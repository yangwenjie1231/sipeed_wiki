{"/maixpy/api/maix/peripheral/pinmap.html":{"title":"maix.peripheral.pinmap","content":" title: maix.peripheral.pinmap maix.peripheral.pinmap module > You can use `maix.peripheral.pinmap` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ## Function ### get\\_pins ```python def get_pins() > list[str] ``` Get all pins of devices item description **return** pin name list, string type. > C++ defination code: > ```cpp > std::vector<std::string> get_pins() > ``` ### get\\_pin\\_functions ```python def get_pin_functions(pin: str) > list[str] ``` Get all function of a pin item description **param** **pin**: pin name, string type.<br> **return** function list, function name is string type. **throw** If pin name error will throwout err.Err.ERR_ARGS error. > C++ defination code: > ```cpp > std::vector<std::string> get_pin_functions(const std::string &pin) > ``` ### set\\_pin\\_function ```python def set_pin_function(pin: str, func: str) > maix.err.Err ``` Set function of a pin item description **param** **pin**: pin name, string type.<br>**func**: which function should this pin use.<br> **return** if set ok, will return err.Err.ERR_NONE, else error occurs. > C++ defination code: > ```cpp > err::Err set_pin_function(const std::string &pin, const std::string &func) > ``` ## Class"},"/maixpy/api/maix/ext_dev/bm8563.html":{"title":"maix.ext_dev.bm8563","content":" title: maix.ext_dev.bm8563 maix.ext_dev.bm8563 module > You can use `maix.ext_dev.bm8563` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ## Function ## Class ### BM8563 Peripheral BM8563 class > C++ defination code: > ```cpp > class BM8563 > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, i2c_bus: int 1) > None ``` BM8563 constructor item description **type** func **param** **i2c_bus**: i2c bus number.<br> **static** False > C++ defination code: > ```cpp > BM8563(int i2c_bus 1) > ``` #### datetime ```python def datetime(self, timetuple: list[int] []) > list[int] ``` Get or set the date and time of the BM8563. item description **type** func **param** **timetuple**: time tuple, like (year, month, day[, hour[, minute[, second]]])<br> **return** time tuple, like (year, month, day[, hour[, minute[, second]]]) **static** False > C++ defination code: > ```cpp > std::vector<int> datetime(std::vector<int> timetuple std::vector<int>()) > ``` #### init ```python def init(self, timetuple: list[int]) > maix.err.Err ``` Initialise the BM8563. item description **type** func **param** **timetuple**: time tuple, like (year, month, day[, hour[, minute[, second]]])<br> **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err init(std::vector<int> timetuple) > ``` #### now ```python def now(self) > list[int] ``` Get get the current datetime. item description **type** func **return** time tuple, like (year, month, day[, hour[, minute[, second]]]) **static** False > C++ defination code: > ```cpp > std::vector<int> now() > ``` #### deinit ```python def deinit(self) > maix.err.Err ``` Deinit the BM8563. item description **type** func **return** err::Err err::Err type, if deinit success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err deinit() > ``` #### hctosys ```python def hctosys(self) > maix.err.Err ``` Set the system time from the BM8563 item description **type** func **return** err::Err type **static** False > C++ defination code: > ```cpp > err::Err hctosys() > ``` #### systohc ```python def systohc(self) > maix.err.Err ``` Set the BM8563 from the system time item description **type** func **return** err::Err type **static** False > C++ defination code: > ```cpp > err::Err systohc() > ```"},"/maixpy/api/maix/ext_dev/qmi8658.html":{"title":"maix.ext_dev.qmi8658","content":" title: maix.ext_dev.qmi8658 maix.ext_dev.qmi8658 module > You can use `maix.ext_dev.qmi8658` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ## Function ## Class ### QMI8658 QMI8656 driver class > C++ defination code: > ```cpp > class QMI8658 > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, i2c_bus: int 1, addr: int 107, freq: int 400000, mode: maix.ext_dev.imu.Mode ..., acc_scale: maix.ext_dev.imu.AccScale ..., acc_odr: maix.ext_dev.imu.AccOdr ..., gyro_scale: maix.ext_dev.imu.GyroScale ..., gyro_odr: maix.ext_dev.imu.GyroOdr ..., block: bool True) > None ``` Construct a new QMI8658 object, will open QMI8658 item description **type** func **param** **i2c_bus**: i2c bus number. Automatically selects the on board qmi8658 when 1 is passed in.<br>**addr**: QMI8658 i2c addr.<br>**freq**: QMI8658 freq<br>**mode**: QMI8658 Mode: ACC_ONLY/GYRO_ONLY/DUAL<br>**acc_scale**: acc scale, see @qmi8658::AccScale<br>**acc_odr**: acc output data rate, see @qmi8658::AccOdr<br>**gyro_scale**: gyro scale, see @qmi8658::GyroScale<br>**gyro_odr**: gyro output data rate, see @qmi8658::GyroOdr<br>**block**: block or non block, defalut is true<br> **static** False > C++ defination code: > ```cpp > QMI8658(int i2c_bus 1, int addr 0x6B, int freq 400000, > maix::ext_dev::imu::Mode mode maix::ext_dev::imu::Mode::DUAL, > maix::ext_dev::imu::AccScale acc_scale maix::ext_dev::imu::AccScale::ACC_SCALE_2G, > maix::ext_dev::imu::AccOdr acc_odr maix::ext_dev::imu::AccOdr::ACC_ODR_8000, > maix::ext_dev::imu::GyroScale gyro_scale maix::ext_dev::imu::GyroScale::GYRO_SCALE_16DPS, > maix::ext_dev::imu::GyroOdr gyro_odr maix::ext_dev::imu::GyroOdr::GYRO_ODR_8000, > bool block true) > ``` #### read ```python def read(self) > list[float] ``` Read data from QMI8658. item description **type** func **return** list type. If only one of the outputs is initialized, only [x,y,z] of that output will be returned.<br>If all outputs are initialized, [acc_x, acc_y, acc_z, gyro_x, gyro_y, gyro_z] is returned. **static** False > C++ defination code: > ```cpp > std::vector<float> read() > ```"},"/maixpy/api/maix/ext_dev/tmc2209.html":{"title":"maix.ext_dev.tmc2209","content":" title: maix.ext_dev.tmc2209 maix.ext_dev.tmc2209 module > You can use `maix.ext_dev.tmc2209` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ## Function ### slide\\_scan ```python def slide_scan(port: str, addr: int, baud: int, step_angle: float, micro_step: int, round_mm: float, speed_mm_s: float, dir: bool True, use_internal_sense_resistors: bool True, run_current_per: int 100, hold_current_per: int 100, conf_save_path: str './slide_conf.bin', force_update: bool True) > None ``` Scan and initialize the slide with the given parameters item description **param** **port**: UART port, string type.<br>**addr**: TMC2209 UART address, range 0x00~0x03, integer type.<br>**baud**: UART baud rate, integer type.<br>**step_angle**: Motor step angle, float type.<br>**micro_step**: Motor micro step, options: 1/2/4/8/16/32/64/128/256, integer type.<br>**round_mm**: Round distance in mm, float type.<br>**speed_mm_s**: Speed of the slide in mm/s, float type.<br>**dir**: Direction of movement, boolean type. Default is true.<br>**use_internal_sense_resistors**: Enable internal sense resistors if true, disable if false, boolean type. Default is true.<br>**run_current_per**: Motor run current percentage, range 0~100(%), integer type. Default is 100%.<br>**hold_current_per**: Motor hold current percentage, range 0~100(%), integer type. Default is 100%.<br>**conf_save_path**: Configuration save path, string type. Default is \"./slide_conf.bin\".<br>**force_update**: Force update the configuration if true, boolean type. Default is true.<br> > C++ defination code: > ```cpp > void slide_scan(const char* port, uint8_t addr, long baud, /* Uart init param */ > float step_angle, uint16_t micro_step, float round_mm, /* Motor init param */ > float speed_mm_s, bool dir true, bool use_internal_sense_resistors true, uint8_t run_current_per 100, > uint8_t hold_current_per 100, const std::string conf_save_path \"./slide_conf.bin\", > bool force_update true /* Driver init param */) > ``` ### slide\\_test ```python def slide_test(port: str, addr: int, baud: int, step_angle: float, micro_step: int, round_mm: float, speed_mm_s: float, dir: bool True, use_internal_sense_resistors: bool True, run_current_per: int 100, hold_current_per: int 100, conf_save_path: str './slide_conf.bin') > None ``` Test the slide with the given parameters\\nThis function tests the slide by moving it in the specified direction until a stall condition is detected, as defined in the configuration file. item description **param** **port**: UART port, string type.<br>**addr**: TMC2209 UART address, range 0x00~0x03, integer type.<br>**baud**: UART baud rate, integer type.<br>**step_angle**: Motor step angle, float type.<br>**micro_step**: Motor micro step, options: 1/2/4/8/16/32/64/128/256, integer type.<br>**round_mm**: Round distance in mm, float type.<br>**speed_mm_s**: Speed of the slide in mm/s, float type.<br>**dir**: Direction of movement, boolean type. Default is true.<br>**use_internal_sense_resistors**: Enable internal sense resistors if true, disable if false, boolean type. Default is true.<br>**run_current_per**: Motor run current percentage, range 0~100(%), integer type. Default is 100%.<br>**hold_current_per**: Motor hold current percentage, range 0~100(%), integer type. Default is 100%.<br>**conf_save_path**: Configuration save path, string type. Default is \"./slide_conf.bin\".<br> > C++ defination code: > ```cpp > void slide_test(const char* port, uint8_t addr, long baud, /* Uart init param */ > float step_angle, uint16_t micro_step, float round_mm, /* Motor init param */ > float speed_mm_s, bool dir true, bool use_internal_sense_resistors true, uint8_t run_current_per 100, > uint8_t hold_current_per 100, const std::string conf_save_path \"./slide_conf.bin\"/* Driver init param */) > ``` ## Class ### Slide Slide Class > C++ defination code: > ```cpp > class Slide > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, port: str, addr: int, baud: int, step_angle: float, micro_step: int, round_mm: float, speed_mm_s: float 1, use_internal_sense_resistors: bool True, run_current_per: int 100, hold_current_per: int 100, cfg_file_path: str '') > None ``` Constructor for Slide\\nInitializes the Slide object with the specified parameters. item description **type** func **param** **port**: UART port, string type.<br>**addr**: TMC2209 UART address, range 0x00~0x03, integer type.<br>**baud**: UART baud rate, integer type.<br>**step_angle**: Motor step angle, float type.<br>**micro_step**: Motor micro step, options: 1/2/4/8/16/32/64/128/256, integer type.<br>**round_mm**: Round distance in mm, float type.<br>**speed_mm_s**: Speed of the slide in mm/s, float type. Default is 1, indicating the use of a default speed factor.<br>**use_internal_sense_resistors**: Enable internal sense resistors if TRUE, disable if FALSE, boolean type. Default is TRUE.<br>**run_current_per**: Motor run current percentage, range 0~100(%), integer type. Default is 100%.<br>**hold_current_per**: Motor hold current percentage, range 0~100(%), integer type. Default is 100%.<br>**cfg_file_path**: Configuration file path, string type. Default is an empty string, indicating no configuration file.<br> **static** False > C++ defination code: > ```cpp > Slide(const char* port, uint8_t addr, long baud, /* Uart init param */ > float step_angle, uint16_t micro_step, float round_mm, /* Motor init param */ > float speed_mm_s 1, bool use_internal_sense_resistors true, uint8_t run_current_per 100, > uint8_t hold_current_per 100, std::string cfg_file_path \"\" /* Driver init param */) > ``` #### load\\_conf ```python def load_conf(self, path: str) > None ``` Load configuration from a file\\nLoads the configuration settings for the slide from the specified file path. item description **type** func **param** **path**: Path to the configuration file, string type.<br> **static** False > C++ defination code: > ```cpp > void load_conf(std::string path) > ``` #### move ```python def move(self, oft: float, speed_mm_s: int 1, check: bool True) > None ``` Move the slide by a specified length\\nMoves the slide by the specified length at the given speed. Optionally checks for stall conditions. item description **type** func **param** **oft**: Length to move, float type.<br>**speed_mm_s**: Speed in mm/s. Default is 1, indicating the use of the default speed set during initialization.<br>**check**: Enable movement check if true, boolean type. Default is true.<br> **static** False > C++ defination code: > ```cpp > void move(float oft, int speed_mm_s 1, bool check true) > ``` #### reset ```python def reset(self, dir: bool False, speed_mm_s: int 1) > None ``` Reset the slide position\\nResets the slide position in the specified direction at the given speed. item description **type** func **param** **dir**: Direction of reset, boolean type. Default is false.<br>**speed_mm_s**: Speed in mm/s. Default is 1, indicating the use of the speed set during initialization.<br> **static** False > C++ defination code: > ```cpp > void reset(bool dir false, int speed_mm_s 1) > ``` #### stop\\_default\\_per Get or set the stop default percentage\\nRetrieves or sets the stop default percentage. If the parameter is 1, it returns the current setting. item description **type** func **param** **per**: Stop default percentage, range 0~100(%), integer type. Default is 1, indicating no change.<br> **return** int Current stop default percentage if per is 1, otherwise the new set percentage. **static** False > C++ defination code: > ```cpp > int stop_default_per(int per 1) > ``` #### run\\_current\\_per ```python def run_current_per(self, per: int 1) > int ``` Get or set the run current percentage\\nRetrieves or sets the run current percentage. If the parameter is 1, it returns the current setting. item description **type** func **param** **per**: Run current percentage, range 0~100(%), integer type. Default is 1, indicating no change.<br> **return** int Current run current percentage if per is 1, otherwise the new set percentage. **static** False > C++ defination code: > ```cpp > int run_current_per(int per 1) > ``` #### hold\\_current\\_per ```python def hold_current_per(self, per: int 1) > int ``` Get or set the hold current percentage\\nRetrieves or sets the hold current percentage. If the parameter is 1, it returns the current setting. item description **type** func **param** **per**: Hold current percentage, range 0~100(%), integer type. Default is 1, indicating no change.<br> **return** int Current hold current percentage if per is 1, otherwise the new set percentage. **static** False > C++ defination code: > ```cpp > int hold_current_per(int per 1) > ``` #### use\\_internal\\_sense\\_resistors ```python def use_internal_sense_resistors(self, b: bool True) > None ``` Enable or disable internal sense resistors\\nEnables or disables the internal sense resistors based on the provided boolean value. item description **type** func **param** **b**: Boolean value to enable (true) or disable (false) internal sense resistors. Default is true.<br> **static** False > C++ defination code: > ```cpp > void use_internal_sense_resistors(bool b true) > ``` ### ScrewSlide ScrewSlide Class > C++ defination code: > ```cpp > class ScrewSlide > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, port: str, addr: int, baud: int, step_angle: float, micro_step: int, screw_pitch: float, speed_mm_s: float 1, use_internal_sense_resistors: bool True, run_current_per: int 100, hold_current_per: int 100) > None ``` Constructor for ScrewSlide item description **type** func **param** **port**: UART port, string type.<br>**addr**: TMC2209 UART address, range 0x00~0x03, integer type.<br>**baud**: UART baud rate, integer type.<br>**step_angle**: Motor step angle, float type.<br>**micro_step**: Motor micro step, options: 1/2/4/8/16/32/64/128/256, integer type.<br>**screw_pitch**: Screw pitch of the slide, integer type.<br>**speed_mm_s**: Speed of the slide in mm/s, 10 means 10mm/s, float type.<br>Default is 1, indicating the use of a default speed factor.<br>**use_internal_sense_resistors**: Enable internal sense resistors if TRUE,<br>disable if FALSE, boolean type. Default is TRUE.<br>**run_current_per**: Motor run current percentage, range 0~100(%), integer type. Default is 100%.<br>**hold_current_per**: Motor hold current percentage, range 0~100(%), integer type. Default is 100%.<br> **static** False > C++ defination code: > ```cpp > ScrewSlide(const char* port, uint8_t addr, long baud, /* Uart init param */ > float step_angle, uint16_t micro_step, float screw_pitch, /* Motor init param */ > float speed_mm_s 1, bool use_internal_sense_resistors true, uint8_t run_current_per 100, > uint8_t hold_current_per 100) > ``` #### move ```python def move(self, oft: float, speed_mm_s: int 1, callback: typing.Callable[[float], bool] None) > None ``` Move the slide by a specified length item description **type** func **param** **oft**: Length to move, 10 means 10mm, float type.<br>Positive values move the slide in the positive direction, negative values move it in the opposite direction.<br>**speed_mm_s**: Speed in mm/s. Default is 1, indicating the use of the default speed set during initialization.<br>**callback**: Callback function to be called during movement.<br>The callback function receives the current progress percentage (0~100%) of the movement.<br>If the callback returns true, the move operation will be terminated immediately. Default is nullptr.<br> **static** False > C++ defination code: > ```cpp > void move(float oft, int speed_mm_s 1, std::function<bool(float)> callback nullptr) > ``` #### reset ```python def reset(self, callback: typing.Callable[[], bool], dir: bool False, speed_mm_s: int 1) > None ``` Reset the slide position item description **type** func **param** **callback**: Callback function to be called during the reset loop.<br>The reset operation will only terminate if the callback returns true.<br>**dir**: Direction of reset. Default is false.<br>**speed_mm_s**: Speed in mm/s. Default is 1, indicating the use of the speed set during initialization.<br> **static** False > C++ defination code: > ```cpp > void reset(std::function<bool(void)> callback, bool dir false, int speed_mm_s 1) > ``` #### run\\_current\\_per ```python def run_current_per(self, per: int 1) > int ``` Get or set the run current percentage item description **type** func **param** **per**: Run current percentage, range 0~100(%).<br>Default is 1, indicating no change and returning the current run current percentage.<br> **return** int Current run current percentage if per is 1, otherwise the new set percentage. **static** False > C++ defination code: > ```cpp > int run_current_per(int per 1) > ``` #### hold\\_current\\_per ```python def hold_current_per(self, per: int 1) > int ``` Get or set the hold current percentage item description **type** func **param** **per**: Hold current percentage, range 0~100(%). Default is 1, indicating no change and returning the current hold current percentage.<br> **return** int Current hold current percentage if per is 1, otherwise the new set percentage. **static** False > C++ defination code: > ```cpp > int hold_current_per(int per 1) > ``` #### use\\_internal\\_sense\\_resistors ```python def use_internal_sense_resistors(self, b: bool True) > None ``` Enable or disable internal sense resistors item description **type** func **param** **b**: Boolean value to enable (true) or disable (false) internal sense resistors. Default is true.<br> **static** False > C++ defination code: > ```cpp > void use_internal_sense_resistors(bool b true) > ```"},"/maixpy/api/maix/ext_dev/imu.html":{"title":"maix.ext_dev.imu","content":" title: maix.ext_dev.imu maix.ext_dev.imu module > You can use `maix.ext_dev.imu` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ### Mode imu mode item describe **values** **ACC_ONLY**: <br>**GYRO_ONLY**: <br>**DUAL**: <br> > C++ defination code: > ```cpp > enum class Mode { > ACC_ONLY 0, > GYRO_ONLY, > DUAL > } > ``` ### AccScale imu acc scale item describe **values** **ACC_SCALE_2G**: <br>**ACC_SCALE_4G**: <br>**ACC_SCALE_8G**: <br>**ACC_SCALE_16G**: <br> > C++ defination code: > ```cpp > enum class AccScale { > ACC_SCALE_2G 0, > ACC_SCALE_4G, > ACC_SCALE_8G, > ACC_SCALE_16G > } > ``` ### AccOdr imu acc output data rate item describe **values** **ACC_ODR_8000**: Accelerometer ODR set to 8000 Hz.<br>**ACC_ODR_4000**: Accelerometer ODR set to 4000 Hz.<br>**ACC_ODR_2000**: Accelerometer ODR set to 2000 Hz.<br>**ACC_ODR_1000**: Accelerometer ODR set to 1000 Hz.<br>**ACC_ODR_500**: Accelerometer ODR set to 500 Hz.<br>**ACC_ODR_250**: Accelerometer ODR set to 250 Hz.<br>**ACC_ODR_125**: Accelerometer ODR set to 125 Hz.<br>**ACC_ODR_62_5**: Accelerometer ODR set to 62.5 Hz.<br>**ACC_ODR_31_25**: Accelerometer ODR set to 31.25 Hz.<br>**ACC_ODR_128**: Accelerometer ODR set to 128 Hz.<br>**ACC_ODR_21**: Accelerometer ODR set to 21 Hz.<br>**ACC_ODR_11**: Accelerometer ODR set to 11 Hz.<br>**ACC_ODR_3**: Accelerometer ODR set to 3 Hz.<br> > C++ defination code: > ```cpp > enum class AccOdr { > ACC_ODR_8000, // Accelerometer ODR set to 8000 Hz. > ACC_ODR_4000, // Accelerometer ODR set to 4000 Hz. > ACC_ODR_2000, // Accelerometer ODR set to 2000 Hz. > ACC_ODR_1000, // Accelerometer ODR set to 1000 Hz. > ACC_ODR_500, // Accelerometer ODR set to 500 Hz. > ACC_ODR_250, // Accelerometer ODR set to 250 Hz. > ACC_ODR_125, // Accelerometer ODR set to 125 Hz. > ACC_ODR_62_5, // Accelerometer ODR set to 62.5 Hz. > ACC_ODR_31_25, // Accelerometer ODR set to 31.25 Hz. > ACC_ODR_128 12, // Accelerometer ODR set to 128 Hz. > ACC_ODR_21, // Accelerometer ODR set to 21 Hz. > ACC_ODR_11, // Accelerometer ODR set to 11 Hz. > ACC_ODR_3, // Accelerometer ODR set to 3 Hz. > } > ``` ### GyroScale imu gyro scale item describe **values** **GYRO_SCALE_16DPS**: Gyroscope scale set to ±16 degrees per second.<br>**GYRO_SCALE_32DPS**: Gyroscope scale set to ±32 degrees per second.<br>**GYRO_SCALE_64DPS**: Gyroscope scale set to ±64 degrees per second.<br>**GYRO_SCALE_128DPS**: Gyroscope scale set to ±128 degrees per second.<br>**GYRO_SCALE_256DPS**: Gyroscope scale set to ±256 degrees per second.<br>**GYRO_SCALE_512DPS**: Gyroscope scale set to ±512 degrees per second.<br>**GYRO_SCALE_1024DPS**: Gyroscope scale set to ±1024 degrees per second.<br>**GYRO_SCALE_2048DPS**: Gyroscope scale set to ±2048 degrees per second.<br> > C++ defination code: > ```cpp > enum class GyroScale { > GYRO_SCALE_16DPS 0, // Gyroscope scale set to ±16 degrees per second. > GYRO_SCALE_32DPS, // Gyroscope scale set to ±32 degrees per second. > GYRO_SCALE_64DPS, // Gyroscope scale set to ±64 degrees per second. > GYRO_SCALE_128DPS, // Gyroscope scale set to ±128 degrees per second. > GYRO_SCALE_256DPS, // Gyroscope scale set to ±256 degrees per second. > GYRO_SCALE_512DPS, // Gyroscope scale set to ±512 degrees per second. > GYRO_SCALE_1024DPS, // Gyroscope scale set to ±1024 degrees per second. > GYRO_SCALE_2048DPS, // Gyroscope scale set to ±2048 degrees per second. > } > ``` ### GyroOdr imu gyro output data rate item describe **values** **GYRO_ODR_8000**: Gyroscope ODR set to 8000 Hz.<br>**GYRO_ODR_4000**: Gyroscope ODR set to 4000 Hz.<br>**GYRO_ODR_2000**: Gyroscope ODR set to 2000 Hz.<br>**GYRO_ODR_1000**: Gyroscope ODR set to 1000 Hz.<br>**GYRO_ODR_500**: Gyroscope ODR set to 500 Hz.<br>**GYRO_ODR_250**: Gyroscope ODR set to 250 Hz.<br>**GYRO_ODR_125**: Gyroscope ODR set to 125 Hz.<br>**GYRO_ODR_62_5**: Gyroscope ODR set to 62.5 Hz.<br>**GYRO_ODR_31_25**: Gyroscope ODR set to 31.25 Hz.<br> > C++ defination code: > ```cpp > enum class GyroOdr { > GYRO_ODR_8000, // Gyroscope ODR set to 8000 Hz. > GYRO_ODR_4000, // Gyroscope ODR set to 4000 Hz. > GYRO_ODR_2000, // Gyroscope ODR set to 2000 Hz. > GYRO_ODR_1000, // Gyroscope ODR set to 1000 Hz. > GYRO_ODR_500, // Gyroscope ODR set to 500 Hz. > GYRO_ODR_250, // Gyroscope ODR set to 250 Hz. > GYRO_ODR_125, // Gyroscope ODR set to 125 Hz. > GYRO_ODR_62_5, // Gyroscope ODR set to 62.5 Hz. > GYRO_ODR_31_25, // Gyroscope ODR set to 31.25 Hz. > } > ``` ## Variable ## Function ## Class ### IMU QMI8656 driver class > C++ defination code: > ```cpp > class IMU > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, driver: str, i2c_bus: int 1, addr: int 107, freq: int 400000, mode: Mode ..., acc_scale: AccScale ..., acc_odr: AccOdr ..., gyro_scale: GyroScale ..., gyro_odr: GyroOdr ..., block: bool True) > None ``` Construct a new IMU object, will open IMU item description **type** func **param** **driver**: driver name, only support \"qmi8656\"<br>**i2c_bus**: i2c bus number. Automatically selects the on board imu when 1 is passed in.<br>**addr**: IMU i2c addr.<br>**freq**: IMU freq<br>**mode**: IMU Mode: ACC_ONLY/GYRO_ONLY/DUAL<br>**acc_scale**: acc scale, see @imu::AccScale<br>**acc_odr**: acc output data rate, see @imu::AccOdr<br>**gyro_scale**: gyro scale, see @imu::GyroScale<br>**gyro_odr**: gyro output data rate, see @imu::GyroOdr<br>**block**: block or non block, defalut is true<br> **static** False > C++ defination code: > ```cpp > IMU(std::string driver, int i2c_bus 1, int addr 0x6B, int freq 400000, > maix::ext_dev::imu::Mode mode maix::ext_dev::imu::Mode::DUAL, > maix::ext_dev::imu::AccScale acc_scale maix::ext_dev::imu::AccScale::ACC_SCALE_2G, > maix::ext_dev::imu::AccOdr acc_odr maix::ext_dev::imu::AccOdr::ACC_ODR_8000, > maix::ext_dev::imu::GyroScale gyro_scale maix::ext_dev::imu::GyroScale::GYRO_SCALE_16DPS, > maix::ext_dev::imu::GyroOdr gyro_odr maix::ext_dev::imu::GyroOdr::GYRO_ODR_8000, > bool block true) > ``` #### read ```python def read(self) > list[float] ``` Read data from IMU. item description **type** func **return** list type. If only one of the outputs is initialized, only [x,y,z] of that output will be returned.<br>If all outputs are initialized, [acc_x, acc_y, acc_z, gyro_x, gyro_y, gyro_z] is returned. **static** False > C++ defination code: > ```cpp > std::vector<float> read() > ``` #### calculate\\_calibration ```python def calculate_calibration(self, time_ms: int 30000) > maix.err.Err ``` Caculate calibration, save calibration data to /maixapp/shart/imu_calibration item description **type** func **param** **time_ms**: caculate max time, unit:ms<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err calculate_calibration(uint64_t time_ms 30 * 1000) > ``` #### get\\_calibration ```python def get_calibration(self) > list[float] ``` Get calibration data item description **type** func **return** return an array, format is [acc_x_bias, acc_y_bias, acc_z_bias, gyro_x_bias, gyro_y_bias, gyro_z_bias]<br>If the calibration file cannot be found, an empty array will be returned. **static** False > C++ defination code: > ```cpp > std::vector<double> get_calibration() > ``` ### Gcsv Gcsv class > C++ defination code: > ```cpp > class Gcsv > ``` #### \\_\\_init\\_\\_ ```python def __init__(self) > None ``` Construct a new IMU object item description **type** func **static** False > C++ defination code: > ```cpp > Gcsv() > ``` #### open ```python def open(self, path: str, tscale: float 0.001, gscale: float 1, ascale: float 1, mscale: float 1, version: str '1.3', id: str 'imu', orientation: str 'YxZ') > maix.err.Err ``` Open a file item description **type** func **param** **path**: the path where data will be saved<br>**tscale**: time scale, default is 0.001<br>**gscale**: gyroscope scale factor, default is 1, unit:g<br>**ascale**: accelerometer scale factor, default is 1, unit:radians/second<br>**mscale**: magnetometer scale factor, default is 1(unused)<br>**version**: version number, default is \"1.3\"<br>**id**: identifier for the IMU, default is \"imu\"<br>**orientation**: sensor orientation, default is \"YxZ\"<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err open(std::string path, double tscale 0.001, double gscale 1, double ascale 1, double mscale 1, std::string version \"1.3\", std::string id \"imu\", std::string orientation \"YxZ\") > ``` #### close ```python def close(self) > maix.err.Err ``` Close file item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err close() > ``` #### is\\_opened ```python def is_opened(self) > bool ``` Check if the object is already open item description **type** func **return** true, opened; false, not opened **static** False > C++ defination code: > ```cpp > bool is_opened() > ``` #### write ```python def write(self, timestamp: float, gyro: list[float], acc: list[float], mag: list[float] []) > maix.err.Err ``` Write imu data to gcsv file item description **type** func **param** **t**: Timestamp of the current data. The actual value is equal to t * tscale. unit:s<br>**gyro**: Gyroscope data must be an array consisting of x, y, and z axis data. The actual value is equal to gyro * gscale. unit:g<br>**acc**: Acceleration data must be an array consisting of x, y, and z axis data. The actual value is equal to acc * ascale.unit:radians/second<br>**mag**: Magnetic data must be an array consisting of x, y, and z axis data. Currently not supported.<br> **static** False > C++ defination code: > ```cpp > err::Err write(double timestamp, std::vector<double> gyro, std::vector<double> acc, std::vector<double> mag std::vector<double>()) > ```"},"/maixpy/api/maix/nn/F.html":{"title":"maix.nn.F","content":" title: maix.nn.F maix.nn.F module > You can use `maix.nn.F` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ## Function ### softmax ```python def softmax(tensor: maix.tensor.Tensor, replace: bool) > maix.tensor.Tensor ``` Softmax, only support 1D tensor, multi dimension tensor will be treated as 1D tensor item description **param** **tensor**: input tensor<br>**replace**: change input tensor data directly, if not, will create a new tensor<br> **throw** If arg error, will raise err.Exception error **return** output tensor, if arg replace is true, return the arg tensor's address.<br>If not replace, return a new object, so In C++, you should delete it manually in this case! > C++ defination code: > ```cpp > tensor::Tensor *softmax(tensor::Tensor *tensor, bool replace) > ``` ## Class"},"/maixpy/api/maix/camera.html":{"title":"maix.camera","content":" title: maix.camera maix.camera module, access camera device and get image from it > You can use `maix.camera` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ## Function ### list\\_devices ```python def list_devices() > list[str] ``` List all supported camera devices. item description **return** Returns the path to the camera device. > C++ defination code: > ```cpp > std::vector<std::string> list_devices() > ``` ### set\\_regs\\_enable ```python def set_regs_enable(enable: bool True) > None ``` Enable set camera registers, default is false, if set to true, will not set camera registers, you can manually set registers by write_reg API. item description **param** **enable**: enable/disable set camera registers<br> > C++ defination code: > ```cpp > void set_regs_enable(bool enable true) > ``` ## Class ### Camera Camera class > C++ defination code: > ```cpp > class Camera > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, width: int 1, height: int 1, format: maix.image.Format ..., device: str None, fps: float 1, buff_num: int 3, open: bool True, raw: bool False) > None ``` Construct a new Camera object.\\nMaximum resolution support 2560x1440. item description **type** func **param** **width**: camera width, default is 1, means auto, mostly means max width of camera support<br>**height**: camera height, default is 1, means auto, mostly means max height of camera support<br>**format**: camera output format, default is image.Format.FMT_RGB888<br>**device**: camera device path, you can get devices by list_devices method, by default(value is NULL(None in MaixPy)) means the first device<br>**fps**: camera fps, default is 1, means auto, mostly means max fps of camera support<br>**buff_num**: camera buffer number, default is 3, means 3 buffer, one used by user, one used for cache the next frame,<br>more than one buffer will accelerate image read speed, but will cost more memory.<br>**open**: If true, camera will automatically call open() after creation. default is true.<br>**raw**: If true, you can use read_raw() to capture the raw image output from the sensor.<br> **static** False > C++ defination code: > ```cpp > Camera(int width 1, int height 1, image::Format format image::FMT_RGB888, const char *device nullptr, double fps 1, int buff_num 3, bool open true, bool raw false) > ``` #### get\\_ch\\_nums ```python def get_ch_nums(self) > int ``` Get the number of channels supported by the camera. item description **type** func **return** Returns the maximum number of channels. **static** False > C++ defination code: > ```cpp > int get_ch_nums() > ``` #### open ```python def open(self, width: int 1, height: int 1, format: maix.image.Format ..., fps: float 1, buff_num: int 1) > maix.err.Err ``` Open camera and run item description **type** func **param** **width**: camera width, default is 1, means auto, mostly means max width of camera support<br>**height**: camera height, default is 1, means auto, mostly means max height of camera support<br>**format**: camera output format, default same as the constructor's format argument<br>**fps**: camera fps, default is 1, means auto, mostly means max fps of camera support<br>**buff_num**: camera buffer number, default is 3, means 3 buffer, one used by user, one used for cache the next frame,<br>more than one buffer will accelerate image read speed, but will cost more memory.<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err open(int width 1, int height 1, image::Format format image::FMT_INVALID, double fps 1, int buff_num 1) > ``` #### read ```python def read(self, buff: capsule None, buff_size: int 0, block: bool True, block_ms: int 1) > maix.image.Image ``` Get one frame image from camera buffer, must call open method before read.\\nIf open method not called, will call it automatically, if open failed, will throw exception!\\nSo call open method before read is recommended. item description **type** func **param** **buff**: buffer to store image data, if buff is nullptr, will alloc memory automatically.<br>In MaixPy, default to None, you can create a image.Image object, then pass img.data() to buff.<br>**block**: block read, default is true, means block util read image successfully,<br>if set to false, will return nullptr if no image in buffer<br>**block_ms**: block read timeout<br> **return** image::Image object, if failed, return nullptr, you should delete if manually in C++ **static** False > C++ defination code: > ```cpp > image::Image *read(void *buff nullptr, size_t buff_size 0, bool block true, int block_ms 1) > ``` #### read\\_raw ```python def read_raw(self) > maix.image.Image ``` Read the raw image and obtain the width, height, and format of the raw image through the returned Image object. item description **type** func **note** The raw image is in a Bayer format, and its width and height are affected by the driver. Modifying the size and format is generally not allowed. **return** image::Image object, if failed, return nullptr, you should delete if manually in C++ **static** False > C++ defination code: > ```cpp > image::Image *read_raw() > ``` #### clear\\_buff ```python def clear_buff(self) > None ``` Clear buff to ensure the next read image is the latest image item description **type** func **static** False > C++ defination code: > ```cpp > void clear_buff() > ``` #### skip\\_frames ```python def skip_frames(self, num: int) > None ``` Read some frames and drop, this is usually used avoid read not stable image when camera just opened. item description **type** func **param** **num**: number of frames to read and drop<br> **static** False > C++ defination code: > ```cpp > void skip_frames(int num) > ``` #### close ```python def close(self) > None ``` Close camera item description **type** func **static** False > C++ defination code: > ```cpp > void close() > ``` #### add\\_channel ```python def add_channel(self, width: int 1, height: int 1, format: maix.image.Format ..., fps: float 1, buff_num: int 3, open: bool True) > Camera ``` Add a new channel and return a new Camera object, you can use close() to close this channel. item description **type** func **param** **width**: camera width, default is 1, means auto, mostly means max width of camera support<br>**height**: camera height, default is 1, means auto, mostly means max height of camera support<br>**format**: camera output format, default is RGB888<br>**fps**: camera fps, default is 1, means auto, mostly means max fps of camera support<br>**buff_num**: camera buffer number, default is 3, means 3 buffer, one used by user, one used for cache the next frame,<br>more than one buffer will accelerate image read speed, but will cost more memory.<br>**open**: If true, camera will automatically call open() after creation. default is true.<br> **return** new Camera object **static** False > C++ defination code: > ```cpp > camera::Camera *add_channel(int width 1, int height 1, image::Format format image::FMT_RGB888, double fps 1, int buff_num 3, bool open true) > ``` #### is\\_opened ```python def is_opened(self) > bool ``` Check if camera is opened item description **type** func **return** true if camera is opened, false if not **static** False > C++ defination code: > ```cpp > bool is_opened() > ``` #### is\\_closed ```python def is_closed(self) > bool ``` check camera device is closed or not item description **type** func **return** closed or not, bool type **static** False > C++ defination code: > ```cpp > bool is_closed() > ``` #### width ```python def width(self) > int ``` Get camera width item description **type** func **return** camera width **static** False > C++ defination code: > ```cpp > int width() > ``` #### height ```python def height(self) > int ``` Get camera height item description **type** func **return** camera height **static** False > C++ defination code: > ```cpp > int height() > ``` #### fps ```python def fps(self) > float ``` Get camera fps item description **type** func **return** camera fps **static** False > C++ defination code: > ```cpp > double fps() > ``` #### format ```python def format(self) > maix.image.Format ``` Get camera output format item description **type** func **return** camera output format, image::Format object **static** False > C++ defination code: > ```cpp > image::Format format() > ``` #### buff\\_num ```python def buff_num(self) > int ``` Get camera buffer number item description **type** func **return** camera buffer number **static** False > C++ defination code: > ```cpp > int buff_num() > ``` #### hmirror ```python def hmirror(self, value: int 1) > int ``` Set/Get camera horizontal mirror item description **type** func **return** camera horizontal mirror **static** False > C++ defination code: > ```cpp > int hmirror(int value 1) > ``` #### vflip ```python def vflip(self, value: int 1) > int ``` Set/Get camera vertical flip item description **type** func **return** camera vertical flip **static** False > C++ defination code: > ```cpp > int vflip(int value 1) > ``` #### device ```python def device(self) > str ``` Get camera device path item description **type** func **return** camera device path **static** False > C++ defination code: > ```cpp > std::string device() > ``` #### write\\_reg ```python def write_reg(self, addr: int, data: int, bit_width: int 8) > maix.err.Err ``` Write camera register item description **type** func **param** **addr**: register address<br>**data**: register data<br>**bit_width**: register data bit width, default is 8<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err write_reg(int addr, int data, int bit_width 8) > ``` #### read\\_reg ```python def read_reg(self, addr: int, bit_width: int 8) > int ``` Read camera register item description **type** func **param** **addr**: register address<br>**bit_width**: register data bit width, default is 8<br> **return** register data, 1 means failed **static** False > C++ defination code: > ```cpp > int read_reg(int addr, int bit_width 8) > ``` #### show\\_colorbar ```python def show_colorbar(self, enable: bool) > maix.err.Err ``` Camera output color bar image for test item description **type** func **param** **enable**: enable/disable color bar<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err show_colorbar(bool enable) > ``` #### get\\_channel ```python def get_channel(self) > int ``` Get channel of camera item description **type** func **return** channel number **static** False > C++ defination code: > ```cpp > int get_channel() > ``` #### set\\_resolution ```python def set_resolution(self, width: int, height: int) > maix.err.Err ``` Set camera resolution item description **type** func **param** **width**: new width<br>**height**: new height<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err set_resolution(int width, int height) > ``` #### set\\_fps ```python def set_fps(self, fps: float) > maix.err.Err ``` Set camera fps item description **type** func **param** **fps**: new fps<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err set_fps(double fps) > ``` #### exposure ```python def exposure(self, value: int 1) > int ``` Set/Get camera exposure item description **type** func **attention** This method will affect the isp and thus the image, so please be careful with it. **param** **value**: exposure time. unit: us<br>If value 1, return exposure time.<br>If value ! 0, set and return exposure time.<br> **return** camera exposure time **static** False > C++ defination code: > ```cpp > int exposure(int value 1) > ``` #### gain ```python def gain(self, value: int 1) > int ``` Set/Get camera gain item description **type** func **attention** This method will affect the isp and thus the image, so please be careful with it. **param** **value**: camera gain.<br>If value 1, returns camera gain.<br>If value ! 0, set and return camera gain.<br> **return** camera gain **static** False > C++ defination code: > ```cpp > int gain(int value 1) > ``` #### luma ```python def luma(self, value: int 1) > int ``` Set/Get camera luma item description **type** func **attention** This method will affect the isp and thus the image, so please be careful with it. **param** **value**: luma value, range is [0, 100]<br>If value 1, returns luma value.<br>If value ! 0, set and return luma value.<br> **return** returns luma value **static** False > C++ defination code: > ```cpp > int luma(int value 1) > ``` #### constrast ```python def constrast(self, value: int 1) > int ``` Set/Get camera constrast item description **type** func **attention** This method will affect the isp and thus the image, so please be careful with it. **param** **value**: constrast value, range is [0, 100]<br>If value 1, returns constrast value.<br>If value ! 0, set and return constrast value.<br> **return** returns constrast value **static** False > C++ defination code: > ```cpp > int constrast(int value 1) > ``` #### saturation ```python def saturation(self, value: int 1) > int ``` Set/Get camera saturation item description **type** func **attention** This method will affect the isp and thus the image, so please be careful with it. **param** **value**: saturation value, range is [0, 100]<br>If value 1, returns saturation value.<br>If value ! 0, set and return saturation value.<br> **return** returns saturation value **static** False > C++ defination code: > ```cpp > int saturation(int value 1) > ``` #### awb\\_mode ```python def awb_mode(self, value: int 1) > int ``` Set/Get white balance mode (deprecated interface) item description **type** func **attention** This method will affect the isp and thus the image, so please be careful with it.<br>This interface may be deprecated in the future, and there may be incompatibilities in the definition of the parameters of the new interface **param** **value**: value 0, means set white balance to auto mode, value 1, means set white balance to manual mode, default is auto mode.<br> **return** returns awb mode **static** False > C++ defination code: > ```cpp > int awb_mode(int value 1) > ``` #### set\\_awb ```python def set_awb(self, mode: int 1) > int ``` Set/Get white balance mode item description **type** func **attention** This method will affect the isp and thus the image, so please be careful with it. **param** **value**: value 0, means set white balance to manual mode, value 1, means set white balance to auto mode, default is auto mode.<br> **return** returns awb mode **static** False > C++ defination code: > ```cpp > int set_awb(int mode 1) > ``` #### exp\\_mode ```python def exp_mode(self, value: int 1) > int ``` Set/Get exposure mode (deprecated interface) item description **type** func **attention** This method will affect the isp and thus the image, so please be careful with it.<br>This interface may be deprecated in the future, and there may be incompatibilities in the definition of the parameters of the new interface **param** **value**: value 0, means set exposure to auto mode, value 1, means set exposure to manual mode, default is auto mode.<br> **return** returns exposure mode **static** False > C++ defination code: > ```cpp > int exp_mode(int value 1) > ``` #### set\\_windowing ```python def set_windowing(self, roi: list[int]) > maix.err.Err ``` Set window size of camera item description **type** func **param** **roi**: Support two input formats, [x,y,w,h] set the coordinates and size of the window;<br>[w,h] set the size of the window, when the window is centred.<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err set_windowing(std::vector<int> roi) > ```"},"/maixpy/api/index.html":{"title":"MaixPy API -- Maix AI machine vision platform Python API","content":" title: MaixPy API Maix AI machine vision platform Python API **You can read API doc at [MaixPy API on Sipeed Wiki](https://wiki.sipeed.com/maixpy/api/index.html)** If you want to preview API doc offline, build MaixPy, and API doc will be generated in `MaixPy/docs/api/` directory. > For MaixPy developer: This API documentation is generated from the source code, DO NOT edit this file manually! MaixPy API documentation, modules: module brief [maix.err](./maix/err.html) maix.err module [maix.tensor](./maix/tensor.html) maix.tensor module [maix.image](./maix/image.html) maix.image module, image related definition and functions [maix.camera](./maix/camera.html) maix.camera module, access camera device and get image from it [maix.display](./maix/display.html) maix.display module, control display device and show image on it [maix.ext_dev](./maix/ext_dev.html) maix.ext_dev module [maix.audio](./maix/audio.html) maix.audio module [maix.tracker](./maix/tracker.html) maix.tracker module [maix.http](./maix/http.html) maix.http module [maix.rtsp](./maix/rtsp.html) maix.rtsp module [maix.rtmp](./maix/rtmp.html) maix.rtmp module [maix.touchscreen](./maix/touchscreen.html) maix.touchscreen module [maix.video](./maix/video.html) maix.video module [maix.network](./maix/network.html) maix.network module [maix.comm](./maix/comm.html) maix.comm module [maix.fs](./maix/fs.html) maix.fs module [maix.app](./maix/app.html) maix.app module [maix.protocol](./maix/protocol.html) maix.protocol module [maix.time](./maix/time.html) maix.time module [maix.example](./maix/example.html) example module, this will be maix.example module in MaixPy, maix::example namespace in MaixCDK [maix.util](./maix/util.html) maix.util module [maix.thread](./maix/thread.html) maix.thread module [maix.sys](./maix/sys.html) maix.sys module [maix.i18n](./maix/i18n.html) maix.i18n module [maix.peripheral](./maix/peripheral.html) Chip's peripheral driver [maix.nn](./maix/nn.html) maix.nn module "},"/maixpy/api/maix/rtsp.html":{"title":"maix.rtsp","content":" title: maix.rtsp maix.rtsp module > You can use `maix.rtsp` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ### RtspStreamType The stream type of rtsp item describe **values** **RTSP_STREAM_NONE**: format invalid<br>**RTSP_STREAM_H265**: <br> > C++ defination code: > ```cpp > enum RtspStreamType > { > RTSP_STREAM_NONE 0, // format invalid > RTSP_STREAM_H265, > } > ``` ## Variable ## Function ## Class ### Region Region class > C++ defination code: > ```cpp > class Region > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, x: int, y: int, width: int, height: int, format: maix.image.Format, camera: maix.camera.Camera) > None ``` Construct a new Region object item description **type** func **param** **x**: region coordinate x<br>**y**: region coordinate y<br>**width**: region width<br>**height**: region height<br>**format**: region format<br>**camera**: bind region to camera<br> **static** False > C++ defination code: > ```cpp > Region(int x, int y, int width, int height, image::Format format, camera::Camera *camera) > ``` #### get\\_canvas ```python def get_canvas(self) > maix.image.Image ``` Return an image object from region item description **type** func **return** image object **static** False > C++ defination code: > ```cpp > image::Image *get_canvas() > ``` #### update\\_canvas ```python def update_canvas(self) > maix.err.Err ``` Update canvas item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err update_canvas() > ``` ### Rtsp Rtsp class > C++ defination code: > ```cpp > class Rtsp > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, ip: str '', port: int 8554, fps: int 30, stream_type: RtspStreamType ...) > None ``` Construct a new Video object item description **type** func **param** **ip**: rtsp ip<br>**port**: rtsp port<br>**fps**: rtsp fps<br>**stream_type**: rtsp stream type<br> **static** False > C++ defination code: > ```cpp > Rtsp(std::string ip std::string(), int port 8554, int fps 30, rtsp::RtspStreamType stream_type rtsp::RtspStreamType::RTSP_STREAM_H265) > ``` #### start ```python def start(self) > maix.err.Err ``` start rtsp item description **type** func **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err start() > ``` #### start (overload 1) stop rtsp item description **type** func **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err stop() > ``` #### bind\\_camera ```python def bind_camera(self, camera: maix.camera.Camera) > maix.err.Err ``` Bind camera item description **type** func **param** **camera**: camera object<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err bind_camera(camera::Camera *camera) > ``` #### write ```python def write(self, frame: ...) > maix.err.Err ``` Write data to rtsp item description **type** func **param** **frame**: video frame data<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err write(video::Frame &frame) > ``` #### get\\_url ```python def get_url(self) > str ``` Get url of rtsp item description **type** func **return** url of rtsp **static** False > C++ defination code: > ```cpp > std::string get_url() > ``` #### get\\_urls ```python def get_urls(self) > list[str] ``` Get url list of rtsp item description **type** func **return** url list of rtsp **static** False > C++ defination code: > ```cpp > std::vector<std::string> get_urls() > ``` #### to\\_camera ```python def to_camera(self) > maix.camera.Camera ``` Get camera object from rtsp item description **type** func **return** camera object **static** False > C++ defination code: > ```cpp > camera::Camera *to_camera() > ``` #### rtsp\\_is\\_start ```python def rtsp_is_start(self) > bool ``` return rtsp start status item description **type** func **return** true means rtsp is start, false means rtsp is stop. **static** False > C++ defination code: > ```cpp > bool rtsp_is_start() > ``` #### add\\_region ```python def add_region(self, x: int, y: int, width: int, height: int, format: maix.image.Format ...) > Region ``` return a region object, you can draw image on the region. item description **type** func **param** **x**: region coordinate x<br>**y**: region coordinate y<br>**width**: region width<br>**height**: region height<br>**format**: region format, support Format::FMT_BGRA8888 only<br> **return** the reigon object **static** False > C++ defination code: > ```cpp > rtsp::Region *add_region(int x, int y, int width, int height, image::Format format image::Format::FMT_BGRA8888) > ``` #### update\\_region ```python def update_region(self, region: Region) > maix.err.Err ``` update and show region item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err update_region(rtsp::Region &region) > ``` #### del\\_region ```python def del_region(self, region: Region) > maix.err.Err ``` del region item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err del_region(rtsp::Region *region) > ``` #### draw\\_rect ```python def draw_rect(self, id: int, x: int, y: int, width: int, height: int, color: maix.image.Color, thickness: int 1) > maix.err.Err ``` Draw a rectangle on the canvas item description **type** func **param** **id**: region id<br>**x**: rectangle coordinate x<br>**y**: rectangle coordinate y<br>**width**: rectangle width<br>**height**: rectangle height<br>**color**: rectangle color<br>**thickness**: rectangle thickness. If you set it to 1, the rectangle will be filled.<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err draw_rect(int id, int x, int y, int width, int height, image::Color color, int thickness 1) > ``` #### draw\\_string ```python def draw_string(self, id: int, x: int, y: int, str: str, color: maix.image.Color, size: int 16, thickness: int 1) > maix.err.Err ``` Draw a string on the canvas item description **type** func **param** **id**: region id<br>**x**: string coordinate x<br>**y**: string coordinate y<br>**str**: string<br>**color**: string color<br>**size**: string size<br>**thickness**: string thickness<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err draw_string(int id, int x, int y, const char *str, image::Color color, int size 16, int thickness 1) > ```"},"/maixpy/api/maix/peripheral.html":{"title":"maix.peripheral","content":" title: maix.peripheral Chip's peripheral driver > You can use `maix.peripheral` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module module brief [key](./peripheral/key.html) maix.peripheral.key module [i2c](./peripheral/i2c.html) maix.peripheral.i2c module [spi](./peripheral/spi.html) maix.peripheral.spi module [pwm](./peripheral/pwm.html) maix.peripheral.pwm module [wdt](./peripheral/wdt.html) maix.peripheral.wdt module [adc](./peripheral/adc.html) maix.peripheral.adc module [pinmap](./peripheral/pinmap.html) maix.peripheral.pinmap module [uart](./peripheral/uart.html) maix uart peripheral driver [gpio](./peripheral/gpio.html) maix.peripheral.gpio module [hid](./peripheral/hid.html) maix.peripheral.hid module [timer](./peripheral/timer.html) maix.peripheral.timer module ## Enum ## Variable ## Function ## Class"},"/maixpy/api/maix/tracker.html":{"title":"maix.tracker","content":" title: maix.tracker maix.tracker module > You can use `maix.tracker` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ## Function ## Class ### Object tracker.Object class > C++ defination code: > ```cpp > class Object > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, x: int, y: int, w: int, h: int, class_id: int, score: float) > None ``` tracker.Object class constructor item description **type** func **static** False > C++ defination code: > ```cpp > Object(const int &x, const int &y, const int &w, const int &h, const int &class_id, const float &score) > ``` #### x position x attribute. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int x > ``` #### y position y attribute. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int y > ``` #### w position rectangle width. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int w > ``` #### h position rectangle height. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int h > ``` #### class\\_id object class id, int type. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int class_id > ``` #### score object score(prob). item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float score > ``` ### Track tracker.Track class > C++ defination code: > ```cpp > class Track > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, id: int, score: float, lost: bool, start_frame_id: int, frame_id: int) > None ``` tracker.Track class constructor item description **type** func **static** False > C++ defination code: > ```cpp > Track(const size_t &id, const float &score, const bool &lost, const size_t &start_frame_id, const size_t &frame_id) > ``` #### id track id. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > size_t id > ``` #### score track score(prob). item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float score > ``` #### lost whether this track lost. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool lost > ``` #### start\\_frame\\_id track start frame id. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > size_t start_frame_id > ``` #### frame\\_id track current frame id. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > size_t frame_id > ``` #### history track position history, the last one is latest position. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::deque<tracker::Object> history > ``` ### ByteTracker tracker.ByteTracker class > C++ defination code: > ```cpp > class ByteTracker > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, max_lost_buff_num: int 60, track_thresh: float 0.5, high_thresh: float 0.6, match_thresh: float 0.8, max_history: int 20) > None ``` tracker.ByteTracker class constructor item description **type** func **param** **max_lost_buff_num**: the frames for keep lost tracks.<br>**track_thresh**: tracking confidence threshold.<br>**high_thresh**: threshold to add to new track.<br>**match_thresh**: matching threshold for tracking, e.g. one object in two frame iou < match_thresh we think they are the same obj.<br>**max_history**: max tack's position history length.<br> **static** False > C++ defination code: > ```cpp > ByteTracker(const int &max_lost_buff_num 60, > const float &track_thresh 0.5, > const float &high_thresh 0.6, > const float &match_thresh 0.8, > const int &max_history 20) > ``` #### update ```python def update(self, objs: list[Object]) > list[Track] ``` update tracks according to current detected objects. item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<tracker::Track> update(const std::vector<tracker::Object> &objs) > ```"},"/maixpy/api/maix/util.html":{"title":"maix.util","content":" title: maix.util maix.util module > You can use `maix.util` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ## Function ### do\\_exit\\_function ```python def do_exit_function() > None ``` exec all of exit function > C++ defination code: > ```cpp > void do_exit_function() > ``` ### register\\_atexit ```python def register_atexit() > None ``` Registering default processes that need to be executed on exit > C++ defination code: > ```cpp > void register_atexit() > ``` ## Class"},"/maixpy/api/maix/tensor.html":{"title":"maix.tensor","content":" title: maix.tensor maix.tensor module > You can use `maix.tensor` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ### DType Tensor data types item describe **values** **UINT8**: <br>**INT8**: <br>**UINT16**: <br>**INT16**: <br>**UINT32**: <br>**INT32**: <br>**FLOAT16**: <br>**FLOAT32**: <br>**FLOAT64**: <br>**BOOL**: <br>**DTYPE_MAX**: <br> > C++ defination code: > ```cpp > enum DType > { > UINT8 0, > INT8, > UINT16, > INT16, > UINT32, > INT32, > FLOAT16, > FLOAT32, > FLOAT64, > BOOL, > // STRING, > // OBJECT, > DTYPE_MAX > } > ``` ## Variable ### dtype\\_size Tensor data type size in bytes item description **attention** It's a copy of this variable in MaixPy,<br>so change it in C++ (e.g. update var in hello function) will not take effect the var inMaixPy.<br>So we add const for this var to avoid this mistake. **value** **{<br> 1, // UINT8<br> 1, // INT8<br> 2, // UINT16<br> 2, // INT16<br> 4, // UINT32<br> 4, // INT32<br> 2, // FLOAT16<br> 4, // FLOAT32<br> 8, // FLOAT64<br> 1, // BOOL<br> // 1, // STRING<br> // 1, // OBJECT<br> 0<br> }** **readonly** True > C++ defination code: > ```cpp > const std::vector<int> dtype_size { > 1, // UINT8 > 1, // INT8 > 2, // UINT16 > 2, // INT16 > 4, // UINT32 > 4, // INT32 > 2, // FLOAT16 > 4, // FLOAT32 > 8, // FLOAT64 > 1, // BOOL > // 1, // STRING > // 1, // OBJECT > 0 > } > ``` ### dtype\\_name Tensor data type name item description **value** **{<br> \"uint8\",<br> \"int8\",<br> \"uint16\",<br> \"int16\",<br> \"uint32\",<br> \"int32\",<br> \"float16\",<br> \"float32\",<br> \"float64\",<br> \"bool\",<br> // \"string\",<br> // \"object\",<br> \"invalid\"<br> }** **readonly** True > C++ defination code: > ```cpp > const std::vector<std::string> dtype_name { > \"uint8\", > \"int8\", > \"uint16\", > \"int16\", > \"uint32\", > \"int32\", > \"float16\", > \"float32\", > \"float64\", > \"bool\", > // \"string\", > // \"object\", > \"invalid\" > } > ``` ## Function ### tensor\\_from\\_numpy\\_float32 ```python def tensor_from_numpy_float32(array: numpy.ndarray[numpy.float32], copy: bool True) > Tensor ``` float32 type numpy ndarray object to tensor.Tensor object. item description **param** **array**: numpy array object.<br>**copy**: if true, will alloc new buffer and copy data, else will directly use array's data buffer, default true.<br>Use this arg carefully, when set to false, ther array MUST keep alive until we don't use the return tensor of this func, or will cause program crash.<br> **return** tensor.Tensor object. > C++ defination code: > ```cpp > tensor::Tensor *tensor_from_numpy_float32(py::array_t<float, py::array::c_style> array, bool copy true) > ``` ### tensor\\_from\\_numpy\\_uint8 ```python def tensor_from_numpy_uint8(array: numpy.ndarray[numpy.uint8], copy: bool True) > Tensor ``` uint8 type numpy ndarray object to tensor.Tensor object. item description **param** **array**: numpy array object.<br>**copy**: if true, will alloc new buffer and copy data, else will directly use array's data buffer, default true.<br>Use this arg carefully, when set to false, ther array MUST keep alive until we don't use the return tensor of this func, or will cause program crash.<br> **return** tensor.Tensor object. > C++ defination code: > ```cpp > tensor::Tensor *tensor_from_numpy_uint8(py::array_t<uint8_t, py::array::c_style> array, bool copy true) > ``` ### tensor\\_from\\_numpy\\_int8 ```python def tensor_from_numpy_int8(array: numpy.ndarray[numpy.int8], copy: bool True) > Tensor ``` int8 type numpy ndarray object to tensor.Tensor object. item description **param** **array**: numpy array object.<br>**copy**: if true, will alloc new buffer and copy data, else will directly use array's data buffer, default true.<br>Use this arg carefully, when set to false, ther array MUST keep alive until we don't use the return tensor of this func, or will cause program crash.<br> **return** tensor.Tensor object. > C++ defination code: > ```cpp > tensor::Tensor *tensor_from_numpy_int8(py::array_t<int8_t, py::array::c_style> array, bool copy true) > ``` ### tensor\\_to\\_numpy\\_float32 ```python def tensor_to_numpy_float32(t: Tensor, copy: bool True) > numpy.ndarray[numpy.float32] ``` tensor.Tensor object to float32 type numpy ndarray object. item description **param** **t**: tensor.Tensor object.<br>**copy**: Whether alloc new Tensor and copy data or not,<br>if not copy, array object will directly use arg's data buffer, will faster but change array will affect arg's data, default true.<br> **return** numpy array object > C++ defination code: > ```cpp > py::array_t<float, py::array::c_style> tensor_to_numpy_float32(tensor::Tensor *t, bool copy true) > ``` ### tensor\\_to\\_numpy\\_uint8 ```python def tensor_to_numpy_uint8(t: Tensor, copy: bool True) > numpy.ndarray[numpy.uint8] ``` tensor.Tensor object to int8 type numpy ndarray object. item description **param** **t**: tensor.Tensor object.<br>**copy**: Whether alloc new Tensor and copy data or not,<br>if not copy, array object will directly use arg's data buffer, will faster but change array will affect arg's data, default true.<br> **return** numpy array object > C++ defination code: > ```cpp > py::array_t<uint8_t, py::array::c_style> tensor_to_numpy_uint8(tensor::Tensor *t, bool copy true) > ``` ### tensor\\_to\\_numpy\\_int8 ```python def tensor_to_numpy_int8(t: Tensor, copy: bool True) > numpy.ndarray[numpy.int8] ``` tensor.Tensor object to int8 type numpy ndarray object. item description **param** **t**: tensor.Tensor object.<br>**copy**: Whether alloc new Tensor and copy data or not,<br>if not copy, array object will directly use arg's data buffer, will faster but change array will affect arg's data, default true.<br> **return** numpy array object > C++ defination code: > ```cpp > py::array_t<int8_t, py::array::c_style> tensor_to_numpy_int8(tensor::Tensor *t, bool copy true) > ``` ## Class ### Tensor Tensor class > C++ defination code: > ```cpp > class Tensor > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, shape: list[int], dtype: DType) > None ``` Tensor constructor item description **type** func **param** **shape**: tensor shape, a int list<br>**dtype**: tensor element data type, see DType of this module<br> **static** False > C++ defination code: > ```cpp > Tensor(std::vector<int> shape, tensor::DType dtype) > ``` #### to\\_str ```python def to_str(self) > str ``` To string item description **type** func **static** False > C++ defination code: > ```cpp > std::string to_str() > ``` #### \\_\\_str\\_\\_ ```python def __str__(self) > str ``` To string item description **type** func **static** False > C++ defination code: > ```cpp > std::string __str__() > ``` #### shape ```python def shape(self) > list[int] ``` get tensor shape item description **type** func **return** tensor shape, a int list **static** False > C++ defination code: > ```cpp > std::vector<int> shape() > ``` #### expand\\_dims ```python def expand_dims(self, axis: int) > None ``` expand tensor shape item description **type** func **param** **axis**: axis to expand<br> **static** False > C++ defination code: > ```cpp > void expand_dims(int axis) > ``` #### reshape ```python def reshape(self, shape: list[int]) > None ``` reshape tensor shape, if size not match, it will throw an err::Exception item description **type** func **param** **shape**: new shape<br> **static** False > C++ defination code: > ```cpp > void reshape(std::vector<int> shape) > ``` #### flatten ```python def flatten(self) > None ``` Flatten tensor shape to 1D item description **type** func **static** False > C++ defination code: > ```cpp > void flatten() > ``` #### dtype ```python def dtype(self) > DType ``` get tensor data type item description **type** func **return** tensor data type, see DType of this module **static** False > C++ defination code: > ```cpp > tensor::DType dtype() > ``` #### to\\_float\\_list ```python def to_float_list(self) > list[float] ``` get tensor data and return a list item description **type** func **return** list type data **static** False > C++ defination code: > ```cpp > std::valarray<float>* to_float_list() > ``` #### argmax ```python def argmax(self, axis: int 65535) > Tensor ``` argmax of tensor item description **type** func **param** **axis**: By default, the index is into the flattened array, otherwise along the specified axis., wrong axis will throw an err::Exception<br> **return** argmax result, you need to delete it after use in C++. **static** False > C++ defination code: > ```cpp > tensor::Tensor *argmax(int axis 0xffff) > ``` #### argmax1 ```python def argmax1(self) > int ``` argmax1, flattened data max index item description **type** func **return** argmax result, int type **static** False > C++ defination code: > ```cpp > int argmax1() > ``` ### Tensors Tensors > C++ defination code: > ```cpp > class Tensors > ``` #### \\_\\_init\\_\\_ ```python def __init__(self) > None ``` Constructor of Tensors item description **type** func **static** False > C++ defination code: > ```cpp > Tensors() > ``` #### add\\_tensor ```python def add_tensor(self, key: str, tensor: Tensor, copy: bool, auto_delete: bool) > None ``` Add tensor item description **type** func **static** False > C++ defination code: > ```cpp > void add_tensor(const std::string &key, tensor::Tensor *tensor, bool copy, bool auto_delete) > ``` #### rm\\_tensor ```python def rm_tensor(self, key: str) > None ``` Remove tensor item description **type** func **static** False > C++ defination code: > ```cpp > void rm_tensor(const std::string &key) > ``` #### clear ```python def clear(self) > None ``` Clear tensors item description **type** func **static** False > C++ defination code: > ```cpp > void clear() > ``` #### get\\_tensor ```python def get_tensor(self, key: str) > Tensor ``` Get tensor by key item description **type** func **static** False > C++ defination code: > ```cpp > tensor::Tensor &get_tensor(const std::string &key) > ``` #### \\_\\_getitem\\_\\_ ```python def __getitem__(self, key: str) > Tensor ``` Operator [] item description **type** func **static** False > C++ defination code: > ```cpp > tensor::Tensor &operator[](const std::string &key) > ``` #### \\_\\_len\\_\\_ ```python def __len__(self) > int ``` Size item description **type** func **static** False > C++ defination code: > ```cpp > size_t size() > ``` #### keys ```python def keys(self) > list[str] ``` Get names item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<std::string> keys() > ``` #### tensors Tensors data, dict type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::map<std::string, tensor::Tensor*> tensors > ```"},"/maixpy/api/maix/touchscreen.html":{"title":"maix.touchscreen","content":" title: maix.touchscreen maix.touchscreen module > You can use `maix.touchscreen` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ## Function ## Class ### TouchScreen TouchScreen class > C++ defination code: > ```cpp > class TouchScreen > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, device: str '', open: bool True) > None ``` Construct a new TouchScreen object item description **type** func **param** **device**: touchscreen device path, you can get devices by list_devices method, by default(value is NULL(None in MaixPy)) means the first device<br>**open**: If true, touchscreen will automatically call open() after creation. default is true.<br> **static** False > C++ defination code: > ```cpp > TouchScreen(const std::string &device \"\", bool open true) > ``` #### open ```python def open(self) > maix.err.Err ``` open touchscreen device item description **type** func **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err open() > ``` #### close ```python def close(self) > maix.err.Err ``` close touchscreen device item description **type** func **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err close() > ``` #### read ```python def read(self) > list[int] ``` read touchscreen device item description **type** func **attention** This method will discard same event in buffer, that is:<br>if too many move event in buffer when call this method, it will only return the last one,<br>and if read pressed or released event, it will return immediately. **return** Returns a list include x, y, pressed state **static** False > C++ defination code: > ```cpp > std::vector<int> read() > ``` #### read (overload 1) read touchscreen device item description **type** func **attention** This method will return immediately if have event, so it's better to use available() to check if have more event in buffer,<br>or too much event in buffer when your program call this read() interval is too long will make your program slow. **return** Returns a list include x, y, pressed state **static** False > C++ defination code: > ```cpp > std::vector<int> read0() > ``` #### available ```python def available(self, timeout: int 0) > bool ``` If we need to read from touchscreen, for event driven touchscreen means have event or not item description **type** func **param** **timeout**: 1 means block, 0 means no block, >0 means timeout, default is 0, unit is ms.<br> **return** true if need to read(have event), false if not **static** False > C++ defination code: > ```cpp > bool available(int timeout 0) > ``` #### is\\_opened ```python def is_opened(self) > bool ``` Check if touchscreen is opened item description **type** func **return** true if touchscreen is opened, false if not **static** False > C++ defination code: > ```cpp > bool is_opened() > ```"},"/maixpy/api/maix/example.html":{"title":"maix.example","content":" title: maix.example example module, this will be maix.example module in MaixPy, maix::example namespace in MaixCDK > You can use `maix.example` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ### Kind Example enum(not recommend! See Kind2) item describe **values** **KIND_NONE**: Kind none, value always 0, other enum value will auto increase<br>**KIND_DOG**: Kind dog<br>**KIND_CAT**: Kind cat, value is auto generated according to KING_DOG<br>**KIND_BIRD**: <br>**KIND_MAX**: Max Kind quantity<br>You can get max Kind value by KIND_MAX 1<br> > C++ defination code: > ```cpp > enum Kind > { > KIND_NONE 0, /** Kind none, value always 0, other enum value will auto increase */ > KIND_DOG, /** Kind dog*/ > KIND_CAT, // Kind cat, value is auto generated according to KING_DOG > KIND_BIRD, > KIND_MAX /* Max Kind quantity, > You can get max Kind value by KIND_MAX 1 > */ > } > ``` ### Kind2 Example enum class(recommend!) item describe **values** **NONE**: Kind none, value always 0, other enum value will auto increase<br>**DOG**: Kind dog<br>**CAT**: Kind cat, value is auto generated according to KING_DOG<br>**BIRD**: <br>**MAX**: Max Kind quantity<br>You can get max Kind value by KIND_MAX 1<br> > C++ defination code: > ```cpp > enum class Kind2 > { > NONE 0, /** Kind none, value always 0, other enum value will auto increase */ > DOG, /** Kind dog*/ > CAT, // Kind cat, value is auto generated according to KING_DOG > BIRD, > MAX /* Max Kind quantity, > You can get max Kind value by KIND_MAX 1 > */ > } > ``` ## Variable ### var1 Example module variable item description **attention** It's a copy of this variable in MaixPy,<br>so change it in C++ (e.g. update var in hello function) will not take effect the var inMaixPy.<br>So we add const for this var to avoid this mistake. **value** **\"Sipeed\"** **readonly** True > C++ defination code: > ```cpp > const std::string var1 \"Sipeed\" > ``` ### list\\_var Tensor data type size in bytes item description **attention** **1**. DO NOT use C/C++ array directly for python API, the python wrapper not support it.<br>Use std::vector instead.<br>**2**. It's a copy of this variable in MaixPy,<br>so change it in C++ (e.g. update var in hello function) will not take effect the var inMaixPy.<br>So we add const for this var to avoid this mistake.<br> **value** **{<br> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9}** **readonly** True > C++ defination code: > ```cpp > const std::vector<int> list_var { > 0, 1, 2, 3, 4, 5, 6, 7, 8, 9} > ``` ### test\\_var Example module variable test_var item description **attention** It's a copy of this variable in MaixPy, so if you change it in C++, it will not take effect in MaixPy.<br>And change it in MaixPy will not take effect in C++ as well !!!<br>If you want to use vars shared between C++ and MaixPy, you can create a class and use its member. **value** **100** **readonly** False > C++ defination code: > ```cpp > int test_var 100 > ``` ## Function ### hello ```python def hello(name: str) > str ``` say hello to someone item description **param** **name**: direction [in], name of someone, string type<br> **return** string type, content is hello + name > C++ defination code: > ```cpp > std::string hello(std::string name) > ``` ### change\\_arg\\_name ```python def change_arg_name(e: Example) > Example ``` Change arg name example item description **param** **e**: Example object<br> **return** same as arg > C++ defination code: > ```cpp > example::Example *change_arg_name(example::Example *e) > ``` ### change\\_arg\\_name2 ```python def change_arg_name2(e: Example) > None ``` Change arg name example item description **param** **e**: Example object<br> > C++ defination code: > ```cpp > void change_arg_name2(example::Example &e) > ``` ## Class ### Test Test class > C++ defination code: > ```cpp > class Test > ``` #### \\_\\_init\\_\\_ ```python def __init__(self) > None ``` Test constructor item description **type** func **static** False > C++ defination code: > ```cpp > Test() > ``` ### Example Example class\\nthis class will be export to MaixPy as maix.example.Example > C++ defination code: > ```cpp > class Example > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, name: str, age: int 18, pet: Kind ...) > None ``` Example constructor\\nthis constructor will be export to MaixPy as maix.example.Example.__init__ item description **type** func **param** **name**: direction [in], name of Example, string type<br>**age**: direction [in], age of Example, int type, default is 18, value range is [0, 100]<br> **attention** to make auto generate code work, param Kind should with full namespace name `example::Kind` instead of `Kind`,<br>namespace `maix` can be ignored. **static** False > C++ defination code: > ```cpp > Example(std::string &name, int age 18, example::Kind pet example::KIND_NONE) > ``` #### get\\_name ```python def get_name(self) > str ``` get name of Example\\nyou can also get name by property `name`. item description **type** func **return** name of Example, string type **static** False > C++ defination code: > ```cpp > std::string get_name() > ``` #### get\\_age ```python def get_age(self) > int ``` get age of Example item description **type** func **return** age of Example, int type, value range is [0, 100] **static** False > C++ defination code: > ```cpp > int get_age() > ``` #### set\\_name ```python def set_name(self, name: str) > None ``` set name of Example item description **type** func **param** **name**: name of Example, string type<br> **static** False > C++ defination code: > ```cpp > void set_name(std::string name) > ``` #### set\\_age ```python def set_age(self, age: int) > None ``` set age of Example item description **type** func **param** **age**: age of Example, int type, value range is [0, 100]<br> **static** False > C++ defination code: > ```cpp > void set_age(int age) > ``` #### set\\_pet ```python def set_pet(self, pet: Kind) > None ``` Example enum member item description **type** func **attention** **static** False > C++ defination code: > ```cpp > void set_pet(example::Kind pet) > ``` #### get\\_pet ```python def get_pet(self) > Kind ``` Example enum member item description **type** func **static** False > C++ defination code: > ```cpp > example::Kind get_pet() > ``` #### get\\_list ```python def get_list(self, in: list[int]) > list[int] ``` get list example item description **type** func **param** **in**: direction [in], input list, items are int type.<br>In MaixPy, you can pass list or tuple to this API<br> **return** list, items are int type, content is [1, 2, 3] + in. Alloc item, del in MaixPy will auto free memory. **static** False > C++ defination code: > ```cpp > std::vector<int> *get_list(std::vector<int> in) > ``` #### get\\_dict ```python def get_dict(self, in: dict[str, int]) > dict[str, int] ``` Example dict API item description **type** func **param** **in**: direction [in], input dict, key is string type, value is int type.<br>In MaixPy, you can pass `dict` to this API<br> **return** dict, key is string type, value is int type, content is {\"a\": 1} + in<br>In MaixPy, return type is `dict` object **static** False > C++ defination code: > ```cpp > std::map<std::string, int> get_dict(std::map<std::string, int> &in) > ``` #### hello ```python def hello(name: str) > str ``` say hello to someone item description **type** func **param** **name**: name of someone, string type<br> **return** string type, content is Example::hello_str + name **static** True > C++ defination code: > ```cpp > static std::string hello(std::string name) > ``` #### hello\\_bytes ```python def hello_bytes(*args, **kwargs) ``` param is bytes example item description **type** func **param** **bytes**: bytes type param<br> **return** bytes type, return value is bytes changed value **static** True > C++ defination code: > ```cpp > static Bytes *hello_bytes(Bytes &bytes) > ``` #### callback ```python def callback(cb: typing.Callable[[int, int], int]) > int ``` Callback example item description **type** func **param** **cb**: callback function, param is two int type, return is int type<br> **return** int type, return value is cb's return value. **static** True > C++ defination code: > ```cpp > static int callback(std::function<int(int, int)> cb) > ``` #### callback2 ```python def callback2(cb: typing.Callable[[list[int], int], int]) > int ``` Callback example item description **type** func **param** **cb**: callback function, param is a int list type and int type, return is int type<br> **return** int type, return value is cb's return value. **static** True > C++ defination code: > ```cpp > static int callback2(std::function<int(std::vector<int>, int)> cb) > ``` #### hello\\_dict ```python def hello_dict(dict: dict[str, int]) > dict[str, int] ``` Dict param example item description **type** func **param** **dict**: dict type param, key is string type, value is int type<br> **static** True > C++ defination code: > ```cpp > static std::map<std::string, int> *hello_dict(std::map<std::string, int> *dict) > ``` #### name name member of Example item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string name > ``` #### age age member of Example, value range should be [0, 100] item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int age > ``` #### hello\\_str hello_str member of Example, default value is \\\"hello \\\" item description **type** var **static** True **readonly** False > C++ defination code: > ```cpp > static std::string hello_str > ``` #### var1 Example module readonly variable item description **type** var **static** False **readonly** True > C++ defination code: > ```cpp > const std::string var1 \"Example.var1\" > ``` #### var2 Example module readonly variable item description **type** var **static** False **readonly** True > C++ defination code: > ```cpp > std::string var2 \"Example.var2\" > ``` #### dict\\_test ```python def dict_test() > dict[str, Test] ``` dict_test, return dict type, and element is pointer type(alloc in C++).\\nHere when the returned Tensor object will auto delete by Python GC. item description **type** func **static** True > C++ defination code: > ```cpp > static std::map<std::string, example::Test *> *dict_test() > ```"},"/maixpy/api/maix/time.html":{"title":"maix.time","content":" title: maix.time maix.time module > You can use `maix.time` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ## Function ### time ```python def time() > float ``` Get current time in s item description **return** current time in s, double type **attention** If board have no RTC battery, when bootup and connect to network,<br>system will automatically sync time by NTP, will cause time() have big change,<br>e.g. before NTP: 10(s), after: 1718590639.5149617(s).<br>If you want to calculate time interval, please use ticks_s(). > C++ defination code: > ```cpp > double time() > ``` ### time\\_ms ```python def time_ms() > int ``` Get current time in ms item description **return** current time in ms, uint64_t type **attention** If board have no RTC battery, when bootup and connect to network,<br>system will automatically sync time by NTP, will cause time() have big change,<br>e.g. before NTP: 10000(ms), after: 1718590639000(ms)<br>If you want to calculate time interval, please use ticks_ms(). > C++ defination code: > ```cpp > uint64_t time_ms() > ``` ### time\\_s ```python def time_s() > int ``` Get current time in s item description **return** current time in s, uint64_t type **attention** If board have no RTC battery, when bootup and connect to network,<br>system will automatically sync time by NTP, will cause time() have big change,<br>e.g. before NTP: 10(s), after: 1718590639(s) > C++ defination code: > ```cpp > uint64_t time_s() > ``` ### time\\_us ```python def time_us() > int ``` Get current time in us item description **return** current time in us, uint64_t type **attention** If board have no RTC battery, when bootup and connect to network,<br>system will automatically sync time by NTP, will cause time() have big change,<br>e.g. before NTP: 10000000(us), after: 1718590639000000(s)<br>If you want to calculate time interval, please use ticks_us(). > C++ defination code: > ```cpp > uint64_t time_us() > ``` ### time\\_diff ```python def time_diff(last: float, now: float 1) > float ``` Calculate time difference in s. item description **param** **last**: last time<br>**now**: current time, can be 1 if use current time<br> **return** time difference **attention** If board have no RTC battery, when bootup and connect to network,<br>system will automatically sync time by NTP, will cause time() have big change, and lead to big value.<br>e.g. before NTP: 1(s), after: 1718590500(s)<br>If you want to calculate time interval, please use ticks_diff(). > C++ defination code: > ```cpp > double time_diff(double last, double now 1) > ``` ### ticks\\_s ```python def ticks_s() > float ``` Get current time in s since bootup item description **return** current time in s, double type > C++ defination code: > ```cpp > double ticks_s() > ``` ### ticks\\_ms ```python def ticks_ms() > int ``` Get current time in ms since bootup item description **return** current time in ms, uint64_t type > C++ defination code: > ```cpp > uint64_t ticks_ms() > ``` ### ticks\\_us ```python def ticks_us() > int ``` Get current time in us since bootup item description **return** current time in us, uint64_t type > C++ defination code: > ```cpp > uint64_t ticks_us() > ``` ### ticks\\_diff ```python def ticks_diff(last: float, now: float 1) > float ``` Calculate time difference in s. item description **param** **last**: last time<br>**now**: current time, can be 1 if use current time<br> **return** time difference > C++ defination code: > ```cpp > double ticks_diff(double last, double now 1) > ``` ### sleep Sleep seconds item description **param** **s**: seconds, double type<br> > C++ defination code: > ```cpp > void sleep(double s) > ``` ### sleep\\_ms Sleep milliseconds item description **param** **ms**: milliseconds, uint64_t type<br> > C++ defination code: > ```cpp > void sleep_ms(uint64_t ms) > ``` ### sleep\\_us Sleep microseconds item description **param** **us**: microseconds, uint64_t type<br> > C++ defination code: > ```cpp > void sleep_us(uint64_t us) > ``` ### fps ```python def fps() > float ``` Calculate FPS since last call this method.\\nAttention, this method is not multi thread safe, only call this method in one threads.\\nIf you want to use in multi threads, please use time.FPS class.\\nFPS is average value of recent n(buff_len) times, and you can call fps_set_buff_len(10) to change buffer length, default is 20.\\nMultiple invoke this function will calculate fps between two invoke, and you can also call fps_start() fisrt to manually assign fps calulate start point. item description **return** float type, current fps since last call this method > C++ defination code: > ```cpp > float fps() > ``` ### fps\\_start ```python def fps_start() > None ``` Manually set fps calculation start point, then you can call fps() function to calculate fps between fps_start() and fps(). > C++ defination code: > ```cpp > void fps_start() > ``` ### fps\\_set\\_buff\\_len ```python def fps_set_buff_len(len: int) > None ``` Set fps method buffer length, by default the buffer length is 10. item description **param** **len**: Buffer length to store recent fps value.<br> > C++ defination code: > ```cpp > void fps_set_buff_len(int len) > ``` ### now ```python def now() > DateTime ``` Get current UTC date and time item description **return** current date and time, DateTime type > C++ defination code: > ```cpp > time::DateTime *now() > ``` ### localtime ```python def localtime() > DateTime ``` Get local time item description **return** local time, DateTime type > C++ defination code: > ```cpp > time::DateTime *localtime() > ``` ### strptime ```python def strptime(str: str, format: str) > DateTime ``` DateTime from string item description **param** **str**: date time string<br>**format**: date time format<br> **return** DateTime > C++ defination code: > ```cpp > time::DateTime *strptime(const std::string &str, const std::string &format) > ``` ### gmtime ```python def gmtime(timestamp: float) > DateTime ``` timestamp to DateTime(time zone is UTC (value 0)) item description **param** **timestamp**: double timestamp<br> **return** DateTime > C++ defination code: > ```cpp > time::DateTime *gmtime(double timestamp) > ``` ### timezone ```python def timezone(timezone: str '') > str ``` Set or get timezone item description **param** **timezone**: string type, can be empty and default to empty, if empty, only return crrent timezone, a \"region/city\" string, e.g. Asia/Shanghai, Etc/UTC, you can get all by list_timezones function.<br> **return** string type, return current timezone setting. **attention** when set new timezone, time setting not take effect in this process for some API, so you need to restart program. > C++ defination code: > ```cpp > std::string timezone(const std::string &timezone \"\") > ``` ### timezone (overload 1) Set or get timezone item description **param** **region**: string type, which region to set, can be empty means only get current, default empty.<br>**city**: string type, which city to set, can be empty means only get current, default empty.<br> **return** list type, return current timezone setting, first is region, second is city. **attention** when set new timezone, time setting not take effect in this process for some API, so you need to restart program. > C++ defination code: > ```cpp > std::vector<std::string> timezone2(const std::string &region \"\", const std::string &city \"\") > ``` ### list\\_timezones ```python def list_timezones() > dict[str, list[str]] ``` List all timezone info item description **return** A dict with key are regions, and value are region's cities. > C++ defination code: > ```cpp > std::map<std::string, std::vector<std::string>> list_timezones() > ``` ### ntp\\_timetuple ```python def ntp_timetuple(host: str, port: int 1, retry: int 3, timeout_ms: int 0) > list[int] ``` Retrieves time from an NTP server\\nThis function fetches the current time from the specified NTP server and port,\\nreturning a tuple containing the time details. item description **param** **host**: The hostname or IP address of the NTP server.<br>**port**: The port number of the NTP server. Use 1 for the default port 123.<br>**retry**: The number of retry attempts. Must be at least 1.<br>**timeout_ms**: The timeout duration in milliseconds. Must be non negative.<br> **return** A list of 6 elements: [year, month, day, hour, minute, second] > C++ defination code: > ```cpp > std::vector<int> ntp_timetuple(std::string host, int port 1, uint8_t retry 3, int timeout_ms 0) > ``` ### ntp\\_timetuple\\_with\\_config ```python def ntp_timetuple_with_config(path: str) > list[int] ``` Retrieves time from an NTP server using a configuration file\\nThis function reads the configuration from a YAML file to fetch the current time\\nfrom a list of specified NTP servers, returning a tuple containing the time details. item description **param** **path**: The path to the YAML configuration file, which should include:<br> Config:<br> retry: Number of retry attempts (must be at least 1)<br> total_timeout_ms: Total timeout duration in milliseconds (must be non negative)<br> NtpServers:<br> host: Hostname or IP address of the NTP server<br> port: Port number of the NTP server (use 123 for default)<br>Example YAML configuration:<br>Config:<br> retry: 3<br> total_timeout_ms: 10000<br>NtpServers:<br> host: \"pool.ntp.org\"<br>port: 123<br> host: \"time.nist.gov\"<br>port: 123<br> host: \"time.windows.com\"<br>port: 123<br> **return** A list of 6 elements: [year, month, day, hour, minute, second] > C++ defination code: > ```cpp > std::vector<int> ntp_timetuple_with_config(std::string path) > ``` ### ntp\\_sync\\_sys\\_time ```python def ntp_sync_sys_time(host: str, port: int 1, retry: int 3, timeout_ms: int 0) > list[int] ``` Retrieves time from an NTP server and synchronizes the system time\\nThis function fetches the current time from the specified NTP server and port,\\nthen synchronizes the system time with the retrieved time. item description **param** **host**: The hostname or IP address of the NTP server.<br>**port**: The port number of the NTP server. Use 123 for the default port.<br>**retry**: The number of retry attempts. Must be at least 1.<br>**timeout_ms**: The timeout duration in milliseconds. Must be non negative.<br> **return** A list of 6 elements: [year, month, day, hour, minute, second] > C++ defination code: > ```cpp > std::vector<int> ntp_sync_sys_time(std::string host, int port 1, uint8_t retry 3, int timeout_ms 0) > ``` ### ntp\\_sync\\_sys\\_time\\_with\\_config ```python def ntp_sync_sys_time_with_config(path: str) > list[int] ``` Retrieves time from an NTP server using a configuration file and synchronizes the system time\\nThis function reads the configuration from a YAML file to fetch the current time\\nfrom a list of specified NTP servers, then synchronizes the system time with the retrieved time. item description **param** **path**: The path to the YAML configuration file, which should include:<br> Config:<br> retry: Number of retry attempts (must be at least 1)<br> total_timeout_ms: Total timeout duration in milliseconds (must be non negative)<br> NtpServers:<br> host: Hostname or IP address of the NTP server<br> port: Port number of the NTP server (use 123 for default)<br>Example YAML configuration:<br>Config:<br> retry: 3<br> total_timeout_ms: 10000<br>NtpServers:<br> host: \"pool.ntp.org\"<br>port: 123<br> host: \"time.nist.gov\"<br>port: 123<br> host: \"time.windows.com\"<br>port: 123<br> **return** A vector of integers containing the time details: [year, month, day, hour, minute, second] > C++ defination code: > ```cpp > std::vector<int> ntp_sync_sys_time_with_config(std::string path) > ``` ## Class ### FPS FPS class to use average filter to calculate FPS. > C++ defination code: > ```cpp > class FPS > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, buff_len: int 20) > None ``` FPS class constructor item description **type** func **param** **buff_len**: Average buffer length, default 20, that is, fps() function will return the average fps in recent buff_len times fps.<br> **static** False > C++ defination code: > ```cpp > FPS(int buff_len 20) > ``` #### start ```python def start(self) > None ``` Manually set fps calculation start point, then you can call fps() function to calculate fps between start() and fps(). item description **type** func **static** False > C++ defination code: > ```cpp > void start() > ``` #### fps ```python def fps(self) > float ``` The same as end function. item description **type** func **return** float type, current fps since last call this method **static** False > C++ defination code: > ```cpp > float fps() > ``` #### fps (overload 1) Calculate FPS since last call this method.\\nFPS is average value of recent n(buff_len) times, and you can call fps_set_buff_len(10) to change buffer length, default is 20.\\nMultiple invoke this function will calculate fps between two invoke, and you can also call fps_start() fisrt to manually assign fps calulate start point. item description **type** func **return** float type, current fps since last call this method **static** False > C++ defination code: > ```cpp > inline float end() > ``` #### set\\_buff\\_len ```python def set_buff_len(self, len: int) > None ``` Set fps method buffer length, by default the buffer length is 10. item description **type** func **param** **len**: Buffer length to store recent fps value.<br> **static** False > C++ defination code: > ```cpp > void set_buff_len(int len) > ``` ### DateTime Date and time class > C++ defination code: > ```cpp > class DateTime > ``` #### year Year item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int year > ``` #### month Month, 1~12 item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int month > ``` #### day Day item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int day > ``` #### hour Hour item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int hour > ``` #### minute Minute item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int minute > ``` #### second Second item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int second > ``` #### microsecond Microsecond item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int microsecond > ``` #### yearday Year day item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int yearday > ``` #### weekday Weekday, 0 is Monday, 6 is Sunday item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int weekday > ``` #### zone Time zone item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float zone > ``` #### zone\\_name Time zone name item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string zone_name > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, year: int 0, month: int 0, day: int 0, hour: int 0, minute: int 0, second: int 0, microsecond: int 0, yearday: int 0, weekday: int 0, zone: int 0) > None ``` Constructor item description **type** func **param** **year**: year<br>**month**: month<br>**day**: day<br>**hour**: hour<br>**minute**: minute<br>**second**: second<br>**microsecond**: microsecond<br>**yearday**: year day<br>**weekday**: weekday<br>**zone**: time zone<br> **static** False > C++ defination code: > ```cpp > DateTime(int year 0, int month 0, int day 0, int hour 0, int minute 0, int second 0, int microsecond 0, int yearday 0, int weekday 0, int zone 0) > ``` #### strftime ```python def strftime(self, format: str) > str ``` Convert to string item description **type** func **return** date time string **static** False > C++ defination code: > ```cpp > std::string strftime(const std::string &format) > ``` #### timestamp ```python def timestamp(self) > float ``` Convert to float timestamp item description **type** func **return** float timestamp **static** False > C++ defination code: > ```cpp > double timestamp() > ```"},"/maixpy/api/maix/sys.html":{"title":"maix.sys","content":" title: maix.sys maix.sys module > You can use `maix.sys` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ## Function ### os\\_version ```python def os_version() > str ``` Get system version item description **return** version string, e.g. \"maixcam 2024 08 13 maixpy v4.4.20\" > C++ defination code: > ```cpp > std::string os_version() > ``` ### maixpy\\_version ```python def maixpy_version() > str ``` Get MaixPy version, if get failed will return empty string. item description **return** version string, e.g. \"4.4.21\" > C++ defination code: > ```cpp > std::string maixpy_version() > ``` ### device\\_name ```python def device_name() > str ``` Get device name item description **return** device name, e.g. \"MaixCAM\" > C++ defination code: > ```cpp > std::string device_name() > ``` ### host\\_name ```python def host_name() > str ``` Get host name item description **return** host name, e.g. \"maixcam 2f9f\" > C++ defination code: > ```cpp > std::string host_name() > ``` ### host\\_domain ```python def host_domain() > str ``` Get host domain item description **return** host domain, e.g. \"maixcam 2f9f.local\" > C++ defination code: > ```cpp > std::string host_domain() > ``` ### ip\\_address ```python def ip_address() > dict[str, str] ``` Get ip address item description **return** ip address, dict type, e.g. {\"eth0\": \"192.168.0.195\", \"wlan0\": \"192.168.0.123\", \"usb0\": \"10.47.159.1\"} > C++ defination code: > ```cpp > std::map<std::string, std::string> ip_address() > ``` ### mac\\_address ```python def mac_address() > dict[str, str] ``` Get mac address item description **return** mac address, dict type, e.g. {\"eth0\": \"00:0c:29:2f:9f:00\", \"wlan0\": \"00:0c:29:2f:9f:01\", \"usb0\": \"00:0c:29:2f:9f:02\"} > C++ defination code: > ```cpp > std::map<std::string, std::string> mac_address() > ``` ### device\\_key ```python def device_key() > str ``` Get device key, can be unique id of device item description **return** device key, 32 bytes hex string, e.g. \"1234567890abcdef1234567890abcdef\" > C++ defination code: > ```cpp > std::string device_key() > ``` ### memory\\_info ```python def memory_info() > dict[str, int] ``` Get memory info item description **return** memory info, dict type, e.g. {\"total\": 1024, \"used\": 512, \"hw_total\": 256*1024*1024}<br>total: total memory size in Byte.<br>used: used memory size in Byte.<br>hw_total: total memory size in Byte of hardware, the total < hw_total，<br>OS kernel may reserve some memory for some hardware like camera, npu, display etc. > C++ defination code: > ```cpp > std::map<std::string, int> memory_info() > ``` ### bytes\\_to\\_human ```python def bytes_to_human(bytes: int, precision: int 2, base: int 1024, unit: str 'B', sep: str ' ') > str ``` Bytes to human readable string item description **param** **bytes:**: bytes size，e.g. 1234B 1234/1024 1.205 KB<br>**precision:**: decimal precision, default 2<br>**base:**: base number, default 1024<br>**unit:**: unit string, e.g. \"B\"<br>**sep:**: separator string, e.g. \" \"<br> **return** human readable string, e.g. \"1.21 KB\" > C++ defination code: > ```cpp > std::string bytes_to_human(unsigned long long bytes, int precision 2, int base 1024, const std::string &unit \"B\", const std::string &sep \" \") > ``` ### cpu\\_freq ```python def cpu_freq() > dict[str, int] ``` Get CPU frequency item description **return** CPU frequency, dict type, e.g. {\"cpu0\": 1000000000, \"cpu1\": 1000000000} > C++ defination code: > ```cpp > std::map<std::string, unsigned long> cpu_freq() > ``` ### cpu\\_temp ```python def cpu_temp() > dict[str, float] ``` Get CPU temperature item description **return** CPU temperature, unit dgree, dict type, e.g. {\"cpu\": 50.0, \"cpu0\": 50, \"cpu1\": 50} > C++ defination code: > ```cpp > std::map<std::string, float> cpu_temp() > ``` ### cpu\\_usage ```python def cpu_usage() > dict[str, float] ``` Get CPU usage item description **return** CPU usage, dict type, e.g. {\"cpu\": 50.0, \"cpu0\": 50, \"cpu1\": 50} > C++ defination code: > ```cpp > std::map<std::string, float> cpu_usage() > ``` ### npu\\_freq ```python def npu_freq() > dict[str, int] ``` Get NPU frequency item description **return** NPU frequency, dict type, e.g. {\"npu0\": 500000000} > C++ defination code: > ```cpp > std::map<std::string, unsigned long> npu_freq() > ``` ### disk\\_usage ```python def disk_usage(path: str '/') > dict[str, int] ``` Get disk usage item description **param** **path:**: disk path, default \"/\"<br> **return** disk usage, dict type, e.g. {\"total\": 1024, \"used\": 512} > C++ defination code: > ```cpp > std::map<std::string, unsigned long long> disk_usage(const std::string &path \"/\") > ``` ### disk\\_partitions ```python def disk_partitions(only_disk: bool True) > list[dict[str, str]] ``` Get disk partition and mount point info item description **param** **only_disk**: only return real disk, tempfs sysfs etc. not return, default true.<br> **return** disk partition and mount point info, list type, e.g. [{\"device\": \"/dev/mmcblk0p1\", \"mountpoint\": \"/mnt/sdcard\", \"fstype\": \"vfat\"}] > C++ defination code: > ```cpp > std::vector<std::map<std::string, std::string>> disk_partitions(bool only_disk true) > ``` ### register\\_default\\_signal\\_handle register default signal handle > C++ defination code: > ```cpp > void register_default_signal_handle() > ``` ### poweroff ```python def poweroff() > None ``` Power off device > C++ defination code: > ```cpp > void poweroff() > ``` ### reboot ```python def reboot() > None ``` Power off device and power on > C++ defination code: > ```cpp > void reboot() > ``` ## Class"},"/maixpy/api/maix/network/wifi.html":{"title":"maix.network.wifi","content":" title: maix.network.wifi maix.network.wifi module > You can use `maix.network.wifi` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ## Function ### list\\_devices ```python def list_devices() > list[str] ``` List WiFi interfaces item description **return** WiFi interface list, string type > C++ defination code: > ```cpp > std::vector<std::string> list_devices() > ``` ## Class ### AP\\_Info WiFi AP info > C++ defination code: > ```cpp > class AP_Info > ``` #### ssid WiFi AP info SSID item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<uint8_t> ssid > ``` #### bssid WiFi AP info BSSID item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string bssid > ``` #### security WiFi AP info security item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string security > ``` #### channel WiFi AP info channel item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int channel > ``` #### frequency WiFi AP info frequency item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int frequency > ``` #### rssi WiFi AP info rssi item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int rssi > ``` #### ssid\\_str ```python def ssid_str(self) > str ``` WiFi AP info ssid_str item description **type** func **static** False > C++ defination code: > ```cpp > std::string ssid_str() > ``` ### Wifi Wifi class > C++ defination code: > ```cpp > class Wifi > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, iface: str 'wlan0') > None ``` Wifi class item description **type** func **param** **iface**: wifi interface name, default is wlan0<br> **static** False > C++ defination code: > ```cpp > Wifi(std::string iface \"wlan0\") > ``` #### get\\_ip ```python def get_ip(self) > str ``` Get current WiFi ip item description **type** func **return** ip, string type, if network not connected, will return empty string. **static** False > C++ defination code: > ```cpp > std::string get_ip() > ``` #### get\\_mac ```python def get_mac(self) > str ``` Get current WiFi MAC address item description **type** func **return** ip, string type. **static** False > C++ defination code: > ```cpp > std::string get_mac() > ``` #### get\\_ssid ```python def get_ssid(self, from_cache: bool True) > str ``` Get current WiFi SSID item description **type** func **param** **from_cache**: if true, will not read config from file, direct use ssid in cache.<br>attention, first time call this method will auto matically read config from file, and if call connect method will set cache.<br> **return** SSID, string type. **static** False > C++ defination code: > ```cpp > std::string get_ssid(bool from_cache true) > ``` #### get\\_gateway ```python def get_gateway(self) > str ``` Get current WiFi ip item description **type** func **return** ip, string type, if network not connected, will return empty string. **static** False > C++ defination code: > ```cpp > std::string get_gateway() > ``` #### start\\_scan ```python def start_scan(self) > maix.err.Err ``` WiFi start scan AP info around in background. item description **type** func **return** If success, return err.Err.ERR_NONE, else means failed. **static** False > C++ defination code: > ```cpp > err::Err start_scan() > ``` #### get\\_scan\\_result ```python def get_scan_result(self) > list[AP_Info] ``` Get WiFi scan AP info. item description **type** func **return** wifi.AP_Info list. **static** False > C++ defination code: > ```cpp > std::vector<network::wifi::AP_Info> get_scan_result() > ``` #### stop\\_scan ```python def stop_scan(self) > None ``` Stop WiFi scan AP info. item description **type** func **static** False > C++ defination code: > ```cpp > void stop_scan() > ``` #### connect ```python def connect(self, ssid: str, password: str, wait: bool True, timeout: int 60) > maix.err.Err ``` Connect to WiFi AP. item description **type** func **param** **ssid**: SSID of AP<br>**password**: password of AP, if no password, leave it empty.<br>**wait**: wait for got IP or failed or timeout.<br>**timeout**: connect timeout internal, unit second.<br> **return** If success, return err.Err.ERR_NONE, else means failed. **static** False > C++ defination code: > ```cpp > err::Err connect(const std::string &ssid, const std::string &password, bool wait true, int timeout 60) > ``` #### disconnect ```python def disconnect(self) > maix.err.Err ``` Disconnect from WiFi AP. item description **type** func **return** If success, return err.Err.ERR_NONE, else means failed. **static** False > C++ defination code: > ```cpp > err::Err disconnect() > ``` #### is\\_connected ```python def is_connected(self) > bool ``` See if WiFi is connected to AP. item description **type** func **return** If connected return true, else false. **static** False > C++ defination code: > ```cpp > bool is_connected() > ``` #### start\\_ap ```python def start_ap(self, ssid: str, password: str, mode: str 'g', channel: int 0, ip: str '192.168.66.1', netmask: str '255.255.255.0', hidden: bool False) > maix.err.Err ``` Start WiFi AP. item description **type** func **param** **ssid**: SSID of AP.<br>**password**: password of AP, if no password, leave it empty.<br>**ip**: ip address of hostap, default empty string means auto generated one according to hardware.<br>**netmask**: netmask, default 255.255.255.0, now only support 255.255.255.0 .<br>**mode**: WiFi mode, default g(IEEE 802.11g (2.4 GHz)), a IEEE 802.11a (5 GHz), b IEEE 802.11b (2.4 GHz).<br>**channel**: WiFi channel number, 0 means auto select. MaixCAM not support auto, will default channel 1.<br>**hidden**: hidden SSID or not.<br> **return** If success, return err.Err.ERR_NONE, else means failed. **static** False > C++ defination code: > ```cpp > err::Err start_ap(const std::string &ssid, const std::string &password, > std::string mode \"g\", int channel 0, > const std::string &ip \"192.168.66.1\", const std::string &netmask \"255.255.255.0\", > bool hidden false) > ``` #### stop\\_ap ```python def stop_ap(self) > maix.err.Err ``` Stop WiFi AP. item description **type** func **return** If success, return err.Err.ERR_NONE, else means failed. **static** False > C++ defination code: > ```cpp > err::Err stop_ap() > ``` #### is\\_ap\\_mode ```python def is_ap_mode(self) > bool ``` Whether WiFi is AP mode item description **type** func **return** True if AP mode now, or False. **static** False > C++ defination code: > ```cpp > bool is_ap_mode() > ```"},"/maixpy/api/maix/rtmp.html":{"title":"maix.rtmp","content":" title: maix.rtmp maix.rtmp module > You can use `maix.rtmp` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ### TagType Video type item describe **values** **TAG_NONE**: <br>**TAG_VIDEO**: <br>**TAG_AUDIO**: <br>**TAG_SCRIPT**: <br> > C++ defination code: > ```cpp > enum TagType > { > TAG_NONE, > TAG_VIDEO, > TAG_AUDIO, > TAG_SCRIPT, > } > ``` ## Variable ## Function ## Class ### Rtmp Rtmp class > C++ defination code: > ```cpp > class Rtmp > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, host: str 'localhost', port: int 1935, app: str '', stream: str '', bitrate: int 1000000) > None ``` Construct a new Video object item description **type** func **note** Rtmp url : rtmp://host:prot/app/stream<br>example:<br>r Rtmp(\"localhost\", 1935, \"live\", \"stream\")<br>means rtmp url is rtmp://localhost:1935/live/stream **param** **host**: rtmp ip<br>**port**: rtmp port, default is 1935.<br>**app**: rtmp app name<br>**stream**: rtmp stream name<br>**bitrate**: rtmp bitrate, default is 1000 * 1000<br> **static** False > C++ defination code: > ```cpp > Rtmp(std::string host \"localhost\", int port 1935, std::string app std::string(), std::string stream std::string(), int bitrate 1000 * 1000) > ``` #### push\\_video ```python def push_video(self) > int ``` Get bitrate item description **type** func **return** bitrate **static** False > C++ defination code: > ```cpp > int bitrate() > ``` #### bind\\_camera ```python def bind_camera(self, cam: maix.camera.Camera) > maix.err.Err ``` Bind camera item description **type** func **note** If the cam object is bound, the cam object cannot be used elsewhere. **param** **cam**: camera object<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err bind_camera(camera::Camera *cam) > ``` #### get\\_camera ```python def get_camera(self) > maix.camera.Camera ``` If you bind a camera, return the camera object. item description **type** func **return** Camera object **static** False > C++ defination code: > ```cpp > camera::Camera *get_camera() > ``` #### start ```python def start(self, path: str '') > maix.err.Err ``` Start push stream item description **type** func **note** only support flv file now **param** **path**: File path, if you passed file path, cyclic push the file, else if you bound camera, push the camera image.<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err start(std::string path std::string()) > ``` #### stop ```python def stop(self) > maix.err.Err ``` Stop push stream item description **type** func **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err stop() > ``` #### get\\_path ```python def get_path(self) > str ``` Get the file path of the push stream item description **type** func **return** file path **static** False > C++ defination code: > ```cpp > std::string get_path() > ``` #### get\\_path (overload 1) Check whether push streaming has started item description **type** func **return** If rtmp thread is running, returns true **static** False > C++ defination code: > ```cpp > bool is_started() > ```"},"/maixpy/api/maix/video.html":{"title":"maix.video","content":" title: maix.video maix.video module > You can use `maix.video` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ### VideoType Video type item describe **values** **VIDEO_NONE**: format invalid<br>**VIDEO_ENC_H265_CBR**: Deprecated<br>**VIDEO_ENC_MP4_CBR**: Deprecated<br>**VIDEO_DEC_H265_CBR**: Deprecated<br>**VIDEO_DEC_MP4_CBR**: Deprecated<br>**VIDEO_H264_CBR**: Deprecated<br>**VIDEO_H265_CBR**: Deprecated<br>**VIDEO_H264_CBR_MP4**: Deprecated<br>**VIDEO_H265_CBR_MP4**: Deprecated<br>**VIDEO_H264**: <br>**VIDEO_H264_MP4**: <br>**VIDEO_H264_FLV**: <br>**VIDEO_H265**: <br>**VIDEO_H265_MP4**: <br> > C++ defination code: > ```cpp > enum VideoType > { > VIDEO_NONE 0, // format invalid > VIDEO_ENC_H265_CBR, // Deprecated > VIDEO_ENC_MP4_CBR, // Deprecated > VIDEO_DEC_H265_CBR, // Deprecated > VIDEO_DEC_MP4_CBR, // Deprecated > VIDEO_H264_CBR, // Deprecated > VIDEO_H265_CBR, // Deprecated > VIDEO_H264_CBR_MP4, // Deprecated > VIDEO_H265_CBR_MP4, // Deprecated > > VIDEO_H264, > VIDEO_H264_MP4, > VIDEO_H264_FLV, > VIDEO_H265, > VIDEO_H265_MP4, > } > ``` ### MediaType Video type item describe **values** **MEDIA_TYPE_UNKNOWN**: Represents an unknown media type, which is usually treated as AVMEDIA_TYPE_DATA.<br>**MEDIA_TYPE_VIDEO**: Represents a video stream, such as video content encoded in H.264, MPEG 4, etc.<br>**MEDIA_TYPE_AUDIO**: Represents an audio stream, such as audio content encoded in AAC, MP3, etc.<br>**MEDIA_TYPE_DATA**: Represents opaque data streams that are usually continuous. This type of stream is not necessarily audio or video and may be used for other data purposes.<br>**MEDIA_TYPE_SUBTITLE**: Represents a subtitle stream used for displaying text or subtitle information, such as SRT, ASS, etc.<br>**MEDIA_TYPE_ATTACHMENT**: Represents attachment streams that are usually sparse. Attachment streams can include images, fonts, or other files that need to be bundled with the media.<br>**MEDIA_TYPE_NB**: Represents the number of media types (count) and indicates the total number of media types defined in this enumeration. It is not a media type itself but is used for counting enumeration items.<br> > C++ defination code: > ```cpp > enum MediaType > { > MEDIA_TYPE_UNKNOWN 1, // Represents an unknown media type, which is usually treated as AVMEDIA_TYPE_DATA. > MEDIA_TYPE_VIDEO, // Represents a video stream, such as video content encoded in H.264, MPEG 4, etc. > MEDIA_TYPE_AUDIO, // Represents an audio stream, such as audio content encoded in AAC, MP3, etc. > MEDIA_TYPE_DATA, // Represents opaque data streams that are usually continuous. This type of stream is not necessarily audio or video and may be used for other data purposes. > MEDIA_TYPE_SUBTITLE, // Represents a subtitle stream used for displaying text or subtitle information, such as SRT, ASS, etc. > MEDIA_TYPE_ATTACHMENT, // Represents attachment streams that are usually sparse. Attachment streams can include images, fonts, or other files that need to be bundled with the media. > MEDIA_TYPE_NB // Represents the number of media types (count) and indicates the total number of media types defined in this enumeration. It is not a media type itself but is used for counting enumeration items. > } > ``` ## Variable ## Function ### timebase\\_to\\_us ```python def timebase_to_us(timebase: list[int], value: int) > float ``` Convert a value in timebase units to microseconds. value * 1000000 / (timebase[1] / timebase[0]) item description **param** **timebse**: Time base, used as the unit for calculating playback time. It must be an array containing two parameters,<br>in the format [num, den], where the first parameter is the numerator of the time base, and the second parameter is the denominator of the time base.<br>**value**: Input value<br> **return** Return the result in microseconds. > C++ defination code: > ```cpp > double timebase_to_us(std::vector<int> timebase, uint64_t value) > ``` ### timebase\\_to\\_ms ```python def timebase_to_ms(timebase: list[int], value: int) > float ``` Convert a value in timebase units to milliseconds. item description **param** **timebse**: Time base, used as the unit for calculating playback time. It must be an array containing two parameters,<br>in the format [num, den], where the first parameter is the numerator of the time base, and the second parameter is the denominator of the time base.<br>**value**: Input value<br> **return** Return the result in milliseconds. > C++ defination code: > ```cpp > double timebase_to_ms(std::vector<int> timebase, uint64_t value) > ``` ## Class ### Context Context class > C++ defination code: > ```cpp > class Context > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, media_type: MediaType, timebase: list[int]) > None ``` Construct a new Context object item description **type** func **param** **media_type**: enable capture, if true, you can use capture() function to get an image object<br>**timebase**: Time base, used as the unit for calculating playback time. It must be an array containing two parameters,<br>in the format [num, den], where the first parameter is the numerator of the time base, and the second parameter is the denominator of the time base.<br> **static** False > C++ defination code: > ```cpp > Context(video::MediaType media_type, std::vector<int> timebase) > ``` #### audio\\_sample\\_rate ```python def audio_sample_rate(self) > int ``` Get sample rate of audio (only valid in the context of audio) item description **type** func **return** sample rate **static** False > C++ defination code: > ```cpp > int audio_sample_rate() > ``` #### audio\\_sample\\_rate (overload 1) Get sample rate of audio (only valid in the context of audio) item description **type** func **return** sample rate **static** False > C++ defination code: > ```cpp > int audio_sample_rate() > ``` #### audio\\_channels ```python def audio_channels(self) > int ``` Get channels of audio (only valid in the context of audio) item description **type** func **return** channels **static** False > C++ defination code: > ```cpp > int audio_channels() > ``` #### audio\\_channels (overload 1) Get channels of audio (only valid in the context of audio) item description **type** func **return** channels **static** False > C++ defination code: > ```cpp > int audio_channels() > ``` #### audio\\_format ```python def audio_format(self) > maix.audio.Format ``` Get format of audio (only valid in the context of audio) item description **type** func **return** audio format. @see audio::Format **static** False > C++ defination code: > ```cpp > audio::Format audio_format() > ``` #### audio\\_format (overload 1) Get format of audio (only valid in the context of audio) item description **type** func **return** audio format. @see audio::Format **static** False > C++ defination code: > ```cpp > audio::Format audio_format() > ``` #### set\\_pcm ```python def set_pcm(self, data: maix.Bytes(bytes), duration: int 0, pts: int 0, copy: bool True) > maix.err.Err ``` Set pcm data (only valid in the context of audio) item description **type** func **param** **duration**: Duration of the current pcm. unit: timebase<br>**pts**: The start time of this pcm playback. If it is 0, it means this parameter is not supported. unit: timebase<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err set_pcm(maix::Bytes *data, int duration 0, uint64_t pts 0, bool copy true) > ``` #### get\\_pcm ```python def get_pcm(*args, **kwargs) ``` Get pcm data (only valid in the context of audio) item description **type** func **attention** Note that if you call this interface, you are responsible for releasing the memory of the data, and this interface cannot be called again. **return** Bytes **static** False > C++ defination code: > ```cpp > Bytes *get_pcm() > ``` #### image ```python def image(self) > maix.image.Image ``` Retrieve the image data to be played. item description **type** func **attention** Note that if you call this interface, you are responsible for releasing the memory of the image, and this interface cannot be called again. **static** False > C++ defination code: > ```cpp > image::Image *image() > ``` #### media\\_type ```python def media_type(self) > MediaType ``` Get the media type to determine whether it is video, audio, or another media type. item description **type** func **static** False > C++ defination code: > ```cpp > video::MediaType media_type() > ``` #### pts ```python def pts(self) > int ``` Get the start time of the current playback., in units of time base. item description **type** func **static** False > C++ defination code: > ```cpp > uint64_t pts() > ``` #### last\\_pts ```python def last_pts(self) > int ``` Get the start time of the previous playback, in units of time base. item description **type** func **static** False > C++ defination code: > ```cpp > uint64_t last_pts() > ``` #### timebase ```python def timebase(self) > list[int] ``` Get the time base. item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<int> timebase() > ``` #### duration ```python def duration(self) > int ``` Duration of the current frame. unit: timebase item description **type** func **static** False > C++ defination code: > ```cpp > int duration() > ``` #### duration\\_us ```python def duration_us(self) > int ``` Duration of the current frame. unit: us item description **type** func **static** False > C++ defination code: > ```cpp > uint64_t duration_us() > ``` ### Frame Frame class > C++ defination code: > ```cpp > class Frame > ``` #### to\\_bytes ```python def to_bytes(*args, **kwargs) ``` Get raw data of packet item description **type** func **param** **copy**: if true, will alloc memory and copy data to new buffer<br> **return** raw data **static** False > C++ defination code: > ```cpp > Bytes *to_bytes(bool copy false) > ``` #### size ```python def size(self) > int ``` Get raw data size of packet item description **type** func **return** size of raw data **static** False > C++ defination code: > ```cpp > size_t size() > ``` #### is\\_valid ```python def is_valid(self) > bool ``` Check packet is valid item description **type** func **return** true, packet is valid; false, packet is invalid **static** False > C++ defination code: > ```cpp > bool is_valid() > ``` #### set\\_pts ```python def set_pts(self, pts: int) > None ``` Set pts item description **type** func **param** **pts**: presentation time stamp. unit: time_base<br> **static** False > C++ defination code: > ```cpp > void set_pts(uint64_t pts) > ``` #### set\\_dts ```python def set_dts(self, dts: int) > None ``` Set dts item description **type** func **param** **dts**: decoding time stamp. unit: time_base<br> **static** False > C++ defination code: > ```cpp > void set_dts(uint64_t dts) > ``` #### set\\_duration ```python def set_duration(self, duration: int) > None ``` Set duration item description **type** func **param** **duration**: packet display time. unit: time_base<br> **static** False > C++ defination code: > ```cpp > void set_duration(uint64_t duration) > ``` #### get\\_pts ```python def get_pts(self) > int ``` Set pts item description **type** func **param** **pts**: presentation time stamp. unit: time_base<br> **return** pts value **static** False > C++ defination code: > ```cpp > uint64_t get_pts() > ``` #### get\\_dts ```python def get_dts(self) > int ``` Set dts item description **type** func **param** **dts**: decoding time stamp. unit: time_base<br> **return** dts value **static** False > C++ defination code: > ```cpp > uint64_t get_dts() > ``` #### get\\_duration ```python def get_duration(self) > int ``` Get duration item description **type** func **return** duration value **static** False > C++ defination code: > ```cpp > uint64_t get_duration() > ``` #### type ```python def type(self) > VideoType ``` Get frame type item description **type** func **return** video type. @see video::VideoType **static** False > C++ defination code: > ```cpp > video::VideoType type() > ``` ### Packet Packet class > C++ defination code: > ```cpp > class Packet > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, data: int, len: int, pts: int 1, dts: int 1, duration: int 0) > None ``` Packet number (pair of numerator and denominator). item description **type** func **param** **data**: src data pointer, use pointers directly without copying.<br>Note: this object will try to free this memory<br>**len**: data len<br>**pts**: presentation time stamp. unit: time_base<br>**dts**: decoding time stamp. unit: time_base<br>**duration**: packet display time. unit: time_base<br> **static** False > C++ defination code: > ```cpp > Packet(uint8_t *data, int len, uint64_t pts 1, uint64_t dts 1, int64_t duration 0) > ``` #### get ```python def get(self) > list[int] ``` Get raw data of packet item description **type** func **return** raw data **static** False > C++ defination code: > ```cpp > std::vector<uint8_t> get() > ``` #### data ```python def data(self) > int ``` Get raw data of packet item description **type** func **return** raw data **static** False > C++ defination code: > ```cpp > uint8_t *data() > ``` #### data\\_size ```python def data_size(self) > int ``` Get raw data size of packet item description **type** func **return** size of raw data **static** False > C++ defination code: > ```cpp > size_t data_size() > ``` #### is\\_valid ```python def is_valid(self) > bool ``` Check packet is valid item description **type** func **return** true, packet is valid; false, packet is invalid **static** False > C++ defination code: > ```cpp > bool is_valid() > ``` #### set\\_pts ```python def set_pts(self, pts: int) > None ``` Set pts item description **type** func **param** **pts**: presentation time stamp. unit: time_base<br> **return** true, packet is valid; false, packet is invalid **static** False > C++ defination code: > ```cpp > void set_pts(uint64_t pts) > ``` #### set\\_dts ```python def set_dts(self, dts: int) > None ``` Set dts item description **type** func **param** **dts**: decoding time stamp. unit: time_base<br> **return** true, packet is valid; false, packet is invalid **static** False > C++ defination code: > ```cpp > void set_dts(uint64_t dts) > ``` #### set\\_duration ```python def set_duration(self, duration: int) > None ``` Set duration item description **type** func **param** **duration**: packet display time. unit: time_base<br> **return** true, packet is valid; false, packet is invalid **static** False > C++ defination code: > ```cpp > void set_duration(uint64_t duration) > ``` ### Encoder Encode class > C++ defination code: > ```cpp > class Encoder > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, path: str '', width: int 2560, height: int 1440, format: maix.image.Format ..., type: VideoType ..., framerate: int 30, gop: int 50, bitrate: int 3000000, time_base: int 1000, capture: bool False, block: bool True) > None ``` Construct a new Video object item description **type** func **param** **width**: picture width. this value may be set automatically. default is 2560.<br>**height**: picture height. this value may be set automatically. default is 1440.<br>**format**: picture format. default is image::Format::FMT_YVU420SP. @see image::Format<br>**type**: video encode/decode type. default is ENC_H265_CBR. @see EncodeType<br>**framerate**: frame rate. framerate default is 30, means 30 frames per second<br>for video. 1/time_base is not the average frame rate if the frame rate is not constant.<br>**gop**: for h264/h265 encoding, the interval between two I frames, default is 50.<br>**bitrate**: for h264/h265 encoding, used to limit the bandwidth used by compressed data, default is 3000kbps<br>**time_base**: frame time base. time_base default is 1000, means 1/1000 ms (not used)<br>**capture**: enable capture, if true, you can use capture() function to get an image object<br>**block**: This parameter determines whether encoding should block until it is complete.<br>If set to true, it will wait until encoding is finished before returning.<br>If set to false, it will return the current encoding result on the next call.<br> **static** False > C++ defination code: > ```cpp > Encoder(std::string path \"\", int width 2560, int height 1440, image::Format format image::Format::FMT_YVU420SP, video::VideoType type video::VideoType::VIDEO_H264, int framerate 30, int gop 50, int bitrate 3000 * 1000, int time_base 1000, bool capture false, bool block true) > ``` #### bind\\_camera ```python def bind_camera(self, camera: maix.camera.Camera) > maix.err.Err ``` Bind camera item description **type** func **param** **camera**: camera object<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err bind_camera(camera::Camera *camera) > ``` #### encode ```python def encode(self, img: maix.image.Image ..., pcm: maix.Bytes(bytes) b'') > Frame ``` Encode image. item description **type** func **param** **img**: the image will be encode.<br>if the img is NULL, this function will try to get image from camera, you must use bind_camera() function to bind the camera.<br>**pcm**: the pcm data will be encode.<br> **return** encode result **static** False > C++ defination code: > ```cpp > video::Frame *encode(image::Image *img maix::video::Encoder::NoneImage, Bytes *pcm maix::video::Encoder::NoneBytes) > ``` #### capture ```python def capture(self) > maix.image.Image ``` Capture image item description **type** func **attention** Each time encode is called, the last captured image will be released. **return** error code **static** False > C++ defination code: > ```cpp > image::Image *capture() > ``` #### width ```python def width(self) > int ``` Get video width item description **type** func **return** video width **static** False > C++ defination code: > ```cpp > int width() > ``` #### height ```python def height(self) > int ``` Get video height item description **type** func **return** video height **static** False > C++ defination code: > ```cpp > int height() > ``` #### type ```python def type(self) > VideoType ``` Get video encode type item description **type** func **return** VideoType **static** False > C++ defination code: > ```cpp > video::VideoType type() > ``` #### framerate ```python def framerate(self) > int ``` Get video encode framerate item description **type** func **return** frame rate **static** False > C++ defination code: > ```cpp > int framerate() > ``` #### gop ```python def gop(self) > int ``` Get video encode gop item description **type** func **return** gop value **static** False > C++ defination code: > ```cpp > int gop() > ``` #### bitrate ```python def bitrate(self) > int ``` Get video encode bitrate item description **type** func **return** bitrate value **static** False > C++ defination code: > ```cpp > int bitrate() > ``` #### time\\_base ```python def time_base(self) > int ``` Get video encode time base item description **type** func **return** time base value **static** False > C++ defination code: > ```cpp > int time_base() > ``` ### Decoder Decoder class > C++ defination code: > ```cpp > class Decoder > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, path: str, format: maix.image.Format ...) > None ``` Construct a new decoder object item description **type** func **param** **path**: Path to the file to be decoded. Supports files with .264 and .mp4 extensions. Note that only mp4 files containing h.264 streams are supported.<br>**format**: Decoded output format, currently only support YUV420SP<br> **static** False > C++ defination code: > ```cpp > Decoder(std::string path, image::Format format image::Format::FMT_YVU420SP) > ``` #### decode\\_video ```python def decode_video(self, block: bool True) > Context ``` Decode the video stream, returning the image of the next frame each time. item description **type** func **param** **block**: Whether it blocks or not. If true, it will wait for the decoding to complete and return the current frame.<br>If false, it will return the result of the previous frame's decoding. If the previous frame's decoding result is empty,<br>it will return an unknown Context, and you can use the media_type method of the Context to determine if a valid result exists.<br>default is true.<br> **return** Decoded context information. **static** False > C++ defination code: > ```cpp > video::Context * decode_video(bool block true) > ``` #### decode\\_audio ```python def decode_audio(self) > Context ``` Decode the video stream, returning the image of the next frame each time. item description **type** func **return** Decoded context information. **static** False > C++ defination code: > ```cpp > video::Context * decode_audio() > ``` #### decode ```python def decode(self, block: bool True) > Context ``` Decode the video and audio stream item description **type** func **param** **block**: Whether it blocks or not. If true, it will wait for the decoding to complete and return the current frame.<br>If false, it will return the result of the previous frame's decoding. If the previous frame's decoding result is empty,<br>it will return an unknown Context, and you can use the media_type method of the Context to determine if a valid result exists.<br>default is true.<br> **return** Decoded context information. **static** False > C++ defination code: > ```cpp > video::Context * decode(bool block true) > ``` #### width ```python def width(self) > int ``` Get the video width item description **type** func **return** video width **static** False > C++ defination code: > ```cpp > int width() > ``` #### height ```python def height(self) > int ``` Get the video height item description **type** func **return** video height **static** False > C++ defination code: > ```cpp > int height() > ``` #### bitrate ```python def bitrate(self) > int ``` Get the video bitrate item description **type** func **return** bitrate value **static** False > C++ defination code: > ```cpp > int bitrate() > ``` #### fps ```python def fps(self) > int ``` Get the video fps item description **type** func **return** fps value **static** False > C++ defination code: > ```cpp > int fps() > ``` #### seek ```python def seek(self, time: float 1) > float ``` Seek to the required playback position item description **type** func **param** **time**: timestamp value, unit: s<br> **return** return the current position, unit: s **static** False > C++ defination code: > ```cpp > double seek(double time 1) > ``` #### duration ```python def duration(self) > float ``` Get the maximum duration of the video. If it returns 0, it means it cannot be predicted. item description **type** func **return** duration value, unit: s **static** False > C++ defination code: > ```cpp > double duration() > ``` #### timebase ```python def timebase(self) > list[int] ``` Get the time base. item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<int> timebase() > ``` #### has\\_audio ```python def has_audio(self) > bool ``` If find audio data, return true item description **type** func **static** False > C++ defination code: > ```cpp > bool has_audio() > ``` #### has\\_video ```python def has_video(self) > bool ``` If find video data, return true item description **type** func **static** False > C++ defination code: > ```cpp > bool has_video() > ``` ### Video Video class > C++ defination code: > ```cpp > class Video > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, path: str '', width: int 2560, height: int 1440, format: maix.image.Format ..., time_base: int 30, framerate: int 30, capture: bool False, open: bool True) > None ``` Construct a new Video object item description **type** func **param** **path**: video path. the path determines the location where you load or save the file, if path is none, the video module will not save or load file.<br>xxx.h265 means video format is H265, xxx.mp4 means video format is MP4<br>**width**: picture width. this value may be set automatically. default is 2560.<br>**height**: picture height. this value may be set automatically. default is 1440.<br>**format**: picture pixel format. this value may be set automatically. default is FMT_YVU420SP.<br>**time_base**: frame time base. time_base default is 30, means 1/30 ms<br>**framerate**: frame rate. framerate default is 30, means 30 frames per second<br>for video. 1/time_base is not the average frame rate if the frame rate is not constant.<br>**capture**: enable capture, if true, you can use capture() function to get an image object<br>**open**: If true, video will automatically call open() after creation. default is true.<br> **static** False > C++ defination code: > ```cpp > Video(std::string path std::string(), int width 2560, int height 1440, image::Format format image::Format::FMT_YVU420SP, int time_base 30, int framerate 30, bool capture false, bool open true) > ``` #### open ```python def open(self, path: str '', fps: float 30.0) > maix.err.Err ``` Open video and run item description **type** func **param** **path**: video path. the path determines the location where you load or save the file, if path is none, the video module will not save or load file.<br>xxx.h265 means video format is H265, xxx.mp4 means video format is MP4<br>**fps**: video fps<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err open(std::string path std::string(), double fps 30.0) > ``` #### close ```python def close(self) > None ``` Close video item description **type** func **static** False > C++ defination code: > ```cpp > void close() > ``` #### bind\\_camera ```python def bind_camera(self, camera: maix.camera.Camera) > maix.err.Err ``` Bind camera item description **type** func **param** **camera**: camera object<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err bind_camera(camera::Camera *camera) > ``` #### encode ```python def encode(self, img: maix.image.Image ...) > Packet ``` Encode image. item description **type** func **param** **img**: the image will be encode.<br>if the img is NULL, this function will try to get image from camera, you must use bind_camera() function to bind the camera.<br> **return** encode result **static** False > C++ defination code: > ```cpp > video::Packet *encode(image::Image *img maix::video::Video::NoneImage) > ``` #### decode ```python def decode(self, frame: Frame None) > maix.image.Image ``` Decode frame item description **type** func **param** **frame**: the frame will be decode<br> **return** decode result **static** False > C++ defination code: > ```cpp > image::Image *decode(video::Frame *frame nullptr) > ``` #### finish ```python def finish(self) > maix.err.Err ``` Encode or decode finish item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err finish() > ``` #### capture ```python def capture(self) > maix.image.Image ``` Capture image item description **type** func **attention** Each time encode is called, the last captured image will be released. **return** error code **static** False > C++ defination code: > ```cpp > image::Image *capture() > ``` #### is\\_recording ```python def is_recording(self) > bool ``` Check if video is recording item description **type** func **return** true if video is recording, false if not **static** False > C++ defination code: > ```cpp > bool is_recording() > ``` #### is\\_opened ```python def is_opened(self) > bool ``` Check if video is opened item description **type** func **return** true if video is opened, false if not **static** False > C++ defination code: > ```cpp > bool is_opened() > ``` #### is\\_closed ```python def is_closed(self) > bool ``` check video device is closed or not item description **type** func **return** closed or not, bool type **static** False > C++ defination code: > ```cpp > bool is_closed() > ``` #### width ```python def width(self) > int ``` Get video width item description **type** func **return** video width **static** False > C++ defination code: > ```cpp > int width() > ``` #### height ```python def height(self) > int ``` Get video height item description **type** func **return** video height **static** False > C++ defination code: > ```cpp > int height() > ``` ### VideoRecorder Video Recorder class. This module is not fully supported and may be deprecated in the future. > C++ defination code: > ```cpp > class VideoRecorder > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, open: bool True) > None ``` Construct a new VideoRecorder object. This is an object that integrates recording, video capturing, and display functions, which can be used to achieve high resolution video input when needed. item description **type** func **param** **open**: If true, video will automatically call open() after creation. default is true.<br> **static** False > C++ defination code: > ```cpp > VideoRecorder(bool open true) > ``` #### lock ```python def lock(self, timeout: int 1) > maix.err.Err ``` lock video item description **type** func **param** **timeout**: timeout in ms. unit:ms<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err lock(int64_t timeout 1) > ``` #### unlock ```python def unlock(self) > maix.err.Err ``` unlock video item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err unlock() > ``` #### open ```python def open(self) > maix.err.Err ``` Start a thread to handle the input function. item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err open() > ``` #### close ```python def close(self) > maix.err.Err ``` Stop the thread, and reset the object. item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err close() > ``` #### is\\_opened ```python def is_opened(self) > bool ``` Check whether the object is opened. item description **type** func **static** False > C++ defination code: > ```cpp > bool is_opened() > ``` #### bind\\_display ```python def bind_display(self, display: maix.display.Display, fit: maix.image.Fit ...) > maix.err.Err ``` Bind a Display object. if this object is not bound, it will not be displayed. item description **type** func **param** **display**: display object<br>**fit**: fit mode. It is recommended to fill in FIT_COVER or FIT_FILL. For maixcam, using FIT_CONTAIN may affect the<br>functionality of the second layer created by add_channel() in the Display. default is FIT_COVER.<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err bind_display(display::Display *display, image::Fit fit image::FIT_COVER) > ``` #### bind\\_camera ```python def bind_camera(self, camera: maix.camera.Camera) > maix.err.Err ``` Bind a Camera object. if this object is not bound, images cannot be captured. item description **type** func **param** **camera**: camera object<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err bind_camera(camera::Camera *camera) > ``` #### bind\\_audio ```python def bind_audio(self, audio: maix.audio.Recorder) > maix.err.Err ``` Bind a AudioRecorder object. if this object is not bound, audio cannot be captured. item description **type** func **param** **audio**: audio recorder object<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err bind_audio(audio::Recorder *audio) > ``` #### bind\\_imu ```python def bind_imu(self, imu: capsule) > maix.err.Err ``` Bind a IMU object. if this object is not bound, imu data cannot be captured. item description **type** func **param** **imu**: imu object<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err bind_imu(void *imu) > ``` #### reset ```python def reset(self) > maix.err.Err ``` Reset the video recorder. item description **type** func **note** It will not reset the bound object; if you have already bound the display using bind_display(), there is no need to rebind the display after calling reset(). **return** error code **static** False > C++ defination code: > ```cpp > err::Err reset() > ``` #### config\\_path ```python def config_path(self, path: str) > maix.err.Err ``` The recorded video will be saved to this path, and this API cannot be called during runtime. item description **type** func **param** **path**: The path of the video file to be saved<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err config_path(std::string path) > ``` #### get\\_path ```python def get_path(self) > str ``` Get the path of the video file to be saved item description **type** func **return** path **static** False > C++ defination code: > ```cpp > std::string get_path() > ``` #### config\\_snapshot ```python def config_snapshot(self, enable: bool, resolution: list[int] [], format: maix.image.Format ...) > maix.err.Err ``` Set the snapshot parameters item description **type** func **note** Enabling snapshot functionality may result in some performance loss. **param** **enable**: enable or disable snapshot<br>**resolution**: image resolution of snapshot<br>**format**: image format of snapshot<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err config_snapshot(bool enable, std::vector<int> resolution std::vector<int>(), image::Format format image::Format::FMT_YVU420SP) > ``` #### config\\_resolution ```python def config_resolution(self, resolution: list[int]) > maix.err.Err ``` Set the resolution of the video, and this API cannot be called during runtime. item description **type** func **note** You must bind the camera first, and this interface will modify the camera's resolution. The width must be divisible by 32. **param** **resolution**: The resolution of the video<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err config_resolution(std::vector<int> resolution) > ``` #### get\\_resolution ```python def get_resolution(self) > list[int] ``` Get the resolution of the video item description **type** func **return** the resolution of the video **static** False > C++ defination code: > ```cpp > std::vector<int> get_resolution() > ``` #### config\\_fps ```python def config_fps(self, fps: int) > maix.err.Err ``` Set the fps of the video, and this API cannot be called during runtime. item description **type** func **note** This interface only affect the fps of the encoded file. **return** error code **static** False > C++ defination code: > ```cpp > err::Err config_fps(int fps) > ``` #### get\\_fps ```python def get_fps(self) > int ``` Get the fps of the video. item description **type** func **return** fps value **static** False > C++ defination code: > ```cpp > int get_fps() > ``` #### config\\_bitrate ```python def config_bitrate(self, bitrate: int) > maix.err.Err ``` Set the bitrate of the video, and this API cannot be called during runtime. item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err config_bitrate(int bitrate) > ``` #### get\\_bitrate ```python def get_bitrate(self) > int ``` Get the bitrate of the video. item description **type** func **return** bitrate value **static** False > C++ defination code: > ```cpp > int get_bitrate() > ``` #### mute ```python def mute(self, data: int 1) > int ``` Set/Get the mute of the video item description **type** func **param** **data**: If the parameter is true, mute; if false, unmute; if no parameter is provided, return the mute status.<br> **return** error code **static** False > C++ defination code: > ```cpp > int mute(int data 1) > ``` #### volume ```python def volume(self, data: int 1) > int ``` Set/Get the volume of the video item description **type** func **param** **data**: The volume of the video, the range is 0 100. if no parameter is provided, return the volume.<br> **return** error code **static** False > C++ defination code: > ```cpp > int volume(int data 1) > ``` #### seek ```python def seek(self) > int ``` Get the current position of the video item description **type** func **return** current position, unit: ms **static** False > C++ defination code: > ```cpp > int64_t seek() > ``` #### record\\_start ```python def record_start(self) > maix.err.Err ``` Start recording item description **type** func **note** You must bind the camera at a minimum during input. Additionally,<br>if you bind a display, the input image will be shown,<br>if you bind a audio, audio will be recorded,<br>if you bind a IMU, IMU data will be logged. **return** error code **static** False > C++ defination code: > ```cpp > err::Err record_start() > ``` #### snapshot ```python def snapshot(self) > maix.image.Image ``` Take a snapshot item description **type** func **return** image::Image **static** False > C++ defination code: > ```cpp > image::Image *snapshot() > ``` #### record\\_finish ```python def record_finish(self) > maix.err.Err ``` Stop recording and save the video item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err record_finish() > ``` #### draw\\_rect ```python def draw_rect(self, id: int, x: int, y: int, w: int, h: int, color: maix.image.Color ..., thickness: int 1, hidden: bool False) > maix.err.Err ``` Draw a rect on the video item description **type** func **param** **id**: id of the rect, range is [0, 15]<br>**x**: x coordinate<br>**y**: y coordinate<br>**w**: width<br>**h**: height<br>**color**: color<br>**tickness**: The line width of the rectangular box; if set to 1, it indicates that the rectangular box will be filled.<br>**hidden**: Hide or show the rectangular box<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err draw_rect(int id, int x, int y, int w, int h, image::Color color image::COLOR_WHITE, int thickness 1, bool hidden false) > ```"},"/maixpy/api/maix/nn.html":{"title":"maix.nn","content":" title: maix.nn maix.nn module > You can use `maix.nn` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module module brief [F](./nn/F.html) maix.nn.F module ## Enum ### SpeechDevice speech device item describe **values** **DEVICE_NONE**: <br>**DEVICE_PCM**: <br>**DEVICE_MIC**: <br>**DEVICE_WAV**: <br> > C++ defination code: > ```cpp > enum SpeechDevice { > DEVICE_NONE 1, > DEVICE_PCM, > DEVICE_MIC, > DEVICE_WAV, > } > ``` ### SpeechDecoder speech decoder type item describe **values** **DECODER_RAW**: <br>**DECODER_DIG**: <br>**DECODER_LVCSR**: <br>**DECODER_KWS**: <br>**DECODER_ALL**: <br> > C++ defination code: > ```cpp > enum SpeechDecoder { > DECODER_RAW 1, > DECODER_DIG 2, > DECODER_LVCSR 4, > DECODER_KWS 8, > DECODER_ALL 65535, > } > ``` ## Variable ## Function ## Class ### NanoTrack NanoTrack class > C++ defination code: > ```cpp > class NanoTrack > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, model: str '') > None ``` Constructor of NanoTrack class item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > NanoTrack(const string &model \"\") > ``` #### load ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### init ```python def init(self, img: maix.image.Image, x: int, y: int, w: int, h: int) > None ``` Init tracker, give tacker first target image and target position. item description **type** func **param** **img**: Image want to detect, target should be in this image.<br>**x**: the target position left top coordinate x.<br>**y**: the target position left top coordinate y.<br>**w**: the target width.<br>**h**: the target height.<br> **throw** If image format not match model input format, will throw err::Exception. **static** False > C++ defination code: > ```cpp > void init(image::Image &img, int x, int y, int w, int h) > ``` #### track ```python def track(self, img: maix.image.Image, threshold: float 0.9) > ... ``` Track object acoording to last object position and the init function learned target feature. item description **type** func **param** **img**: image to detect object and track, can be any resolution, before detect it will crop a area according to last time target's position.<br>**threshold**: If score < threshold, will see this new detection is invalid, but remain return this new detecion, default 0.9.<br> **return** object, position and score, and detect area in points's first 4 element(x, y, w, h, center_x, center_y, input_size, target_size) **static** False > C++ defination code: > ```cpp > nn::Object track(image::Image &img, float threshold 0.9) > ``` #### input\\_size ```python def input_size(self) > maix.image.Size ``` Get model input size item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width ```python def input_width(self) > int ``` Get model input width item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height ```python def input_height(self) > int ``` Get model input height item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format ```python def input_format(self) > maix.image.Format ``` Get input image format item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### mean Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` ### OCR\\_Box Object for OCR detect box > C++ defination code: > ```cpp > class OCR_Box > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, x1: int 0, y1: int 0, x2: int 0, y2: int 0, x3: int 0, y3: int 0, x4: int 0, y4: int 0) > None ``` OCR_Box constructor item description **type** func **static** False > C++ defination code: > ```cpp > OCR_Box(int x1 0, int y1 0, int x2 0, int y2 0, int x3 0, int y3 0, int x4 0, int y4 0) > ``` #### x1 left top point of box item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int x1 > ``` #### y1 left top point of box item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int y1 > ``` #### x2 right top point of box item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int x2 > ``` #### y2 right top point of box item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int y2 > ``` #### x3 right bottom point of box item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int x3 > ``` #### y3 right bottom point of box item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int y3 > ``` #### x4 left bottom point of box item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int x4 > ``` #### y4 left bottom point of box item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int y4 > ``` #### to\\_list ```python def to_list(self) > list[int] ``` convert box point to a list type. item description **type** func **return** list type, element is int type, value [x1, y1, x2, y2, x3, y3, x4, y4]. **static** False > C++ defination code: > ```cpp > std::vector<int> to_list() > ``` ### OCR\\_Object Object for OCR detect result > C++ defination code: > ```cpp > class OCR_Object > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, box: OCR_Box, idx_list: list[int], char_list: list[str], score: float 0, char_pos: list[int] []) > None ``` Constructor of Object for OCR detect result item description **type** func **param** **score**: score<br> **static** False > C++ defination code: > ```cpp > OCR_Object(const nn::OCR_Box &box, const std::vector<int> &idx_list, const std::vector<std::string> &char_list, float score 0, const std::vector<int> &char_pos std::vector<int>()) > ``` #### box OCR_Object box, 4 points box, first point at the left top, clock wise. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > nn::OCR_Box box > ``` #### score Object score item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float score > ``` #### idx\\_list chars' idx list, element is int type. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<int> idx_list > ``` #### char\\_pos Chars' position relative to left item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<int> char_pos > ``` #### char\\_str ```python def char_str(self) > str ``` Get OCR_Object's charactors, return a string type. item description **type** func **return** All charactors in string type. **static** False > C++ defination code: > ```cpp > const std::string &char_str() > ``` #### char\\_list ```python def char_list(self) > list[str] ``` Get OCR_Object's charactors, return a list type. item description **type** func **return** All charactors in list type. **static** False > C++ defination code: > ```cpp > const std::vector<std::string> &char_list() > ``` #### update\\_chars ```python def update_chars(self, char_list: list[str]) > None ``` Set OCR_Object's charactors item description **type** func **param** **char_list**: All charactors in list type.<br> **static** False > C++ defination code: > ```cpp > void update_chars(const std::vector<std::string> &char_list) > ``` #### \\_\\_str\\_\\_ ```python def __str__(self) > str ``` OCR_Object info to string item description **type** func **return** OCR_Object info string **static** False > C++ defination code: > ```cpp > std::string to_str() > ``` ### OCR\\_Objects OCR_Objects Class for detect result > C++ defination code: > ```cpp > class OCR_Objects > ``` #### \\_\\_init\\_\\_ ```python def __init__(self) > None ``` Constructor of OCR_Objects class item description **type** func **static** False > C++ defination code: > ```cpp > OCR_Objects() > ``` #### add ```python def add(self, box: OCR_Box, idx_list: list[int], char_list: list[str], score: float 0, char_pos: list[int] []) > OCR_Object ``` Add object to objects item description **type** func **throw** Throw exception if no memory **static** False > C++ defination code: > ```cpp > nn::OCR_Object &add(const nn::OCR_Box &box, const std::vector<int> &idx_list, const std::vector<std::string> &char_list, float score 0, const std::vector<int> &char_pos std::vector<int>()) > ``` #### remove ```python def remove(self, idx: int) > maix.err.Err ``` Remove object form objects item description **type** func **static** False > C++ defination code: > ```cpp > err::Err remove(int idx) > ``` #### at ```python def at(self, idx: int) > OCR_Object ``` Get object item item description **type** func **static** False > C++ defination code: > ```cpp > nn::OCR_Object &at(int idx) > ``` #### \\_\\_item\\_\\_ ```python def __item__(self, idx: int) > OCR_Object ``` Get object item item description **type** func **static** False > C++ defination code: > ```cpp > nn::OCR_Object &operator[](int idx) > ``` #### \\_\\_len\\_\\_ ```python def __len__(self) > int ``` Get size item description **type** func **static** False > C++ defination code: > ```cpp > size_t size() > ``` #### \\_\\_iter\\_\\_ ```python def __iter__(self) > typing.Iterator ``` Begin item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<OCR_Object*>::iterator begin() > ``` ### Speech Speech > C++ defination code: > ```cpp > class Speech > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, model: str '') > None ``` Construct a new Speech object item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > Speech(const string &model \"\") > ``` #### \\_\\_init\\_\\_ (overload 1) Construct a new Speech object item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > Speech(const string &model \"\") > ``` #### load ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### load (overload 1) Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### init ```python def init(self, dev_type: SpeechDevice, device_name: str) > maix.err.Err ``` Init the ASR library and select the type and name of the audio device. item description **type** func **param** **dev_type**: device type want to detect, can choose between WAV, PCM, or MIC.<br>**device_name**: device name want to detect, can choose a WAV file, a PCM file, or a MIC device name.<br> **throw** **1**. If am model is not loaded, will throw err::ERR_NOT_IMPL.<br>**2**. If device is not supported, will throw err::ERR_NOT_IMPL.<br> **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err init(nn::SpeechDevice dev_type, const string &device_name) > ``` #### init (overload 1) Init the ASR library and select the type and name of the audio device. item description **type** func **param** **dev_type**: device type want to detect, can choose between WAV, PCM, or MIC.<br>**device_name**: device name want to detect, can choose a WAV file, a PCM file, or a MIC device name.<br> **throw** **1**. If am model is not loaded, will throw err::ERR_NOT_IMPL.<br>**2**. If device is not supported, will throw err::ERR_NOT_IMPL.<br> **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err init(nn::SpeechDevice dev_type, const string &device_name) > ``` #### devive ```python def devive(self, dev_type: SpeechDevice, device_name: str) > maix.err.Err ``` Reset the device, usually used for PCM/WAV recognition,\\nsuch as identifying the next WAV file. item description **type** func **param** **dev_type**: device type want to detect, can choose between WAV, PCM, or MIC.<br>**device_name**: device name want to detect, can choose a WAV file, a PCM file, or a MIC device name.<br> **throw** If device is not supported, will throw err::ERR_NOT_IMPL. **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err devive(nn::SpeechDevice dev_type, const string &device_name) > ``` #### devive (overload 1) Reset the device, usually used for PCM/WAV recognition,\\nsuch as identifying the next WAV file. item description **type** func **param** **dev_type**: device type want to detect, can choose between WAV, PCM, or MIC.<br>**device_name**: device name want to detect, can choose a WAV file, a PCM file, or a MIC device name.<br> **throw** If device is not supported, will throw err::ERR_NOT_IMPL. **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err devive(nn::SpeechDevice dev_type, const string &device_name) > ``` #### deinit ```python def deinit(self) > None ``` Deinit the ASR library. item description **type** func **static** False > C++ defination code: > ```cpp > void deinit() > ``` #### deinit (overload 1) Deinit the ASR library. item description **type** func **static** False > C++ defination code: > ```cpp > void deinit() > ``` #### dec\\_deinit ```python def dec_deinit(self, decoder: SpeechDecoder) > None ``` Deinit the decoder. item description **type** func **param** **decoder**: decoder type want to deinit<br>can choose between DECODER_RAW, DECODER_DIG, DECODER_LVCSR, DECODER_KWS or DECODER_ALL.<br> **throw** If device is not supported, will throw err::ERR_NOT_IMPL. **static** False > C++ defination code: > ```cpp > void dec_deinit(nn::SpeechDecoder decoder) > ``` #### dec\\_deinit (overload 1) Deinit the decoder. item description **type** func **param** **decoder**: decoder type want to deinit<br>can choose between DECODER_RAW, DECODER_DIG, DECODER_LVCSR, DECODER_KWS or DECODER_ALL.<br> **throw** If device is not supported, will throw err::ERR_NOT_IMPL. **static** False > C++ defination code: > ```cpp > void dec_deinit(nn::SpeechDecoder decoder) > ``` #### raw ```python def raw(self, callback: typing.Callable[[list[pnyp_t], int], None]) > maix.err.Err ``` Init raw decoder, it will output the prediction results of the original AM. item description **type** func **param** **callback**: raw decoder user callback.<br> **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err raw(std::function<void(std::vector<pnyp_t>, int)> callback) > ``` #### raw (overload 1) Get raw decoder status item description **type** func **return** bool, raw decoder status **static** False > C++ defination code: > ```cpp > bool raw() > ``` #### raw (overload 2) Init raw decoder, it will output the prediction results of the original AM. item description **type** func **param** **callback**: raw decoder user callback.<br> **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err raw(std::function<void(std::vector<pnyp_t>, int)> callback) > ``` #### raw (overload 3) Get raw decoder status item description **type** func **return** bool, raw decoder status **static** False > C++ defination code: > ```cpp > bool raw() > ``` #### digit ```python def digit(self, blank: int, callback: typing.Callable[[str, int], None]) > maix.err.Err ``` Init digit decoder, it will output the Chinese digit recognition results within the last 4 seconds. item description **type** func **param** **blank**: If it exceeds this value, insert a '_' in the output result to indicate idle mute.<br>**callback**: digit decoder user callback.<br> **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err digit(int blank, std::function<void(char*, int)> callback) > ``` #### digit (overload 1) Get digit decoder status item description **type** func **return** bool, digit decoder status **static** False > C++ defination code: > ```cpp > bool digit() > ``` #### digit (overload 2) Init digit decoder, it will output the Chinese digit recognition results within the last 4 seconds. item description **type** func **param** **blank**: If it exceeds this value, insert a '_' in the output result to indicate idle mute.<br>**callback**: digit decoder user callback.<br> **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err digit(int blank, std::function<void(char*, int)> callback) > ``` #### digit (overload 3) Get digit decoder status item description **type** func **return** bool, digit decoder status **static** False > C++ defination code: > ```cpp > bool digit() > ``` #### kws ```python def kws(self, kw_tbl: list[str], kw_gate: list[float], callback: typing.Callable[[list[float], int], None], auto_similar: bool True) > maix.err.Err ``` Init kws decoder, it will output a probability list of all registered keywords in the latest frame,\\nusers can set their own thresholds for wake up. item description **type** func **param** **kw_tbl**: Keyword list, filled in with spaces separated by pinyin, for example: xiao3 ai4 tong2 xue2<br>**kw_gate**: kw_gate, keyword probability gate table, the number should be the same as kw_tbl<br>**auto_similar**: Whether to perform automatic homophone processing,<br>setting it to true will automatically calculate the probability by using pinyin with different tones as homophones<br>**callback**: digit decoder user callback.<br> **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err kws(std::vector<string> kw_tbl, std::vector<float> kw_gate, std::function<void(std::vector<float>, int)> callback, bool auto_similar true) > ``` #### kws (overload 1) Get kws decoder status item description **type** func **return** bool, kws decoder status **static** False > C++ defination code: > ```cpp > bool kws() > ``` #### kws (overload 2) Init kws decoder, it will output a probability list of all registered keywords in the latest frame,\\nusers can set their own thresholds for wake up. item description **type** func **param** **kw_tbl**: Keyword list, filled in with spaces separated by pinyin, for example: xiao3 ai4 tong2 xue2<br>**kw_gate**: kw_gate, keyword probability gate table, the number should be the same as kw_tbl<br>**auto_similar**: Whether to perform automatic homophone processing,<br>setting it to true will automatically calculate the probability by using pinyin with different tones as homophones<br>**callback**: digit decoder user callback.<br> **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err kws(std::vector<string> kw_tbl, std::vector<float> kw_gate, std::function<void(std::vector<float>, int)> callback, bool auto_similar true) > ``` #### kws (overload 3) Get kws decoder status item description **type** func **return** bool, kws decoder status **static** False > C++ defination code: > ```cpp > bool kws() > ``` #### lvcsr ```python def lvcsr(self, sfst_name: str, sym_name: str, phones_txt: str, words_txt: str, callback: typing.Callable[[tuple[str, str], int], None], beam: float 8, bg_prob: float 10, scale: float 0.5, mmap: bool False) > maix.err.Err ``` Init lvcsr decoder, it will output continuous speech recognition results (less than 1024 Chinese characters). item description **type** func **param** **sfst_name**: Sfst file path.<br>**sym_name**: Sym file path (output symbol table).<br>**phones_txt**: Path to phones.bin (pinyin table).<br>**words_txt**: Path to words.bin (dictionary table).<br>**callback**: lvcsr decoder user callback.<br>**beam**: The beam size for WFST search is set to 8 by default, and it is recommended to be between 3 and 9.<br>The larger the size, the larger the search space, and the more accurate but slower the search.<br>**bg_prob**: The absolute value of the natural logarithm of the default probability value for background pinyin<br>outside of BEAM CNT is set to 10 by default.<br>**scale**: acoustics_cost log(pny_prob)*scale.<br>**mmap**: use mmap to load the WFST decoding image,<br>If set to true, the beam should be less than 5.<br> **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err lvcsr(const string &sfst_name, const string &sym_name, > const string &phones_txt, const string &words_txt, > std::function<void(std::pair<char*, char*>, int)> callback, > float beam 8, float bg_prob 10, float scale 0.5, bool mmap false) > ``` #### lvcsr (overload 1) Get lvcsr decoder status item description **type** func **return** bool, lvcsr decoder status **static** False > C++ defination code: > ```cpp > bool lvcsr() > ``` #### lvcsr (overload 2) Init lvcsr decoder, it will output continuous speech recognition results (less than 1024 Chinese characters). item description **type** func **param** **sfst_name**: Sfst file path.<br>**sym_name**: Sym file path (output symbol table).<br>**phones_txt**: Path to phones.bin (pinyin table).<br>**words_txt**: Path to words.bin (dictionary table).<br>**callback**: lvcsr decoder user callback.<br>**beam**: The beam size for WFST search is set to 8 by default, and it is recommended to be between 3 and 9.<br>The larger the size, the larger the search space, and the more accurate but slower the search.<br>**bg_prob**: The absolute value of the natural logarithm of the default probability value for background pinyin<br>outside of BEAM CNT is set to 10 by default.<br>**scale**: acoustics_cost log(pny_prob)*scale.<br>**mmap**: use mmap to load the WFST decoding image,<br>If set to true, the beam should be less than 5.<br> **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err lvcsr(const string &sfst_name, const string &sym_name, > const string &phones_txt, const string &words_txt, > std::function<void(std::pair<char*, char*>, int)> callback, > float beam 8, float bg_prob 10, float scale 0.5, bool mmap false) > ``` #### lvcsr (overload 3) Get lvcsr decoder status item description **type** func **return** bool, lvcsr decoder status **static** False > C++ defination code: > ```cpp > bool lvcsr() > ``` #### run ```python def run(self, frame: int) > int ``` Run speech recognition, user can run 1 frame at a time and do other processing after running,\\nor it can run continuously within a thread and be stopped by an external thread. item description **type** func **param** **frame**: The number of frames per run.<br> **return** int type, return actual number of frames in the run. **static** False > C++ defination code: > ```cpp > int run(int frame) > ``` #### run (overload 1) Run speech recognition, user can run 1 frame at a time and do other processing after running,\\nor it can run continuously within a thread and be stopped by an external thread. item description **type** func **param** **frame**: The number of frames per run.<br> **return** int type, return actual number of frames in the run. **static** False > C++ defination code: > ```cpp > int run(int frame) > ``` #### clear ```python def clear(self) > None ``` Reset internal cache operation item description **type** func **static** False > C++ defination code: > ```cpp > void clear() > ``` #### clear (overload 1) Reset internal cache operation item description **type** func **static** False > C++ defination code: > ```cpp > void clear() > ``` #### frame\\_time ```python def frame_time(self) > int ``` Get the time of one frame. item description **type** func **return** int type, return the time of one frame. **static** False > C++ defination code: > ```cpp > int frame_time() > ``` #### frame\\_time (overload 1) Get the time of one frame. item description **type** func **return** int type, return the time of one frame. **static** False > C++ defination code: > ```cpp > int frame_time() > ``` #### vocab ```python def vocab(self) > tuple[str, int] ``` Get the acoustic model dictionary. item description **type** func **return** std::pair<char*, int> type, return the dictionary and length. **static** False > C++ defination code: > ```cpp > std::pair<char*, int> vocab() > ``` #### vocab (overload 1) Get the acoustic model dictionary. item description **type** func **return** std::pair<char*, int> type, return the dictionary and length. **static** False > C++ defination code: > ```cpp > std::pair<char*, int> vocab() > ``` #### similar ```python def similar(self, pny: str, similar_pnys: list[str]) > maix.err.Err ``` Manually register mute words, and each pinyin can register up to 10 homophones,\\nplease note that using this interface to register homophones will overwrite,\\nthe homophone table automatically generated in the \\\"automatic homophone processing\\\" feature. item description **type** func **param** **dev_type**: device type want to detect, can choose between WAV, PCM, or MIC.<br>**device_name**: device name want to detect, can choose a WAV file, a PCM file, or a MIC device name.<br> **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err similar(const string &pny, std::vector<std::string> similar_pnys) > ``` #### similar (overload 1) Manually register mute words, and each pinyin can register up to 10 homophones,\\nplease note that using this interface to register homophones will overwrite,\\nthe homophone table automatically generated in the \\\"automatic homophone processing\\\" feature. item description **type** func **param** **dev_type**: device type want to detect, can choose between WAV, PCM, or MIC.<br>**device_name**: device name want to detect, can choose a WAV file, a PCM file, or a MIC device name.<br> **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err similar(const string &pny, std::vector<std::string> similar_pnys) > ``` #### mean Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` #### dev\\_type ```python def dev_type(self) > SpeechDevice ``` get device type item description **type** func **return** nn::SpeechDevice type, see SpeechDevice of this module **static** False > C++ defination code: > ```cpp > nn::SpeechDevice dev_type() > ``` #### dev\\_type (overload 1) get device type item description **type** func **return** nn::SpeechDevice type, see SpeechDevice of this module **static** False > C++ defination code: > ```cpp > nn::SpeechDevice dev_type() > ``` ### YOLOv8 YOLOv8 class > C++ defination code: > ```cpp > class YOLOv8 > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, model: str '', dual_buff: bool True) > None ``` Constructor of YOLOv8 class item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br>**dual_buff**: direction [in], prepare dual input output buffer to accelarate forward, that is, when NPU is forwarding we not wait and prepare the next input buff.<br>If you want to ensure every time forward output the input's result, set this arg to false please.<br>Default true to ensure speed.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > YOLOv8(const string &model \"\", bool dual_buff true) > ``` #### load ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### detect ```python def detect(self, img: maix.image.Image, conf_th: float 0.5, iou_th: float 0.45, fit: maix.image.Fit ..., keypoint_th: float 0.5) > ... ``` Detect objects from image item description **type** func **param** **img**: Image want to detect, if image's size not match model input's, will auto resize with fit method.<br>**conf_th**: Confidence threshold, default 0.5.<br>**iou_th**: IoU threshold, default 0.45.<br>**fit**: Resize method, default image.Fit.FIT_CONTAIN.<br>**keypoint_th**: keypoint threshold, default 0.5, only for yolov8 pose model.<br> **throw** If image format not match model input format, will throw err::Exception. **return** Object list. In C++, you should delete it after use.<br>If model is yolov8 pose, object's points have value, and if points' value < 0 means that point is invalid(conf < keypoint_th). **static** False > C++ defination code: > ```cpp > nn::Objects *detect(image::Image &img, float conf_th 0.5, float iou_th 0.45, maix::image::Fit fit maix::image::FIT_CONTAIN, float keypoint_th 0.5) > ``` #### input\\_size ```python def input_size(self) > maix.image.Size ``` Get model input size item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width ```python def input_width(self) > int ``` Get model input width item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height ```python def input_height(self) > int ``` Get model input height item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format ```python def input_format(self) > maix.image.Format ``` Get input image format item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### draw\\_pose ```python def draw_pose(self, img: maix.image.Image, points: list[int], radius: int 4, color: maix.image.Color ..., body: bool True) > None ``` Draw pose keypoints on image item description **type** func **param** **img**: image object, maix.image.Image type.<br>**points**: keypoits, int list type, [x, y, x, y ...]<br>**radius**: radius of points.<br>**color**: color of points.<br>**body**: true, if points' length is 17*2 and body is ture, will draw lines as human body, if set to false won't draw lines, default true.<br> **static** False > C++ defination code: > ```cpp > void draw_pose(image::Image &img, std::vector<int> points, int radius 4, image::Color color image::COLOR_RED, bool body true) > ``` #### draw\\_seg\\_mask ```python def draw_seg_mask(self, img: maix.image.Image, x: int, y: int, seg_mask: maix.image.Image, threshold: int 127) > None ``` Draw segmentation on image item description **type** func **param** **img**: image object, maix.image.Image type.<br>**seg_mask**: segmentation mask image by detect method, a grayscale image<br>**threshold**: only mask's value > threshold will be draw on image, value from 0 to 255.<br> **static** False > C++ defination code: > ```cpp > void draw_seg_mask(image::Image &img, int x, int y, image::Image &seg_mask, int threshold 127) > ``` #### labels Labels list item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<string> labels > ``` #### label\\_path Label file path item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string label_path > ``` #### mean Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` ### Object Object for detect result > C++ defination code: > ```cpp > class Object > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, x: int 0, y: int 0, w: int 0, h: int 0, class_id: int 0, score: float 0, points: list[int] []) > None ``` Constructor of Object for detect result item description **type** func **param** **x**: left top x<br>**y**: left top y<br>**w**: width<br>**h**: height<br>**class_id**: class id<br>**score**: score<br> **static** False > C++ defination code: > ```cpp > Object(int x 0, int y 0, int w 0, int h 0, int class_id 0, float score 0, std::vector<int> points std::vector<int>()) > ``` #### \\_\\_str\\_\\_ ```python def __str__(self) > str ``` Object info to string item description **type** func **return** Object info string **static** False > C++ defination code: > ```cpp > std::string to_str() > ``` #### x Object left top coordinate x item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int x > ``` #### y Object left top coordinate y item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int y > ``` #### w Object width item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int w > ``` #### h Object height item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int h > ``` #### class\\_id Object class id item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int class_id > ``` #### score Object score item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float score > ``` #### points keypoints item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<int> points > ``` #### seg\\_mask segmentation mask, uint8 list type, shape is h * w but flattened to one dimension, value fron 0 to 255. item description **type** var **attention** For efficiency, it's a pointer in C++, use this carefully! **static** False **readonly** False > C++ defination code: > ```cpp > image::Image *seg_mask > ``` ### ObjectFloat Object for detect result > C++ defination code: > ```cpp > class ObjectFloat > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, x: float 0, y: float 0, w: float 0, h: float 0, class_id: float 0, score: float 0, points: list[float] []) > None ``` Constructor of Object for detect result item description **type** func **param** **x**: left top x<br>**y**: left top y<br>**w**: width<br>**h**: height<br>**class_id**: class id<br>**score**: score<br> **static** False > C++ defination code: > ```cpp > ObjectFloat(float x 0, float y 0, float w 0, float h 0, float class_id 0, float score 0, std::vector<float> points std::vector<float>()) > ``` #### \\_\\_str\\_\\_ ```python def __str__(self) > str ``` Object info to string item description **type** func **return** Object info string **static** False > C++ defination code: > ```cpp > std::string to_str() > ``` #### x Object left top coordinate x item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float x > ``` #### y Object left top coordinate y item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float y > ``` #### w Object width item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float w > ``` #### h Object height item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float h > ``` #### class\\_id Object class id item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float class_id > ``` #### score Object score item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float score > ``` #### points keypoints item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> points > ``` ### Objects Objects Class for detect result > C++ defination code: > ```cpp > class Objects > ``` #### \\_\\_init\\_\\_ ```python def __init__(self) > None ``` Constructor of Objects class item description **type** func **static** False > C++ defination code: > ```cpp > Objects() > ``` #### add ```python def add(self, x: int 0, y: int 0, w: int 0, h: int 0, class_id: int 0, score: float 0, points: list[int] []) > Object ``` Add object to objects item description **type** func **throw** Throw exception if no memory **static** False > C++ defination code: > ```cpp > nn::Object &add(int x 0, int y 0, int w 0, int h 0, int class_id 0, float score 0, std::vector<int> points std::vector<int>()) > ``` #### remove ```python def remove(self, idx: int) > maix.err.Err ``` Remove object form objects item description **type** func **static** False > C++ defination code: > ```cpp > err::Err remove(int idx) > ``` #### at ```python def at(self, idx: int) > Object ``` Get object item item description **type** func **static** False > C++ defination code: > ```cpp > nn::Object &at(int idx) > ``` #### \\_\\_item\\_\\_ ```python def __item__(self, idx: int) > Object ``` Get object item item description **type** func **static** False > C++ defination code: > ```cpp > nn::Object &operator[](int idx) > ``` #### \\_\\_len\\_\\_ ```python def __len__(self) > int ``` Get size item description **type** func **static** False > C++ defination code: > ```cpp > size_t size() > ``` #### \\_\\_iter\\_\\_ ```python def __iter__(self) > typing.Iterator ``` Begin item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<Object*>::iterator begin() > ``` ### MUD MUD(model universal describe file) class > C++ defination code: > ```cpp > class MUD > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, model_path: str None) > None ``` MUD constructor item description **type** func **param** **model_path**: direction [in], model file path, model format can be MUD(model universal describe file) file.<br>If model_path set, will load model from file, load failed will raise err.Exception.<br>If model_path not set, you can load model later by load function.<br> **static** False > C++ defination code: > ```cpp > MUD(const char *model_path nullptr) > ``` #### load ```python def load(self, model_path: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model_path**: direction [in], model file path, model format can be MUD(model universal describe file) file.<br> **return** error code, if load success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err load(const std::string &model_path) > ``` #### type Model type, string type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string type > ``` #### items Model config items, different model type has different config items item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::map<std::string, std::map<std::string, std::string>> items > ``` ### LayerInfo NN model layer info > C++ defination code: > ```cpp > class LayerInfo > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, name: str '', dtype: maix.tensor.DType ..., shape: list[int] []) > None ``` LayerInfo constructor item description **type** func **param** **name**: direction [in], layer name<br>**dtype**: direction [in], layer data type<br>**shape**: direction [in], layer shape<br> **static** False > C++ defination code: > ```cpp > LayerInfo(const std::string &name \"\", tensor::DType dtype tensor::DType::FLOAT32, std::vector<int> shape std::vector<int>()) > ``` #### name Layer name item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string name > ``` #### dtype Layer data type item description **type** var **attention** If model is quantized, this is the real quantized data type like int8 float16,<br>in most scene, inputs and outputs we actually use float32 in API like forward. **static** False **readonly** False > C++ defination code: > ```cpp > tensor::DType dtype > ``` #### shape Layer shape item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<int> shape > ``` #### shape\\_int ```python def shape_int(self) > int ``` Shape as one int type, multiply all dims of shape item description **type** func **static** False > C++ defination code: > ```cpp > int shape_int() > ``` #### to\\_str ```python def to_str(self) > str ``` To string item description **type** func **static** False > C++ defination code: > ```cpp > std::string to_str() > ``` #### \\_\\_str\\_\\_ ```python def __str__(self) > str ``` To string item description **type** func **static** False > C++ defination code: > ```cpp > std::string __str__() > ``` ### NN Neural network class > C++ defination code: > ```cpp > class NN > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, model: str '', dual_buff: bool True) > None ``` Neural network constructor item description **type** func **param** **model**: direction [in], model file path, model format can be MUD(model universal describe file) file.<br>If model_path set, will load model from file, load failed will raise err.Exception.<br>If model_path not set, you can load model later by load function.<br>**dual_buff**: direction [in], prepare dual input output buffer to accelarate forward, that is, when NPU is forwarding we not wait and prepare the next input buff.<br>If you want to ensure every time forward output the input's result, set this arg to false please.<br>Default true to ensure speed.<br> **static** False > C++ defination code: > ```cpp > NN(const std::string &model \"\", bool dual_buff true) > ``` #### load ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: direction [in], model file path, model format can be MUD(model universal describe file) file.<br> **return** error code, if load success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err load(const std::string &model) > ``` #### loaded ```python def loaded(self) > bool ``` Is model loaded item description **type** func **return** true if model loaded, else false **static** False > C++ defination code: > ```cpp > bool loaded() > ``` #### set\\_dual\\_buff ```python def set_dual_buff(self, enable: bool) > None ``` Enable dual buff or disable dual buff item description **type** func **param** **enable**: true to enable, false to disable<br> **static** False > C++ defination code: > ```cpp > void set_dual_buff(bool enable) > ``` #### inputs\\_info ```python def inputs_info(self) > list[LayerInfo] ``` Get model input layer info item description **type** func **return** input layer info **static** False > C++ defination code: > ```cpp > std::vector<nn::LayerInfo> inputs_info() > ``` #### outputs\\_info ```python def outputs_info(self) > list[LayerInfo] ``` Get model output layer info item description **type** func **return** output layer info **static** False > C++ defination code: > ```cpp > std::vector<nn::LayerInfo> outputs_info() > ``` #### extra\\_info ```python def extra_info(self) > dict[str, str] ``` Get model extra info define in MUD file item description **type** func **return** extra info, dict type, key value object, attention: key and value are all string type. **static** False > C++ defination code: > ```cpp > std::map<std::string, std::string> extra_info() > ``` #### forward ```python def forward(self, inputs: maix.tensor.Tensors, copy_result: bool True, dual_buff_wait: bool False) > maix.tensor.Tensors ``` forward run model, get output of model,\\nthis is specially for MaixPy, not efficient, but easy to use in MaixPy item description **type** func **param** **input**: direction [in], input tensor<br>**copy_result**: If set true, will copy result to a new variable; else will use a internal memory, you can only use it until to the next forward.<br>Default true to avoid problems, you can set it to false manually to make speed faster.<br>**dual_buff_wait**: bool type, only for dual_buff mode, if true, will inference this image and wait for result, default false.<br> **return** output tensor. In C++, you should manually delete tensors in return value and return value.<br>If dual_buff mode, it can be NULL(None in MaixPy) means not ready. **throw** if error ocurrs like no memory or arg error, will raise err.Exception. **static** False > C++ defination code: > ```cpp > tensor::Tensors *forward(tensor::Tensors &inputs, bool copy_result true, bool dual_buff_wait false) > ``` #### forward\\_image ```python def forward_image(self, img: maix.image.Image, mean: list[float] [], scale: list[float] [], fit: maix.image.Fit ..., copy_result: bool True, dual_buff_wait: bool False) > maix.tensor.Tensors ``` forward model, param is image item description **type** func **param** **img**: input image<br>**mean**: mean value, a list type, e.g. [0.485, 0.456, 0.406], default is empty list means not normalize.<br>**scale**: scale value, a list type, e.g. [1/0.229, 1/0.224, 1/0.225], default is empty list means not normalize.<br>**fit**: fit mode, if the image size of input not equal to model's input, it will auto resize use this fit method,<br>default is image.Fit.FIT_FILL for easy coordinate calculation, but for more accurate result, use image.Fit.FIT_CONTAIN is better.<br>**copy_result**: If set true, will copy result to a new variable; else will use a internal memory, you can only use it until to the next forward.<br>Default true to avoid problems, you can set it to false manually to make speed faster.<br>**dual_buff_wait**: bool type, only for dual_buff mode, if true, will inference this image and wait for result, default false.<br> **return** output tensor. In C++, you should manually delete tensors in return value and return value.<br>If dual_buff mode, it can be NULL(None in MaixPy) means not ready. **throw** If error occurs, like arg error or alloc memory failed, will raise err.Exception. **static** False > C++ defination code: > ```cpp > tensor::Tensors *forward_image(image::Image &img, std::vector<float> mean std::vector<float>(), std::vector<float> scale std::vector<float>(), image::Fit fit image::Fit::FIT_FILL, bool copy_result true, bool dual_buff_wait false) > ``` ### FaceObject Face object > C++ defination code: > ```cpp > class FaceObject > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, x: int 0, y: int 0, w: int 0, h: int 0, class_id: int 0, score: float 0, points: list[int] [], feature: list[float] [], face: maix.image.Image ...) > None ``` Constructor item description **type** func **static** False > C++ defination code: > ```cpp > FaceObject(int x 0, int y 0, int w 0, int h 0, int class_id 0, float score 0, std::vector<int> points std::vector<int>(), std::vector<float> feature std::vector<float>(), image::Image face image::Image()) > ``` #### \\_\\_str\\_\\_ ```python def __str__(self) > str ``` FaceObject info to string item description **type** func **return** FaceObject info string **static** False > C++ defination code: > ```cpp > std::string to_str() > ``` #### x FaceObject left top coordinate x item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int x > ``` #### y FaceObject left top coordinate y item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int y > ``` #### w FaceObject width item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int w > ``` #### h FaceObject height item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int h > ``` #### class\\_id FaceObject class id item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int class_id > ``` #### score FaceObject score item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float score > ``` #### points keypoints item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<int> points > ``` #### feature feature, float list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> feature > ``` #### face face image item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > image::Image face > ``` ### FaceRecognizer FaceRecognizer class > C++ defination code: > ```cpp > class FaceRecognizer > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, detect_model: str '', feature_model: str '', dual_buff: bool True) > None ``` Constructor of FaceRecognizer class item description **type** func **param** **detect_model**: face detect model path, default empty, you can load model later by load function.<br>**feature_model**: feature extract model<br>**dual_buff**: direction [in], prepare dual input output buffer to accelarate forward, that is, when NPU is forwarding we not wait and prepare the next input buff.<br>If you want to ensure every time forward output the input's result, set this arg to false please.<br>Default true to ensure speed.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > FaceRecognizer(const string &detect_model \"\", const string &feature_model \"\", bool dual_buff true) > ``` #### load ```python def load(self, detect_model: str, feature_model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **detect_model**: face detect model path, default empty, you can load model later by load function.<br>**feature_model**: feature extract model<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &detect_model, const string &feature_model) > ``` #### recognize ```python def recognize(self, img: maix.image.Image, conf_th: float 0.5, iou_th: float 0.45, compare_th: float 0.8, get_feature: bool False, get_face: bool False, fit: maix.image.Fit ...) > list[FaceObject] ``` Detect objects from image item description **type** func **param** **img**: Image want to detect, if image's size not match model input's, will auto resize with fit method.<br>**conf_th**: Detect confidence threshold, default 0.5.<br>**iou_th**: Detect IoU threshold, default 0.45.<br>**compare_th**: Compare two face score threshold, default 0.8, if two faces' score < this value, will see this face fas unknown.<br>**get_feature**: return feature or not, if true will copy features to result, if false will not copy feature to result to save time and memory.<br>**get_face**: return face image or not, if true result object's face attribute will valid, or face sttribute is empty. Get face image will alloc memory and copy image, so will lead to slower speed.<br>**fit**: Resize method, default image.Fit.FIT_CONTAIN.<br> **throw** If image format not match model input format, will throw err::Exception. **return** FaceObject list. In C++, you should delete it after use. **static** False > C++ defination code: > ```cpp > std::vector<nn::FaceObject> *recognize(image::Image &img, float conf_th 0.5, float iou_th 0.45, float compare_th 0.8, bool get_feature false, bool get_face false, maix::image::Fit fit maix::image::FIT_CONTAIN) > ``` #### add\\_face ```python def add_face(self, face: FaceObject, label: str) > maix.err.Err ``` Add face to lib item description **type** func **param** **face**: face object, find by recognize<br>**label**: face label(name)<br> **static** False > C++ defination code: > ```cpp > err::Err add_face(nn::FaceObject *face, const std::string &label) > ``` #### remove\\_face ```python def remove_face(self, idx: int 1, label: str '') > maix.err.Err ``` remove face from lib item description **type** func **param** **idx**: index of face in lib, default 1 means use label, idx and label must have one, idx have high priotiry.<br>**label**: which face to remove, default to empty string mean use idx, idx and label must have one, idx have high priotiry.<br> **static** False > C++ defination code: > ```cpp > err::Err remove_face(int idx 1, const std::string &label \"\") > ``` #### save\\_faces ```python def save_faces(self, path: str) > maix.err.Err ``` Save faces info to a file item description **type** func **param** **path**: where to save, string type.<br> **return** err.Err type **static** False > C++ defination code: > ```cpp > err::Err save_faces(const std::string &path) > ``` #### load\\_faces ```python def load_faces(self, path: str) > maix.err.Err ``` Load faces info from a file item description **type** func **param** **path**: from where to load, string type.<br> **return** err::Err type **static** False > C++ defination code: > ```cpp > err::Err load_faces(const std::string &path) > ``` #### input\\_size ```python def input_size(self) > maix.image.Size ``` Get model input size item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width ```python def input_width(self) > int ``` Get model input width item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height ```python def input_height(self) > int ``` Get model input height item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format ```python def input_format(self) > maix.image.Format ``` Get input image format item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### mean\\_detector Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean_detector > ``` #### scale\\_detector Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale_detector > ``` #### mean\\_feature Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean_feature > ``` #### scale\\_feature Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale_feature > ``` #### labels labels, list type, first is \\\"unknown\\\" item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<std::string> labels > ``` #### features features item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<std::vector<float>> features > ``` ### SelfLearnClassifier SelfLearnClassifier > C++ defination code: > ```cpp > class SelfLearnClassifier > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, model: str '', dual_buff: bool True) > None ``` Construct a new SelfLearnClassifier object item description **type** func **param** **model**: MUD model path, if empty, will not load model, you can call load_model() later.<br>if not empty, will load model and will raise err::Exception if load failed.<br>**dual_buff**: direction [in], prepare dual input output buffer to accelarate forward, that is, when NPU is forwarding we not wait and prepare the next input buff.<br>If you want to ensure every time forward output the input's result, set this arg to false please.<br>Default true to ensure speed.<br> **static** False > C++ defination code: > ```cpp > SelfLearnClassifier(const std::string &model \"\", bool dual_buff true) > ``` #### load\\_model ```python def load_model(self, model: str) > maix.err.Err ``` Load model from file, model format is .mud,\\nMUD file should contain [extra] section, have key values:\\n model_type: classifier_no_top\\n input_type: rgb or bgr\\n mean: 123.675, 116.28, 103.53\\n scale: 0.017124753831663668, 0.01750700280112045, 0.017429193899782137 item description **type** func **param** **model**: MUD model path<br> **return** error code, if load failed, return error code **static** False > C++ defination code: > ```cpp > err::Err load_model(const string &model) > ``` #### classify ```python def classify(self, img: maix.image.Image, fit: maix.image.Fit ...) > list[tuple[int, float]] ``` Classify image item description **type** func **param** **img**: image, format should match model input_type， or will raise err.Exception<br>**fit**: image resize fit mode, default Fit.FIT_COVER, see image.Fit.<br> **throw** If error occurred, will raise err::Exception, you can find reason in log, mostly caused by args error or hardware error. **return** result, a list of (idx, distance), smaller distance means more similar. In C++, you need to delete it after use. **static** False > C++ defination code: > ```cpp > std::vector<std::pair<int, float>> *classify(image::Image &img, image::Fit fit image::FIT_COVER) > ``` #### add\\_class ```python def add_class(self, img: maix.image.Image, fit: maix.image.Fit ...) > None ``` Add a class to recognize item description **type** func **param** **img**: Add a image as a new class<br>**fit**: image resize fit mode, default Fit.FIT_COVER, see image.Fit.<br> **static** False > C++ defination code: > ```cpp > void add_class(image::Image &img, image::Fit fit image::FIT_COVER) > ``` #### class\\_num ```python def class_num(self) > int ``` Get class number item description **type** func **static** False > C++ defination code: > ```cpp > int class_num() > ``` #### rm\\_class ```python def rm_class(self, idx: int) > maix.err.Err ``` Remove a class item description **type** func **param** **idx**: index, value from 0 to class_num();<br> **static** False > C++ defination code: > ```cpp > err::Err rm_class(int idx) > ``` #### add\\_sample ```python def add_sample(self, img: maix.image.Image, fit: maix.image.Fit ...) > None ``` Add sample, you should call learn method after add some samples to learn classes.\\nSample image can be any of classes we already added. item description **type** func **param** **img**: Add a image as a new sample.<br> **static** False > C++ defination code: > ```cpp > void add_sample(image::Image &img, image::Fit fit image::FIT_COVER) > ``` #### rm\\_sample ```python def rm_sample(self, idx: int) > maix.err.Err ``` Remove a sample item description **type** func **param** **idx**: index, value from 0 to sample_num();<br> **static** False > C++ defination code: > ```cpp > err::Err rm_sample(int idx) > ``` #### sample\\_num ```python def sample_num(self) > int ``` Get sample number item description **type** func **static** False > C++ defination code: > ```cpp > int sample_num() > ``` #### learn ```python def learn(self) > int ``` Start auto learn class features from classes image and samples.\\nYou should call this method after you add some samples. item description **type** func **return** learn epoch(times), 0 means learn nothing. **static** False > C++ defination code: > ```cpp > int learn() > ``` #### clear ```python def clear(self) > None ``` Clear all class and samples item description **type** func **static** False > C++ defination code: > ```cpp > void clear() > ``` #### input\\_size ```python def input_size(self) > maix.image.Size ``` Get model input size, only for image input item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width ```python def input_width(self) > int ``` Get model input width, only for image input item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height ```python def input_height(self) > int ``` Get model input height, only for image input item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format ```python def input_format(self) > maix.image.Format ``` Get input image format, only for image input item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### input\\_shape ```python def input_shape(self) > list[int] ``` Get input shape, if have multiple input, only return first input shape item description **type** func **return** input shape, list type **static** False > C++ defination code: > ```cpp > std::vector<int> input_shape() > ``` #### save ```python def save(self, path: str, labels: list[str] []) > maix.err.Err ``` Save features and labels to a binary file item description **type** func **param** **path**: file path to save, e.g. /root/my_classes.bin<br>**labels**: class labels, can be None, or length must equal to class num, or will return err::Err<br> **return** maix.err.Err if labels exists but length not equal to class num, or save file failed, or class num is 0. **static** False > C++ defination code: > ```cpp > err::Err save(const std::string &path, const std::vector<std::string> &labels std::vector<std::string>()) > ``` #### load ```python def load(self, path: str) > list[str] ``` Load features info from binary file item description **type** func **param** **path**: feature info binary file path, e.g. /root/my_classes.bin<br> **static** False > C++ defination code: > ```cpp > std::vector<std::string> load(const std::string &path) > ``` #### labels Labels list item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<string> labels > ``` #### label\\_path Label file path item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string label_path > ``` #### mean Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` ### YOLOv5 YOLOv5 class > C++ defination code: > ```cpp > class YOLOv5 > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, model: str '', dual_buff: bool True) > None ``` Constructor of YOLOv5 class item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br>**dual_buff**: direction [in], prepare dual input output buffer to accelarate forward, that is, when NPU is forwarding we not wait and prepare the next input buff.<br>If you want to ensure every time forward output the input's result, set this arg to false please.<br>Default true to ensure speed.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > YOLOv5(const string &model \"\", bool dual_buff true) > ``` #### load ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### detect ```python def detect(self, img: maix.image.Image, conf_th: float 0.5, iou_th: float 0.45, fit: maix.image.Fit ...) > list[Object] ``` Detect objects from image item description **type** func **param** **img**: Image want to detect, if image's size not match model input's, will auto resize with fit method.<br>**conf_th**: Confidence threshold, default 0.5.<br>**iou_th**: IoU threshold, default 0.45.<br>**fit**: Resize method, default image.Fit.FIT_CONTAIN.<br> **throw** If image format not match model input format, will throw err::Exception. **return** Object list. In C++, you should delete it after use. **static** False > C++ defination code: > ```cpp > std::vector<nn::Object> *detect(image::Image &img, float conf_th 0.5, float iou_th 0.45, maix::image::Fit fit maix::image::FIT_CONTAIN) > ``` #### input\\_size ```python def input_size(self) > maix.image.Size ``` Get model input size item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width ```python def input_width(self) > int ``` Get model input width item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height ```python def input_height(self) > int ``` Get model input height item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format ```python def input_format(self) > maix.image.Format ``` Get input image format item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### labels Labels list item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<string> labels > ``` #### label\\_path Label file path item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string label_path > ``` #### mean Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` #### anchors Get anchors item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> anchors > ``` ### YOLO11 YOLO11 class > C++ defination code: > ```cpp > class YOLO11 > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, model: str '', dual_buff: bool True) > None ``` Constructor of YOLO11 class item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br>**dual_buff**: direction [in], prepare dual input output buffer to accelarate forward, that is, when NPU is forwarding we not wait and prepare the next input buff.<br>If you want to ensure every time forward output the input's result, set this arg to false please.<br>Default true to ensure speed.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > YOLO11(const string &model \"\", bool dual_buff true) > ``` #### load ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### detect ```python def detect(self, img: maix.image.Image, conf_th: float 0.5, iou_th: float 0.45, fit: maix.image.Fit ..., keypoint_th: float 0.5) > Objects ``` Detect objects from image item description **type** func **param** **img**: Image want to detect, if image's size not match model input's, will auto resize with fit method.<br>**conf_th**: Confidence threshold, default 0.5.<br>**iou_th**: IoU threshold, default 0.45.<br>**fit**: Resize method, default image.Fit.FIT_CONTAIN.<br>**keypoint_th**: keypoint threshold, default 0.5, only for yolo11 pose model.<br> **throw** If image format not match model input format, will throw err::Exception. **return** Object list. In C++, you should delete it after use.<br>If model is yolo11 pose, object's points have value, and if points' value < 0 means that point is invalid(conf < keypoint_th). **static** False > C++ defination code: > ```cpp > nn::Objects *detect(image::Image &img, float conf_th 0.5, float iou_th 0.45, maix::image::Fit fit maix::image::FIT_CONTAIN, float keypoint_th 0.5) > ``` #### input\\_size ```python def input_size(self) > maix.image.Size ``` Get model input size item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width ```python def input_width(self) > int ``` Get model input width item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height ```python def input_height(self) > int ``` Get model input height item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format ```python def input_format(self) > maix.image.Format ``` Get input image format item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### draw\\_pose ```python def draw_pose(self, img: maix.image.Image, points: list[int], radius: int 4, color: maix.image.Color ..., body: bool True) > None ``` Draw pose keypoints on image item description **type** func **param** **img**: image object, maix.image.Image type.<br>**points**: keypoits, int list type, [x, y, x, y ...]<br>**radius**: radius of points.<br>**color**: color of points.<br>**body**: true, if points' length is 17*2 and body is ture, will draw lines as human body, if set to false won't draw lines, default true.<br> **static** False > C++ defination code: > ```cpp > void draw_pose(image::Image &img, std::vector<int> points, int radius 4, image::Color color image::COLOR_RED, bool body true) > ``` #### draw\\_seg\\_mask ```python def draw_seg_mask(self, img: maix.image.Image, x: int, y: int, seg_mask: maix.image.Image, threshold: int 127) > None ``` Draw segmentation on image item description **type** func **param** **img**: image object, maix.image.Image type.<br>**seg_mask**: segmentation mask image by detect method, a grayscale image<br>**threshold**: only mask's value > threshold will be draw on image, value from 0 to 255.<br> **static** False > C++ defination code: > ```cpp > void draw_seg_mask(image::Image &img, int x, int y, image::Image &seg_mask, int threshold 127) > ``` #### labels Labels list item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<string> labels > ``` #### label\\_path Label file path item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string label_path > ``` #### mean Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` ### Classifier Classifier > C++ defination code: > ```cpp > class Classifier > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, model: str '', dual_buff: bool True) > None ``` Construct a new Classifier object item description **type** func **param** **model**: MUD model path, if empty, will not load model, you can call load() later.<br>if not empty, will load model and will raise err::Exception if load failed.<br>**dual_buff**: direction [in], prepare dual input output buffer to accelarate forward, that is, when NPU is forwarding we not wait and prepare the next input buff.<br>If you want to ensure every time forward output the input's result, set this arg to false please.<br>Default true to ensure speed.<br> **static** False > C++ defination code: > ```cpp > Classifier(const string &model \"\", bool dual_buff true) > ``` #### load ```python def load(self, model: str) > maix.err.Err ``` Load model from file, model format is .mud,\\nMUD file should contain [extra] section, have key values:\\n model_type: classifier\\n input_type: rgb or bgr\\n mean: 123.675, 116.28, 103.53\\n scale: 0.017124753831663668, 0.01750700280112045, 0.017429193899782137\\n labels: imagenet_classes.txt item description **type** func **param** **model**: MUD model path<br> **return** error code, if load failed, return error code **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### classify ```python def classify(self, img: maix.image.Image, softmax: bool True, fit: maix.image.Fit ...) > list[tuple[int, float]] ``` Forward image to model, get result. Only for image input, use classify_raw for tensor input. item description **type** func **param** **img**: image, format should match model input_type， or will raise err.Exception<br>**softmax**: if true, will do softmax to result, or will return raw value<br>**fit**: image resize fit mode, default Fit.FIT_COVER, see image.Fit.<br> **throw** If error occurred, will raise err::Exception, you can find reason in log, mostly caused by args error or hardware error. **return** result, a list of (label, score). If in dual_buff mode, value can be one element list and score is zero when not ready. In C++, you need to delete it after use. **static** False > C++ defination code: > ```cpp > std::vector<std::pair<int, float>> *classify(image::Image &img, bool softmax true, image::Fit fit image::FIT_COVER) > ``` #### classify\\_raw ```python def classify_raw(self, data: maix.tensor.Tensor, softmax: bool True) > list[tuple[int, float]] ``` Forward tensor data to model, get result item description **type** func **param** **data**: tensor data, format should match model input_type， or will raise err.Excetion<br>**softmax**: if true, will do softmax to result, or will return raw value<br> **throw** If error occurred, will raise err::Exception, you can find reason in log, mostly caused by args error or hardware error. **return** result, a list of (label, score). In C++, you need to delete it after use. **static** False > C++ defination code: > ```cpp > std::vector<std::pair<int, float>> *classify_raw(tensor::Tensor &data, bool softmax true) > ``` #### input\\_size ```python def input_size(self) > maix.image.Size ``` Get model input size, only for image input item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width ```python def input_width(self) > int ``` Get model input width, only for image input item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height ```python def input_height(self) > int ``` Get model input height, only for image input item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format ```python def input_format(self) > maix.image.Format ``` Get input image format, only for image input item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### input\\_shape ```python def input_shape(self) > list[int] ``` Get input shape, if have multiple input, only return first input shape item description **type** func **return** input shape, list type **static** False > C++ defination code: > ```cpp > std::vector<int> input_shape() > ``` #### labels Labels list item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<string> labels > ``` #### label\\_path Label file path item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string label_path > ``` #### mean Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` ### Retinaface Retinaface class > C++ defination code: > ```cpp > class Retinaface > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, model: str '', dual_buff: bool True) > None ``` Constructor of Retinaface class item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br>**dual_buff**: direction [in], prepare dual input output buffer to accelarate forward, that is, when NPU is forwarding we not wait and prepare the next input buff.<br>If you want to ensure every time forward output the input's result, set this arg to false please.<br>Default true to ensure speed.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > Retinaface(const string &model \"\", bool dual_buff true) > ``` #### load ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### detect ```python def detect(self, img: maix.image.Image, conf_th: float 0.4, iou_th: float 0.45, fit: maix.image.Fit ...) > list[Object] ``` Detect objects from image item description **type** func **param** **img**: Image want to detect, if image's size not match model input's, will auto resize with fit method.<br>**conf_th**: Confidence threshold, default 0.4.<br>**iou_th**: IoU threshold, default 0.45.<br>**fit**: Resize method, default image.Fit.FIT_CONTAIN.<br> **throw** If image format not match model input format, will throw err::Exception. **return** Object list. In C++, you should delete it after use. **static** False > C++ defination code: > ```cpp > std::vector<nn::Object> *detect(image::Image &img, float conf_th 0.4, float iou_th 0.45, maix::image::Fit fit maix::image::FIT_CONTAIN) > ``` #### input\\_size ```python def input_size(self) > maix.image.Size ``` Get model input size item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width ```python def input_width(self) > int ``` Get model input width item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height ```python def input_height(self) > int ``` Get model input height item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format ```python def input_format(self) > maix.image.Format ``` Get input image format item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### mean Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` ### FaceDetector FaceDetector class > C++ defination code: > ```cpp > class FaceDetector > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, model: str '', dual_buff: bool True) > None ``` Constructor of FaceDetector class item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br>**dual_buff**: direction [in], prepare dual input output buffer to accelarate forward, that is, when NPU is forwarding we not wait and prepare the next input buff.<br>If you want to ensure every time forward output the input's result, set this arg to false please.<br>Default true to ensure speed.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > FaceDetector(const string &model \"\", bool dual_buff true) > ``` #### load ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### detect ```python def detect(self, img: maix.image.Image, conf_th: float 0.5, iou_th: float 0.45, fit: maix.image.Fit ...) > list[Object] ``` Detect objects from image item description **type** func **param** **img**: Image want to detect, if image's size not match model input's, will auto resize with fit method.<br>**conf_th**: Confidence threshold, default 0.5.<br>**iou_th**: IoU threshold, default 0.45.<br>**fit**: Resize method, default image.Fit.FIT_CONTAIN.<br> **throw** If image format not match model input format, will throw err::Exception. **return** Object list. In C++, you should delete it after use. **static** False > C++ defination code: > ```cpp > std::vector<nn::Object> *detect(image::Image &img, float conf_th 0.5, float iou_th 0.45, maix::image::Fit fit maix::image::FIT_CONTAIN) > ``` #### input\\_size ```python def input_size(self) > maix.image.Size ``` Get model input size item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width ```python def input_width(self) > int ``` Get model input width item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height ```python def input_height(self) > int ``` Get model input height item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format ```python def input_format(self) > maix.image.Format ``` Get input image format item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### mean Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` ### PP\\_OCR PP_OCR class > C++ defination code: > ```cpp > class PP_OCR > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, model: str '') > None ``` Constructor of PP_OCR class item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > PP_OCR(const string &model \"\") > ``` #### load ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### detect ```python def detect(self, img: maix.image.Image, thresh: float 0.3, box_thresh: float 0.6, fit: maix.image.Fit ..., char_box: bool False) > OCR_Objects ``` Detect objects from image item description **type** func **param** **img**: Image want to detect, if image's size not match model input's, will auto resize with fit method.<br>**thresh**: Confidence threshold where pixels have charactor, default 0.3.<br>**box_thresh**: Box threshold, the box prob higher than this value will be valid, default 0.6.<br>**fit**: Resize method, default image.Fit.FIT_CONTAIN.<br>**char_box**: Calculate every charactor's box, default false, if true then you can get charactor's box by nn.OCR_Object's char_boxes attribute.<br> **throw** If image format not match model input format or no memory, will throw err::Exception. **return** nn.OCR_Objects type. In C++, you should delete it after use. **static** False > C++ defination code: > ```cpp > nn::OCR_Objects *detect(image::Image &img, float thresh 0.3, float box_thresh 0.6, maix::image::Fit fit maix::image::FIT_CONTAIN, bool char_box false) > ``` #### recognize ```python def recognize(self, img: maix.image.Image, box_points: list[int] []) > OCR_Object ``` Only recognize, not detect item description **type** func **param** **img**: image to recognize chractors, can be a stanrd cropped charactors image,<br>if crop image not standard, you can use box_points to assgin where the charactors' 4 corner is.<br>**box_points**: list type, length must be 8 or 0, default empty means not transfer image to standard image.<br>4 points postiion, format: [x1, y1, x2, y2, x3, y3, x4, y4], point 1 at the left top, point 2 right top...<br>**char_box**: Calculate every charactor's box, default false, if true then you can get charactor's box by nn.OCR_Object's char_boxes attribute.<br> **static** False > C++ defination code: > ```cpp > nn::OCR_Object *recognize(image::Image &img, const std::vector<int> &box_points std::vector<int>()) > ``` #### draw\\_seg\\_mask ```python def draw_seg_mask(self, img: maix.image.Image, x: int, y: int, seg_mask: maix.image.Image, threshold: int 127) > None ``` Draw segmentation on image item description **type** func **param** **img**: image object, maix.image.Image type.<br>**seg_mask**: segmentation mask image by detect method, a grayscale image<br>**threshold**: only mask's value > threshold will be draw on image, value from 0 to 255.<br> **static** False > C++ defination code: > ```cpp > void draw_seg_mask(image::Image &img, int x, int y, image::Image &seg_mask, int threshold 127) > ``` #### input\\_size ```python def input_size(self) > maix.image.Size ``` Get model input size item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width ```python def input_width(self) > int ``` Get model input width item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height ```python def input_height(self) > int ``` Get model input height item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format ```python def input_format(self) > maix.image.Format ``` Get input image format item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### mean Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` #### rec\\_mean Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> rec_mean > ``` #### rec\\_scale Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> rec_scale > ``` #### labels labels (charactors) item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<std::string> labels > ``` #### det model have detect model item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool det > ``` #### rec model have recognize model item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool rec > ```"},"/maixpy/api/maix/http.html":{"title":"maix.http","content":" title: maix.http maix.http module > You can use `maix.http` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ## Function ## Class ### JpegStreamer JpegStreamer class > C++ defination code: > ```cpp > class JpegStreamer > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, host: str '', port: int 8000, client_number: int 16) > None ``` Construct a new jpeg streamer object item description **type** func **note** You can get the picture stream through http://host:port/stream, you can also get it through http://ip:port, and you can add personal style through set_html() at this time **param** **host**: http host<br>**port**: http port, default is 8000<br>**client_number**: the max number of client<br> **static** False > C++ defination code: > ```cpp > JpegStreamer(std::string host std::string(), int port 8000, int client_number 16) > ``` #### start ```python def start(self) > maix.err.Err ``` start jpeg streame item description **type** func **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err start() > ``` #### start (overload 1) stop http item description **type** func **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err stop() > ``` #### write ```python def write(self, img: maix.image.Image) > maix.err.Err ``` Write data to http item description **type** func **param** **img**: image object<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err write(image::Image *img) > ``` #### set\\_html ```python def set_html(self, data: str) > maix.err.Err ``` add your style in this api\\ndefault is:\\n<html>\\n<body>\\n<h1>JPG Stream</h1>\\n<img src '/stream'>\\n</body>\\n</html> item description **type** func **param** **data**: html code<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err set_html(std::string data) > ``` #### host ```python def host(self) > str ``` Get host item description **type** func **return** host name **static** False > C++ defination code: > ```cpp > std::string host() > ``` #### port ```python def port(self) > int ``` Get port item description **type** func **return** port **static** False > C++ defination code: > ```cpp > int port() > ```"},"/maixpy/api/maix/peripheral/pwm.html":{"title":"maix.peripheral.pwm","content":" title: maix.peripheral.pwm maix.peripheral.pwm module > You can use `maix.peripheral.pwm` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ## Function ## Class ### PWM Peripheral pwm class > C++ defination code: > ```cpp > class PWM > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, id: int, freq: int 1000, duty: float 0, enable: bool True, duty_val: int 1) > None ``` PWM constructor item description **type** func **param** **pin**: direction [in], pwm id, int type, like 0, 1, 2 etc.<br>**freq**: direction [in], pwm frequency, unit: Hz. int type. default is 1000<br>**duty**: direction [in], pwm duty. double type. range is [0, 100], default is 0.<br>**enable**: direction [in], enable pwm output right now. bool type. default is true, if false, you need to call enable() to enable pwm output.<br>**duty_val**: direction [in], pwm duty value, int type. default 1 means not set and auto calculate by freq and duty.<br>This arg directly set pwm duty value, if set, will ignore duty arg.<br>duty_val duty / 100 * T_ns, T_ns 1 / freq * 1000000000.<br> **throw** If args error or init pwm failed, will throw err::Exception **static** False > C++ defination code: > ```cpp > PWM(int id, int freq 1000, double duty 0, bool enable true, int duty_val 1) > ``` #### duty ```python def duty(self, duty: float 1) > float ``` get or set pwm duty item description **type** func **param** **duty**: direction [in], pwm duty, double type, value in [0, 100], default 1 means only read.<br> **return** current duty, float type, if set and set failed will return err::Err **static** False > C++ defination code: > ```cpp > double duty(double duty 1) > ``` #### duty\\_val ```python def duty_val(self, duty_val: int 1) > int ``` set pwm duty value item description **type** func **param** **duty_val**: direction [in], pwm duty value. int type. default is 1<br>duty_val > 0 means set duty_val<br>duty_val 1 or not set, return current duty_val<br> **return** int type<br>when get duty_val, return current duty_val, else return err::Err code. **static** False > C++ defination code: > ```cpp > int duty_val(int duty_val 1) > ``` #### freq ```python def freq(self, freq: int 1) > int ``` get or set pwm frequency item description **type** func **param** **freq**: direction [in], pwm frequency. int type. default is 1<br>freq > 0, set freq<br>freq 1 or not set, return current freq<br> **return** int type, current freq, if set and set failed will return err::Err **static** False > C++ defination code: > ```cpp > int freq(int freq 1) > ``` #### enable ```python def enable(self) > maix.err.Err ``` set pwm enable item description **type** func **return** err::Err type, err.Err.ERR_NONE means success **static** False > C++ defination code: > ```cpp > err::Err enable() > ``` #### disable ```python def disable(self) > maix.err.Err ``` set pwm disable item description **type** func **return** err::Err type, err.Err.ERR_NONE means success **static** False > C++ defination code: > ```cpp > err::Err disable() > ``` #### is\\_enabled ```python def is_enabled(self) > bool ``` get pwm enable status item description **type** func **return** bool type, true means enable, false means disable **static** False > C++ defination code: > ```cpp > bool is_enabled() > ```"},"/maixpy/api/maix/peripheral/wdt.html":{"title":"maix.peripheral.wdt","content":" title: maix.peripheral.wdt maix.peripheral.wdt module > You can use `maix.peripheral.wdt` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ## Function ## Class ### WDT Peripheral wdt class > C++ defination code: > ```cpp > class WDT > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, id: int, feed_ms: int) > None ``` WDT constructor, after construct, the wdt will auto start. item description **type** func **param** **id**: direction [in], id of wdt, int type<br>**feed_ms**: direction [in], feed interval, int type, unit is ms, you must feed wdt in this interval, or system will restart.<br> **static** False > C++ defination code: > ```cpp > WDT(int id, int feed_ms) > ``` #### feed ```python def feed(self) > int ``` feed wdt item description **type** func **return** error code, if feed success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > int feed() > ``` #### stop ```python def stop(self) > int ``` stop wdt item description **type** func **static** False > C++ defination code: > ```cpp > int stop() > ``` #### restart ```python def restart(self) > int ``` restart wdt, stop and start watchdog timer. item description **type** func **static** False > C++ defination code: > ```cpp > int restart() > ```"},"/maixpy/api/maix/peripheral/uart.html":{"title":"maix.peripheral.uart","content":" title: maix.peripheral.uart maix uart peripheral driver > You can use `maix.peripheral.uart` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ### PARITY uart parity enum item describe **values** **PARITY_NONE**: no parity<br>**PARITY_ODD**: odd parity<br>**PARITY_EVEN**: even parity<br>**PARITY_MAX**: <br> > C++ defination code: > ```cpp > enum PARITY > { > PARITY_NONE 0x00, // no parity > PARITY_ODD 0x01, // odd parity > PARITY_EVEN 0x02, // even parity > PARITY_MAX > } > ``` ### STOP uart stop bits item describe **values** **STOP_1**: 1 stop bit<br>**STOP_2**: 2 stop bits<br>**STOP_1_5**: 1.5 stop bits<br>**STOP_MAX**: <br> > C++ defination code: > ```cpp > enum STOP > { > STOP_1 0x01, // 1 stop bit > STOP_2 0x02, // 2 stop bits > STOP_1_5 0x03, // 1.5 stop bits > STOP_MAX > } > ``` ### BITS uart stop bits item describe **values** **BITS_5**: 5 data bits<br>**BITS_6**: 6 data bits<br>**BITS_7**: 7 data bits<br>**BITS_8**: 8 data bits<br>**BITS_MAX**: <br> > C++ defination code: > ```cpp > enum BITS > { > BITS_5 5, // 5 data bits > BITS_6 6, // 6 data bits > BITS_7 7, // 7 data bits > BITS_8 8, // 8 data bits > BITS_MAX > } > ``` ### FLOW\\_CTRL uart flow control item describe **values** **FLOW_CTRL_NONE**: no flow control<br>**FLOW_CTRL_HW**: hardware flow control<br>**FLOW_CTRL_MAX**: <br> > C++ defination code: > ```cpp > enum FLOW_CTRL > { > FLOW_CTRL_NONE 0, // no flow control > FLOW_CTRL_HW 1, // hardware flow control > FLOW_CTRL_MAX > } > ``` ## Variable ## Function ### list\\_devices ```python def list_devices() > list[str] ``` Get supported uart ports. item description **return** uart ports list, string type. > C++ defination code: > ```cpp > std::vector<std::string> list_devices() > ``` ## Class ### UART maix uart peripheral driver > C++ defination code: > ```cpp > class UART : public comm::CommBase > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, port: str '', baudrate: int 115200, databits: BITS ..., parity: PARITY ..., stopbits: STOP ..., flow_ctrl: FLOW_CTRL ...) > None ``` UART constructor. You need to call open() to open the device. item description **type** func **param** **port**: uart port. string type, can get it by uart.list_devices().<br>If empty, will not open device in constructor, default empty.<br>if not empty, will auto open device in constructor, open fail will throw err.Exception.<br>**baudrate**: baudrate of uart. int type, default 115200.<br>**databits**: databits, values @see uart.DATA_BITS<br>**parity**: parity, values @see uart.PARITY<br>**stopbits**: stopbits, values @see uart.STOP_BITS<br>**flow_control**: flow_control, values @see uart.FLOW_CTRL<br> **static** False > C++ defination code: > ```cpp > UART(const std::string &port \"\", int baudrate 115200, uart::BITS databits uart::BITS_8, > uart::PARITY parity uart::PARITY_NONE, uart::STOP stopbits uart::STOP_1, > uart::FLOW_CTRL flow_ctrl uart::FLOW_CTRL_NONE) > ``` #### set\\_port ```python def set_port(self, port: str) > maix.err.Err ``` Set port item description **type** func **param** **port**: uart port. string type, can get it by uart.list_devices().<br> **return** set port error code, err.Err type. **static** False > C++ defination code: > ```cpp > err::Err set_port(const std::string &port) > ``` #### get\\_port ```python def get_port(self) > str ``` Get port item description **type** func **return** uart port, string type. **static** False > C++ defination code: > ```cpp > std::string get_port() > ``` #### set\\_baudrate ```python def set_baudrate(self, baudrate: int) > maix.err.Err ``` Set baud rate item description **type** func **param** **baudrate**: baudrate of uart. int type, default 115200.<br> **return** set baud rate error code, err.Err type. **static** False > C++ defination code: > ```cpp > err::Err set_baudrate(int baudrate) > ``` #### get\\_baudrate ```python def get_baudrate(self) > int ``` Get baud rate item description **type** func **return** baud rate, int type. **static** False > C++ defination code: > ```cpp > int get_baudrate() > ``` #### open ```python def open(self) > maix.err.Err ``` Open uart device, before open, port must be set in constructor or by set_port().\\nIf already opened, do nothing and return err.ERR_NONE. item description **type** func **return** open device error code, err.Err type. **static** False > C++ defination code: > ```cpp > err::Err open() > ``` #### is\\_open ```python def is_open(self) > bool ``` Check if device is opened. item description **type** func **return** true if opened, false if not opened. **static** False > C++ defination code: > ```cpp > bool is_open() > ``` #### close ```python def close(self) > maix.err.Err ``` Close uart device, if already closed, do nothing and return err.ERR_NONE. item description **type** func **return** close device error code, err.Err type. **static** False > C++ defination code: > ```cpp > err::Err close() > ``` #### set\\_received\\_callback ```python def set_received_callback(self, callback: typing.Callable[[UART, maix.Bytes(bytes)], None]) > None ``` Set received callback function item description **type** func **param** **callback**: function to call when received data<br> **static** False > C++ defination code: > ```cpp > void set_received_callback(std::function<void(uart::UART&, Bytes&)> callback) > ``` #### write\\_str ```python def write_str(self, str: str) > int ``` Send string data item description **type** func **param** **str**: string data<br> **return** sent data length, < 0 means error, value is err.Err. **static** False > C++ defination code: > ```cpp > int write_str(const std::string &str) > ``` #### write ```python def write(self, data: maix.Bytes(bytes)) > int ``` Send data to uart item description **type** func **param** **data**: direction [in], data to send, bytes type. If you want to send str type, use str.encode() to convert.<br> **return** sent length, int type, if < 0 means error, value is err.Err. **static** False > C++ defination code: > ```cpp > int write(Bytes &data) > ``` #### available ```python def available(self, timeout: int 0) > int ``` Check if data available or wait data available. item description **type** func **param** **timeout**: unit ms, timeout to wait data, default 0.<br>0 means check data available and return immediately,<br>> 0 means wait until data available or timeout.<br> 1 means wait until data available.<br> **return** available data number, 0 if timeout or no data, <0 if error, value is err.Err, can be err::ERR_IO， err::ERR_CANCEL, err::ERR_NOT_OPEN. **throw** err.Exception if fatal error. **static** False > C++ defination code: > ```cpp > int available(int timeout 0) > ``` #### read ```python def read(*args, **kwargs) ``` Recv data from uart item description **type** func **param** **len**: max data length want to receive, default 1.<br> 1 means read data in uart receive buffer.<br>>0 means read len data want to receive.<br>other values is invalid.<br>**timeout**: unit ms, timeout to receive data, default 0.<br>0 means read data in uart receive buffer and return immediately,<br> 1 means block until read len data,<br>>0 means block until read len data or timeout.<br> **return** received data, bytes type.<br>Attention, you need to delete the returned object yourself in C++. **throw** Read failed will raise err.Exception error. **static** False > C++ defination code: > ```cpp > Bytes *read(int len 1, int timeout 0) > ``` #### readline ```python def readline(*args, **kwargs) ``` Read line from uart, that is read until '\\n' or '\\r\\n'. item description **type** func **param** **timeout**: unit ms, timeout to receive data, default 1 means block until read '\\n' or '\\r\\n'.<br>> 0 means block until read '\\n' or '\\r\\n' or timeout.<br> **return** received data, bytes type. If timeout will return the current received data despite not read '\\n' or '\\r\\n'.<br>e.g. If we want to read b'123\\n', but when we only read b'12', timeout, then return b'12'. **static** False > C++ defination code: > ```cpp > Bytes *readline(int timeout 1) > ```"},"/maixpy/api/maix/peripheral/adc.html":{"title":"maix.peripheral.adc","content":" title: maix.peripheral.adc maix.peripheral.adc module > You can use `maix.peripheral.adc` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ### RES\\_BIT\\_8 8 bit resolution, supported by the actual hardware item description **value** **8** **readonly** True > C++ defination code: > ```cpp > const int RES_BIT_8 8 > ``` ### RES\\_BIT\\_10 10 bit resolution, supported by the actual hardware item description **value** **10** **readonly** True > C++ defination code: > ```cpp > const int RES_BIT_10 10 > ``` ### RES\\_BIT\\_12 12 bit resolution, supported by the actual hardware item description **value** **12** **readonly** True > C++ defination code: > ```cpp > const int RES_BIT_12 12 > ``` ### RES\\_BIT\\_16 16 bit resolution, supported by the actual hardware item description **value** **16** **readonly** True > C++ defination code: > ```cpp > const int RES_BIT_16 16 > ``` ## Function ## Class ### ADC Peripheral adc class > C++ defination code: > ```cpp > class ADC > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, pin: int, resolution: int, vref: float 1) > None ``` ADC constructor item description **type** func **param** **pin**: direction [in], adc pin, int type<br>**resolution**: direction [in], adc resolution. default is 1, means use default resolution<br>option:<br>resolution adc.RES_BIT_8, means 8 bit resolution<br>resolution adc.RES_BIT_10, means 10 bit resolution<br>resolution adc.RES_BIT_12, means 12 bit resolution<br>resolution adc.RES_BIT_16, means 16 bit resolution<br>the default resolution is determined by actual hardware.<br>**vref**: direction [in], adc refer voltage. default is 1, means use default refer voltage.<br>the default vref is determined by actual hardware. range: [0.0, 10.0]<br> **static** False > C++ defination code: > ```cpp > ADC(int pin, int resolution, float vref 1) > ``` #### read ```python def read(self) > int ``` read adc value item description **type** func **return** adc data, int type<br>if resolution is 8 bit, return value range is [0, 255]<br>if resolution is 10 bit, return value range is [0, 1023]<br>if resolution is 12 bit, return value range is [0, 4095]<br>if resolution is 16 bit, return value range is [0, 65535] **static** False > C++ defination code: > ```cpp > int read() > ``` #### read\\_vol ```python def read_vol(self) > float ``` read adc voltage item description **type** func **return** adc voltage, float type。the range is [0.0, vref] **static** False > C++ defination code: > ```cpp > float read_vol() > ```"},"/maixpy/api/maix/peripheral/hid.html":{"title":"maix.peripheral.hid","content":" title: maix.peripheral.hid maix.peripheral.hid module > You can use `maix.peripheral.hid` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ### DeviceType Device enum of hid item describe **values** **DEVICE_MOUSE**: <br>**DEVICE_KEYBOARD**: <br>**DEVICE_TOUCHPAD**: <br> > C++ defination code: > ```cpp > enum DeviceType { > DEVICE_MOUSE 0, > DEVICE_KEYBOARD, > DEVICE_TOUCHPAD > } > ``` ## Variable ## Function ## Class ### Hid Hid class > C++ defination code: > ```cpp > class Hid > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, device_type: DeviceType, open: bool True) > None ``` Hid Device constructor item description **type** func **param** **device_type**: Device type, used to select mouse, keyboard, or touchpad.<br>**open**: auto open device in constructor, if false, you need call open() to open device<br> **static** False > C++ defination code: > ```cpp > Hid(hid::DeviceType device_type, bool open true) > ``` #### open ```python def open(self) > maix.err.Err ``` Open hid device item description **type** func **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err open() > ``` #### close ```python def close(self) > maix.err.Err ``` Close hid device item description **type** func **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err close() > ``` #### write ```python def write(self, data: list[int]) > maix.err.Err ``` Write data to hid device item description **type** func **param** **data**: data to write<br>For the keyboard, 8 bytes of data need to be written, with the format as follows:<br>data [0x00, #<br>0x00, #<br>0x00, # Key value. Refer to the \"Universal Serial Bus HID Usage Tables\" section of the official documentation(https://www.usb.org).<br>0x00, #<br>0x00, #<br>0x00, #<br>0x00, #<br>0x00] #<br>For the mouse, 4 bytes of data need to be written, with the format as follows:<br>data [0x00, # Button state<br>0x00: no button pressed<br>0x01: press left button<br>0x02: press right button<br>0x04: press middle button<br>x, # X axis relative coordinates. Signed number, positive values for x indicate movement to the right<br>y, # Y axis relative coordinates. Signed number, positive values for y indicate movement downward<br>0x00] # Wheel movement. Signed number, positive values indicate downward movement.<br>For the touchpad, 6 bytes of data need to be written, with the format as follows:<br>data [0x00, # Button state (0: no button pressed, 0x01: press left button, 0x10, press right button.)<br>x & 0xFF, (x >> 8) & 0xFF, # X axis absolute coordinate, 0 means unused.<br>Note: You must map the target position to the range [0x1, 0x7FFF]. This means x value <position_to_move> * 0x7FFF / <actual_screen_width><br>y & 0xFF, (y >> 8) & 0xFF, # Y axis absolute coordinate, 0 means unused.<br>Note: You must map the target position to the range [0x1, 0x7FFF]. This means y value <position_to_move> * 0x7FFF / <actual_screen_height><br>0x00, # Wheel movement. Signed number, positive values indicate downward movement.<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err write(std::vector<int> &data) > ``` #### is\\_opened ```python def is_opened(self) > bool ``` Check if hid device is opened item description **type** func **return** bool **static** False > C++ defination code: > ```cpp > bool is_opened() > ```"},"/maixpy/api/maix/peripheral/gpio.html":{"title":"maix.peripheral.gpio","content":" title: maix.peripheral.gpio maix.peripheral.gpio module > You can use `maix.peripheral.gpio` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ### Mode GPIO mode item describe **values** **IN**: input mode<br>**OUT**: output mode<br>**OUT_OD**: output open drain mode<br>**MODE_MAX**: <br> > C++ defination code: > ```cpp > enum Mode > { > IN 0x01, // input mode > OUT 0x02, // output mode > OUT_OD 0x03, // output open drain mode > MODE_MAX > } > ``` ### Pull GPIO pull mode item describe **values** **PULL_NONE**: pull none mode<br>**PULL_UP**: pull up mode<br>**PULL_DOWN**: pull down mode<br>**PULL_MAX**: <br> > C++ defination code: > ```cpp > enum Pull > { > PULL_NONE 0x00, // pull none mode > PULL_UP 0x01, // pull up mode > PULL_DOWN 0x02, // pull down mode > PULL_MAX > } > ``` ## Variable ## Function ## Class ### GPIO Peripheral gpio class > C++ defination code: > ```cpp > class GPIO > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, pin: str, mode: Mode ..., pull: Pull ...) > None ``` GPIO constructor item description **type** func **param** **pin**: direction [in], gpio pin name, string type the same as board's pin name, e.g. \"B14\" or \"GPIOB14\", or number string like \"10\" if board no gpiochipe name.<br>**mode**: direction [in], gpio mode. gpio.Mode type, default is gpio.Mode.IN (input) mode.<br>**pull**: direction [in], gpio pull. gpio.Pull type, default is gpio.Pull.PULL_NONE (pull none) mode.<br>For input mode, this will set gpio default status(value), if set to gpio.Pull.PULL_NONE, gpio value will be floating.<br>For output mode, this will set gpio default status(value), if set to gpio.Pull.PULL_UP, gpio value will be 1, else 0.<br> **throw** err::Exception if open gpio device failed. **static** False > C++ defination code: > ```cpp > GPIO(std::string pin, gpio::Mode mode gpio::Mode::IN, gpio::Pull pull gpio::Pull::PULL_NONE) > ``` #### value ```python def value(self, value: int 1) > int ``` set and get gpio value item description **type** func **param** **value**: direction [in], gpio value. int type.<br>0, means write gpio to low level<br>1, means write gpio to high level<br> 1, means read gpio value, not set<br> **return** int type, return gpio value, can be 0 or 1 **static** False > C++ defination code: > ```cpp > int value(int value 1) > ``` #### high ```python def high(self) > None ``` set gpio high (value to 1) item description **type** func **static** False > C++ defination code: > ```cpp > void high() > ``` #### low ```python def low(self) > None ``` set gpio low (value to 0) item description **type** func **static** False > C++ defination code: > ```cpp > void low() > ``` #### toggle ```python def toggle(self) > None ``` gpio toggle item description **type** func **static** False > C++ defination code: > ```cpp > void toggle() > ``` #### get\\_mode ```python def get_mode(self) > Mode ``` gpio get mode item description **type** func **static** False > C++ defination code: > ```cpp > gpio::Mode get_mode() > ``` #### get\\_pull ```python def get_pull(self) > Pull ``` get gpio pull item description **type** func **return** gpio::Pull type **static** False > C++ defination code: > ```cpp > gpio::Pull get_pull() > ``` #### reset ```python def reset(self, mode: Mode, pull: Pull) > maix.err.Err ``` reset gpio item description **type** func **param** **mode**: direction [in], gpio mode. gpio.Mode type<br>**pull**: direction [in], gpio pull. gpio.Pull type<br>For input mode, this will set gpio default status(value), if set to gpio.Pull.PULL_NONE, gpio value will be floating.<br>For output mode, this will set gpio default status(value), if set to gpio.Pull.PULL_UP, gpio value will be 1, else 0.<br> **return** err::Err type **static** False > C++ defination code: > ```cpp > err::Err reset(gpio::Mode mode, gpio::Pull pull) > ```"},"/maixpy/api/maix/peripheral/spi.html":{"title":"maix.peripheral.spi","content":" title: maix.peripheral.spi maix.peripheral.spi module > You can use `maix.peripheral.spi` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ### Mode SPI mode enum item describe **values** **MASTER**: spi master mode<br>**SLAVE**: spi slave mode<br> > C++ defination code: > ```cpp > enum Mode > { > MASTER 0x0, // spi master mode > SLAVE 0x1, // spi slave mode > } > ``` ## Variable ## Function ## Class ### SPI Peripheral spi class > C++ defination code: > ```cpp > class SPI > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, id: int, mode: Mode, freq: int, polarity: int 0, phase: int 0, bits: int 8, cs_enable: int 0, soft_cs: bool False, cs: str 'GPIOA19') > None ``` SPI constructor item description **type** func **param** **id**: direction [in], spi bus id, int type<br>**mode**: direction [in], mode of spi, spi.Mode type, spi.Mode.MASTER or spi.Mode.SLAVE.<br>**freq**: direction [in], freq of spi, int type<br>**polarity**: direction [in], polarity of spi, 0 means idle level of clock is low, 1 means high, int type, default is 0.<br>**phase**: direction [in], phase of spi, 0 means data is captured on the first edge of the SPI clock cycle, 1 means second, int type, default is 0.<br>**bits**: direction [in], bits of spi, int type, default is 8.<br>**cs_enable**: direction [in], cs pin active level, default is 0(low)<br>**soft_cs**: direction [in], not use hardware cs, bool type, if set true, you can operate cs pin use gpio manually.<br>**cs**: direction [in], soft cs pin number, std::string type, default is \"GPIOA19\", if SPI support multi hardware cs, you can set it to other value.<br> **static** False > C++ defination code: > ```cpp > SPI(int id, spi::Mode mode, int freq, int polarity 0, int phase 0, > int bits 8, unsigned char cs_enable 0, bool soft_cs false, std::string cs \"GPIOA19\") > ``` #### read ```python def read(*args, **kwargs) ``` read data from spi item description **type** func **param** **length**: direction [in], read length, int type<br> **return** bytes data, Bytes type in C++, bytes type in MaixPy. You need to delete it manually after use in C++. **static** False > C++ defination code: > ```cpp > Bytes *read(int length) > ``` #### write ```python def write(self, data: maix.Bytes(bytes)) > int ``` write data to spi item description **type** func **param** **data**: direction [in], data to write, Bytes type in C++, bytes type in MaixPy<br> **return** write length, int type, if write failed, return err::Err code. **static** False > C++ defination code: > ```cpp > int write(Bytes *data) > ``` #### write\\_read ```python def write_read(*args, **kwargs) ``` write data to spi and read data from spi at the same time. item description **type** func **param** **data**: direction [in], data to write, Bytes type in C++, bytes type in MaixPy<br>**read_len**: direction [in], read length, int type, should > 0.<br> **return** read data, Bytes type in C++, bytes type in MaixPy. You need to delete it manually after use in C++. **static** False > C++ defination code: > ```cpp > Bytes *write_read(Bytes *data, int read_len) > ``` #### is\\_busy ```python def is_busy(self) > bool ``` get busy status of spi item description **type** func **return** busy status, bool type **static** False > C++ defination code: > ```cpp > bool is_busy() > ```"},"/maixpy/api/maix/peripheral/timer.html":{"title":"maix.peripheral.timer","content":" title: maix.peripheral.timer maix.peripheral.timer module > You can use `maix.peripheral.timer` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ## Function ## Class ### TIMER Peripheral timer class > C++ defination code: > ```cpp > class TIMER > ``` #### \\_\\_init\\_\\_ ```python def __init__(self) > None ``` TIMER constructor item description **type** func **static** False > C++ defination code: > ```cpp > TIMER() > ```"},"/maixpy/api/maix/peripheral/i2c.html":{"title":"maix.peripheral.i2c","content":" title: maix.peripheral.i2c maix.peripheral.i2c module > You can use `maix.peripheral.i2c` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ### AddrSize Address size enum item describe **values** **SEVEN_BIT**: 7 bit address mode<br>**TEN_BIT**: 10 bit address mode<br> > C++ defination code: > ```cpp > enum AddrSize > { > SEVEN_BIT 7, // 7 bit address mode > TEN_BIT 10 // 10 bit address mode > } > ``` ### Mode I2C mode enum item describe **values** **MASTER**: master mode<br>**SLAVE**: slave mode<br> > C++ defination code: > ```cpp > enum Mode > { > MASTER 0x00, // master mode > SLAVE 0x01 // slave mode > } > ``` ## Variable ## Function ### list\\_devices ```python def list_devices() > list[int] ``` Get supported i2c bus devices. item description **return** i2c bus devices list, int type, is the i2c bus id. > C++ defination code: > ```cpp > std::vector<int> list_devices() > ``` ## Class ### I2C Peripheral i2c class > C++ defination code: > ```cpp > class I2C > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, id: int, mode: Mode, freq: int 100000, addr_size: AddrSize ...) > None ``` I2C Device constructor\\nthis constructor will be export to MaixPy as _maix.example.Example.__init__ item description **type** func **param** **id**: direction [in], i2c bus id, int type, e.g. 0, 1, 2<br>**freq**: direction [in], i2c clock, int type, default is 100000(100kbit/s), will auto set fast mode if freq > 100000.<br>**mode**: direction [in], mode of i2c, i2c.Mode.SLAVE or i2c.Mode.MASTER.<br>**addr_size**: direction [in], address length of i2c, i2c.AddrSize.SEVEN_BIT or i2c.AddrSize.TEN_BIT.<br> **throw** err::Exception if open i2c device failed. **static** False > C++ defination code: > ```cpp > I2C(int id, i2c::Mode mode, int freq 100000, i2c::AddrSize addr_size i2c::AddrSize::SEVEN_BIT) > ``` #### scan ```python def scan(self, addr: int 1) > list[int] ``` scan all i2c salve address on the bus item description **type** func **param** **addr**: If 1, only scan this addr, or scan from 0x08~0x77, default 1.<br> **return** the list of i2c slave address, int list type. **static** False > C++ defination code: > ```cpp > std::vector<int> scan(int addr 1) > ``` #### writeto ```python def writeto(self, addr: int, data: maix.Bytes(bytes)) > int ``` write data to i2c slave item description **type** func **param** **addr**: direction [in], i2c slave address, int type<br>**data**: direction [in], data to write, bytes type.<br>Note: The range of value should be in [0,255].<br> **return** if success, return the length of written data, error occurred will return err::Err. **static** False > C++ defination code: > ```cpp > int writeto(int addr, const Bytes &data) > ``` #### readfrom ```python def readfrom(*args, **kwargs) ``` read data from i2c slave item description **type** func **param** **addr**: direction [in], i2c slave address, int type<br>**len**: direction [in], data length to read, int type<br> **return** the list of data read from i2c slave, bytes type, you should delete it after use in C++.<br>If read failed, return nullptr in C++, None in MaixPy. **static** False > C++ defination code: > ```cpp > Bytes* readfrom(int addr, int len) > ``` #### writeto\\_mem ```python def writeto_mem(self, addr: int, mem_addr: int, data: maix.Bytes(bytes), mem_addr_size: int 8, mem_addr_le: bool False) > int ``` write data to i2c slave's memory address item description **type** func **param** **addr**: direction [in], i2c slave address, int type<br>**mem_addr**: direction [in], memory address want to write, int type.<br>**data**: direction [in], data to write, bytes type.<br>**mem_addr_size**: direction [in], memory address size, default is 8.<br>**mem_addr_le**: direction [in], memory address little endian, default is false, that is send high byte first.<br> **return** data length written if success, error occurred will return err::Err. **static** False > C++ defination code: > ```cpp > int writeto_mem(int addr, int mem_addr, const Bytes &data, int mem_addr_size 8, bool mem_addr_le false) > ``` #### readfrom\\_mem ```python def readfrom_mem(*args, **kwargs) ``` read data from i2c slave item description **type** func **param** **addr**: direction [in], i2c slave address, int type<br>**mem_addr**: direction [in], memory address want to read, int type.<br>**len**: direction [in], data length to read, int type<br>**mem_addr_size**: direction [in], memory address size, default is 8.<br>**mem_addr_le**: direction [in], memory address little endian, default is false, that is send high byte first.<br> **return** the list of data read from i2c slave, bytes type, you should delete it after use in C++.<br>If read failed, return nullptr in C++, None in MaixPy. **static** False > C++ defination code: > ```cpp > Bytes* readfrom_mem(int addr, int mem_addr, int len, int mem_addr_size 8, bool mem_addr_le false) > ```"},"/maixpy/api/maix/peripheral/key.html":{"title":"maix.peripheral.key","content":" title: maix.peripheral.key maix.peripheral.key module > You can use `maix.peripheral.key` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ### Keys Keys enum, id the same as linux input.h(input event codes.h) item describe **values** **KEY_NONE**: <br>**KEY_ESC**: <br>**KEY_OK**: <br>**KEY_OPTION**: <br>**KEY_NEXT**: <br>**KEY_PREV**: <br> > C++ defination code: > ```cpp > enum Keys{ > KEY_NONE 0x000, > KEY_ESC 0x001, > KEY_OK 0x160, > KEY_OPTION 0x165, > KEY_NEXT 0x197, > KEY_PREV 0x19c > } > ``` ### State Key state enum item describe **values** **KEY_RELEASED**: <br>**KEY_PRESSED**: <br> > C++ defination code: > ```cpp > enum State{ > KEY_RELEASED 0, > KEY_PRESSED 1, > } > ``` ## Variable ## Function ### add\\_default\\_listener Add default listener, if you want to exit app when press ok button, you can just call this function.\\nThis function is auto called in MaixPy' startup code, so you don't need to call it in MaixPy.\\nCreate Key object will auto call rm_default_listener() to cancel the default ok button function.\\nWhen ok button pressed, a SIGINT signal will be raise and call app.set_exit_flag(True). > C++ defination code: > ```cpp > void add_default_listener() > ``` ### rm\\_default\\_listener Remove default listener, if you want to cancel the default ok button function(exit app), you can just call this function. > C++ defination code: > ```cpp > void rm_default_listener() > ``` ## Class ### Key Key input class > C++ defination code: > ```cpp > class Key > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, callback: typing.Callable[[int, int], None] None, open: bool True) > None ``` Key Device constructor item description **type** func **param** **callback**: When key triggered and callback is not empty(empty In MaixPy is None, in C++ is nullptr),<br>callback will be called with args key(key.Keys) and value(key.State).<br>If set to null, you can get key value by read() function.<br>This callback called in a standalone thread, so you can block a while in callback, and you should be carefully when operate shared data.<br>**open**: auto open device in constructor, if false, you need call open() to open device<br> **static** False > C++ defination code: > ```cpp > Key(std::function<void(int, int)> callback nullptr, bool open true) > ``` #### open ```python def open(self) > maix.err.Err ``` Open(Initialize) key device, if already opened, will close first and then open. item description **type** func **return** err::Err type, err.Err.ERR_NONE means success **static** False > C++ defination code: > ```cpp > err::Err open() > ``` #### close ```python def close(self) > maix.err.Err ``` Close key device item description **type** func **return** err::Err type, err.Err.ERR_NONE means success **static** False > C++ defination code: > ```cpp > err::Err close() > ``` #### is\\_opened ```python def is_opened(self) > bool ``` Check key device is opened item description **type** func **return** bool type, true means opened, false means closed **static** False > C++ defination code: > ```cpp > bool is_opened() > ``` #### read ```python def read(self) > tuple[int, int] ``` Read key input, and return key and value, if callback is set, DO NOT call this function manually. item description **type** func **return** list type, first is key(maix.key.Keys), second is value(maix.key.State), if no key input, return [0, 0] **throw** If read failed, will throw maix.err.Exception. **static** False > C++ defination code: > ```cpp > std::pair<int, int> read() > ```"},"/maixpy/api/maix/audio.html":{"title":"maix.audio","content":" title: maix.audio maix.audio module > You can use `maix.audio` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ### Format Audio type item describe **values** **FMT_NONE**: format invalid<br>**FMT_S8**: unsigned 8 bits<br>**FMT_S16_LE**: signed 16 bits, little endian<br>**FMT_S32_LE**: signed 32 bits, little endian<br>**FMT_S16_BE**: signed 16 bits, big endian<br>**FMT_S32_BE**: signed 32 bits, big endian<br>**FMT_U8**: unsigned 8 bits<br>**FMT_U16_LE**: unsigned 16 bits, little endian<br>**FMT_U32_LE**: unsigned 32 bits, little endian<br>**FMT_U16_BE**: unsigned 16 bits, big endian<br>**FMT_U32_BE**: unsigned 32 bits, big endian<br> > C++ defination code: > ```cpp > enum Format > { > FMT_NONE 0, // format invalid > FMT_S8, // unsigned 8 bits > FMT_S16_LE, // signed 16 bits, little endian > FMT_S32_LE, // signed 32 bits, little endian > FMT_S16_BE, // signed 16 bits, big endian > FMT_S32_BE, // signed 32 bits, big endian > FMT_U8, // unsigned 8 bits > FMT_U16_LE, // unsigned 16 bits, little endian > FMT_U32_LE, // unsigned 32 bits, little endian > FMT_U16_BE, // unsigned 16 bits, big endian > FMT_U32_BE, // unsigned 32 bits, big endian > } > ``` ## Variable ## Function ## Class ### Recorder Recorder class > C++ defination code: > ```cpp > class Recorder > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, path: str '', sample_rate: int 48000, format: Format ..., channel: int 1) > None ``` Construct a new Recorder object. currectly only pcm and wav formats supported. item description **type** func **param** **path**: record path. the path determines the location where you save the file, if path is none, the audio module will not save file.<br>**sample_rate**: record sample rate, default is 48000(48KHz), means 48000 samples per second.<br>**format**: record sample format, default is audio::Format::FMT_S16_LE, means sampling 16 bits at a time and save as signed 16 bits, little endian. see @audio::Format<br>**channel**: record sample channel, default is 1, means 1 channel sampling at the same time<br> **static** False > C++ defination code: > ```cpp > Recorder(std::string path std::string(), int sample_rate 48000, audio::Format format audio::Format::FMT_S16_LE, int channel 1) > ``` #### volume ```python def volume(self, value: int 1) > int ``` Set/Get record volume item description **type** func **param** **value**: volume value, If you use this parameter, audio will set the value to volume,<br>if you don't, it will return the current volume. range is [0, 100].<br> **return** the current volume **static** False > C++ defination code: > ```cpp > int volume(int value 1) > ``` #### mute ```python def mute(self, data: int 1) > bool ``` Mute item description **type** func **param** **data**: mute data, If you set this parameter to true, audio will set the value to mute,<br>if you don't, it will return the current mute status.<br> **return** Returns whether mute is currently enabled. **static** False > C++ defination code: > ```cpp > bool mute(int data 1) > ``` #### record ```python def record(*args, **kwargs) ``` Record, Read all cached data in buffer and return. If there is no audio data in the buffer, may return empty data. item description **type** func **param** **record_ms**: Block and record audio data lasting `record_ms` milliseconds and save it to a file, the return value does not return audio data. Only valid if the initialisation `path` is set.<br> **return** pcm data. datatype @see Bytes. If you pass in record_ms parameter, the return value is an empty Bytes object. **static** False > C++ defination code: > ```cpp > maix::Bytes *record(int record_ms 1) > ``` #### finish ```python def finish(self) > maix.err.Err ``` Finish the record, if you have passed in the path, this api will save the audio data to file. item description **type** func **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err finish() > ``` #### sample\\_rate ```python def sample_rate(self) > int ``` Get sample rate item description **type** func **return** returns sample rate **static** False > C++ defination code: > ```cpp > int sample_rate() > ``` #### format ```python def format(self) > Format ``` Get sample format item description **type** func **return** returns sample format **static** False > C++ defination code: > ```cpp > audio::Format format() > ``` #### channel ```python def channel(self) > int ``` Get sample channel item description **type** func **return** returns sample channel **static** False > C++ defination code: > ```cpp > int channel() > ``` ### Player Player class > C++ defination code: > ```cpp > class Player > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, path: str '', sample_rate: int 48000, format: Format ..., channel: int 1) > None ``` Construct a new Player object item description **type** func **param** **path**: player path. the path determines the location where you save the file, if path is none, the audio module will not save file.<br>**sample_rate**: player sample rate, default is 48000(48KHz), means 48000 samples per second.<br>**format**: player sample format, default is audio::Format::FMT_S16_LE, means sampling 16 bits at a time and save as signed 16 bits, little endian. see @audio::Format<br>**channel**: player sample channel, default is 1, means 1 channel sampling at the same time<br> **static** False > C++ defination code: > ```cpp > Player(std::string path std::string(), int sample_rate 48000, audio::Format format audio::Format::FMT_S16_LE, int channel 1) > ``` #### volume ```python def volume(self, value: int 1) > int ``` Set/Get player volume(Not support now) item description **type** func **param** **value**: volume value, If you use this parameter, audio will set the value to volume,<br>if you don't, it will return the current volume.<br> **return** the current volume **static** False > C++ defination code: > ```cpp > int volume(int value 1) > ``` #### play ```python def play(self, data: maix.Bytes(bytes) b'') > maix.err.Err ``` Play item description **type** func **param** **data**: audio data, must be raw data<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err play(maix::Bytes *data maix::audio::Player::NoneBytes) > ``` #### sample\\_rate ```python def sample_rate(self) > int ``` Get sample rate item description **type** func **return** returns sample rate **static** False > C++ defination code: > ```cpp > int sample_rate() > ``` #### format ```python def format(self) > Format ``` Get sample format item description **type** func **return** returns sample format **static** False > C++ defination code: > ```cpp > audio::Format format() > ``` #### channel ```python def channel(self) > int ``` Get sample channel item description **type** func **return** returns sample channel **static** False > C++ defination code: > ```cpp > int channel() > ```"},"/maixpy/api/maix/err.html":{"title":"maix.err","content":" title: maix.err maix.err module > You can use `maix.err` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ### Err Maix Error code item describe **values** **ERR_NONE**: No error<br>**ERR_ARGS**: Invalid arguments<br>**ERR_NO_MEM**: No memory<br>**ERR_NOT_IMPL**: Not implemented<br>**ERR_NOT_READY**: Not ready<br>**ERR_NOT_INIT**: Not initialized<br>**ERR_NOT_OPEN**: Not opened<br>**ERR_NOT_PERMIT**: Not permitted<br>**ERR_REOPEN**: Re open<br>**ERR_BUSY**: Busy<br>**ERR_READ**: Read error<br>**ERR_WRITE**: Write error<br>**ERR_TIMEOUT**: Timeout<br>**ERR_RUNTIME**: Runtime error<br>**ERR_IO**: IO error<br>**ERR_NOT_FOUND**: Not found<br>**ERR_ALREAY_EXIST**: Already exist<br>**ERR_BUFF_FULL**: Buffer full<br>**ERR_BUFF_EMPTY**: Buffer empty<br>**ERR_CANCEL**: Cancel<br>**ERR_OVERFLOW**: Overflow<br>**ERR_MAX**: <br> > C++ defination code: > ```cpp > enum Err > { > // !!! fixed error code, DO NOT change number already defined, only append new error code > ERR_NONE 0, // No error > ERR_ARGS , // Invalid arguments > ERR_NO_MEM , // No memory > ERR_NOT_IMPL , // Not implemented > ERR_NOT_READY , // Not ready > ERR_NOT_INIT , // Not initialized > ERR_NOT_OPEN , // Not opened > ERR_NOT_PERMIT , // Not permitted > ERR_REOPEN , // Re open > ERR_BUSY , // Busy > ERR_READ , // Read error > ERR_WRITE , // Write error > ERR_TIMEOUT , // Timeout > ERR_RUNTIME , // Runtime error > ERR_IO , // IO error > ERR_NOT_FOUND , // Not found > ERR_ALREAY_EXIST , // Already exist > ERR_BUFF_FULL , // Buffer full > ERR_BUFF_EMPTY , // Buffer empty > ERR_CANCEL , // Cancel > ERR_OVERFLOW , // Overflow > ERR_MAX, > } > ``` ## Variable ## Function ### to\\_str ```python def to_str(e: Err) > str ``` Error code to string item description **param** **e**: direction [in], error code, err::Err type<br> **return** error string > C++ defination code: > ```cpp > std::string to_str(err::Err e) > ``` ### get\\_error ```python def get_error() > str ``` get last error string item description **return** error string > C++ defination code: > ```cpp > std::string& get_error() > ``` ### set\\_error ```python def set_error(str: str) > None ``` set last error string item description **param** **str**: direction [in], error string<br> > C++ defination code: > ```cpp > void set_error(const std::string &str) > ``` ### check\\_raise ```python def check_raise(e: Err, msg: str '') > None ``` Check error code, if not ERR_NONE, raise err.Exception item description **param** **e**: direction [in], error code, err::Err type<br>**msg**: direction [in], error message<br> > C++ defination code: > ```cpp > void check_raise(err::Err e, const std::string &msg \"\") > ``` ### check\\_bool\\_raise ```python def check_bool_raise(ok: bool, msg: str '') > None ``` Check condition, if false, raise err.Exception item description **param** **ok**: direction [in], condition, if true, do nothing, if false, raise err.Exception<br>**msg**: direction [in], error message<br> > C++ defination code: > ```cpp > void check_bool_raise(bool ok, const std::string &msg \"\") > ``` ### check\\_null\\_raise ```python def check_null_raise(ptr: capsule, msg: str '') > None ``` Check NULL pointer, if NULL, raise exception item description **param** **ptr**: direction [in], pointer<br>**msg**: direction [in], error message<br> > C++ defination code: > ```cpp > void check_null_raise(void *ptr, const std::string &msg \"\") > ``` ## Class ### Exception Maix Exception > C++ defination code: > ```cpp > class Exception : public std::exception > ```"},"/maixpy/api/maix/fs.html":{"title":"maix.fs","content":" title: maix.fs maix.fs module > You can use `maix.fs` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ### SEEK SEEK enums item describe **values** **SEEK_SET**: Seek from beginning of file.<br>**SEEK_CUR**: Seek from current position.<br>**SEEK_END**: Seek from end of file.<br> > C++ defination code: > ```cpp > enum SEEK > { > SEEK_SET 0, // Seek from beginning of file. > SEEK_CUR 1, // Seek from current position. > SEEK_END 2, // Seek from end of file. > } > ``` ## Variable ## Function ### isabs ```python def isabs(path: str) > bool ``` Check if the path is absolute path item description **param** **path**: path to check<br> **return** true if path is absolute path > C++ defination code: > ```cpp > bool isabs(const std::string &path) > ``` ### isdir ```python def isdir(path: str) > bool ``` Check if the path is a directory, if not exist, throw exception item description **param** **path**: path to check<br> **return** true if path is a directory > C++ defination code: > ```cpp > bool isdir(const std::string &path) > ``` ### isfile ```python def isfile(path: str) > bool ``` Check if the path is a file, if not exist, throw exception item description **param** **path**: path to check<br> **return** true if path is a file > C++ defination code: > ```cpp > bool isfile(const std::string &path) > ``` ### islink ```python def islink(path: str) > bool ``` Check if the path is a link, if not exist, throw exception item description **param** **path**: path to check<br> **return** true if path is a link > C++ defination code: > ```cpp > bool islink(const std::string &path) > ``` ### symlink ```python def symlink(src: str, link: str, force: bool False) > maix.err.Err ``` Create soft link item description **param** **src**: real file path<br>**link**: link file path<br>**force**: force link, if already have link file, will delet it first then create.<br> > C++ defination code: > ```cpp > err::Err symlink(const std::string &src, const std::string &link, bool force false) > ``` ### exists ```python def exists(path: str) > bool ``` Check if the path exists item description **param** **path**: path to check<br> **return** true if path exists > C++ defination code: > ```cpp > bool exists(const std::string &path) > ``` ### mkdir ```python def mkdir(path: str, exist_ok: bool True, recursive: bool True) > maix.err.Err ``` Create a directory recursively item description **param** **path**: path to create<br>**exist_ok**: if true, also return true if directory already exists<br>**recursive**: if true, create directory recursively, otherwise, only create one directory, default is true<br> **return** err::ERR_NONE(err.Err.ERR_NONE in MaixPy) if success, other error code if failed > C++ defination code: > ```cpp > err::Err mkdir(const std::string &path, bool exist_ok true, bool recursive true) > ``` ### rmdir ```python def rmdir(path: str, recursive: bool False) > maix.err.Err ``` Remove a directory item description **param** **path**: path to remove<br>**recursive**: if true, remove directory recursively, otherwise, only remove empty directory, default is false<br> **return** err::ERR_NONE(err.Err.ERR_NONE in MaixPy) if success, other error code if failed > C++ defination code: > ```cpp > err::Err rmdir(const std::string &path, bool recursive false) > ``` ### remove ```python def remove(path: str) > maix.err.Err ``` Remove a file item description **param** **path**: path to remove<br> **return** err::ERR_NONE(err.Err.ERR_NONE in MaixPy) if success, other error code if failed > C++ defination code: > ```cpp > err::Err remove(const std::string &path) > ``` ### rename ```python def rename(src: str, dst: str) > maix.err.Err ``` Rename a file or directory item description **param** **src**: source path<br>**dst**: destination path, if destination dirs not exist, will auto create<br> **return** err::ERR_NONE(err.Err.ERR_NONE in MaixPy) if success, other error code if failed > C++ defination code: > ```cpp > err::Err rename(const std::string &src, const std::string &dst) > ``` ### sync ```python def sync() > None ``` Sync files, ensure they're wrriten to disk from RAM > C++ defination code: > ```cpp > void sync() > ``` ### getsize ```python def getsize(path: str) > int ``` Get file size item description **param** **path**: path to get size<br> **return** file size if success, err::Err code if failed > C++ defination code: > ```cpp > int getsize(const std::string &path) > ``` ### dirname ```python def dirname(path: str) > str ``` Get directory name of path item description **param** **path**: path to get dirname<br> **return** dirname if success, empty string if failed > C++ defination code: > ```cpp > std::string dirname(const std::string &path) > ``` ### basename ```python def basename(path: str) > str ``` Get base name of path item description **param** **path**: path to get basename<br> **return** basename if success, empty string if failed > C++ defination code: > ```cpp > std::string basename(const std::string &path) > ``` ### abspath ```python def abspath(path: str) > str ``` Get absolute path item description **param** **path**: path to get absolute path<br> **return** absolute path if success, empty string if failed > C++ defination code: > ```cpp > std::string abspath(const std::string &path) > ``` ### getcwd ```python def getcwd() > str ``` Get current working directory item description **return** current working directory absolute path > C++ defination code: > ```cpp > std::string getcwd() > ``` ### realpath ```python def realpath(path: str) > str ``` Get realpath of path item description **param** **path**: path to get realpath<br> **return** realpath if success, empty string if failed > C++ defination code: > ```cpp > std::string realpath(const std::string &path) > ``` ### splitext ```python def splitext(path: str) > list[str] ``` Get file extension item description **param** **path**: path to get extension<br> **return** prefix_path and extension list if success, empty string if failed > C++ defination code: > ```cpp > std::vector<std::string> splitext(const std::string &path) > ``` ### listdir ```python def listdir(path: str, recursive: bool False, full_path: bool False) > list[str] ``` List files in directory item description **param** **path**: path to list<br>**recursive**: if true, list recursively, otherwise, only list current directory, default is false<br>**full_path**: if true, return full path, otherwise, only return basename, default is false<br> **return** files list if success, nullptr if failed, you should manually delete it in C++. > C++ defination code: > ```cpp > std::vector<std::string> *listdir(const std::string &path, bool recursive false, bool full_path false) > ``` ### open ```python def open(path: str, mode: str) > File ``` Open a file, and return a File object item description **param** **path**: path to open<br>**mode**: open mode, support \"r\", \"w\", \"a\", \"r+\", \"w+\", \"a+\", \"rb\", \"wb\", \"ab\", \"rb+\", \"wb+\", \"ab+\"<br> **return** File object if success(need to delete object manually in C/C++), nullptr if failed > C++ defination code: > ```cpp > fs::File *open(const std::string &path, const std::string &mode) > ``` ### tempdir ```python def tempdir() > str ``` Get temp files directory item description **return** temp files directory > C++ defination code: > ```cpp > std::string tempdir() > ``` ## Class ### File File read write ops > C++ defination code: > ```cpp > class File > ``` #### \\_\\_init\\_\\_ ```python def __init__(self) > None ``` Construct File object item description **type** func **static** False > C++ defination code: > ```cpp > File() > ``` #### open ```python def open(self, path: str, mode: str) > maix.err.Err ``` Open a file item description **type** func **param** **path**: path to open<br>**mode**: open mode, support \"r\", \"w\", \"a\", \"r+\", \"w+\", \"a+\", \"rb\", \"wb\", \"ab\", \"rb+\", \"wb+\", \"ab+\"<br> **return** err::ERR_NONE(err.Err.ERR_NONE in MaixPy) if success, other error code if failed **static** False > C++ defination code: > ```cpp > err::Err open(const std::string &path, const std::string &mode) > ``` #### close ```python def close(self) > None ``` Close a file item description **type** func **static** False > C++ defination code: > ```cpp > void close() > ``` #### read ```python def read(self, size: int) > list[int] ``` Read data from file API2 item description **type** func **param** **size**: max read size<br> **return** bytes data if success(need delete manually in C/C++), nullptr if failed **static** False > C++ defination code: > ```cpp > std::vector<uint8_t> *read(int size) > ``` #### readline ```python def readline(self) > str ``` Read line from file item description **type** func **return** line if success, empty string if failed. You need to delete the returned object manually in C/C++. **static** False > C++ defination code: > ```cpp > std::string *readline() > ``` #### eof ```python def eof(self) > int ``` End of file or not item description **type** func **return** 0 if not reach end of file, else eof. **static** False > C++ defination code: > ```cpp > int eof() > ``` #### write ```python def write(self, buf: list[int]) > int ``` Write data to file API2 item description **type** func **param** **buf**: buffer to write<br> **return** write size if success, err::Err code if failed **static** False > C++ defination code: > ```cpp > int write(const std::vector<uint8_t> &buf) > ``` #### seek ```python def seek(self, offset: int, whence: int) > int ``` Seek file position item description **type** func **param** **offset**: offset to seek<br>**whence**: @see maix.fs.SEEK<br> **return** new position if success, err::Err code if failed **static** False > C++ defination code: > ```cpp > int seek(int offset, int whence) > ``` #### tell ```python def tell(self) > int ``` Get file position item description **type** func **return** file position if success, err::Err code if failed **static** False > C++ defination code: > ```cpp > int tell() > ``` #### flush ```python def flush(self) > maix.err.Err ``` Flush file item description **type** func **return** err::ERR_NONE(err.Err.ERR_NONE in MaixPy) if success, other error code if failed **static** False > C++ defination code: > ```cpp > err::Err flush() > ```"},"/maixpy/api/maix/network.html":{"title":"maix.network","content":" title: maix.network maix.network module > You can use `maix.network` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module module brief [wifi](./network/wifi.html) maix.network.wifi module ## Enum ## Variable ## Function ### have\\_network ```python def have_network() > bool ``` Return if device have network(WiFi/Eth etc.) item description **return** True if have network, else False. > C++ defination code: > ```cpp > bool have_network() > ``` ## Class"},"/maixpy/api/maix/thread.html":{"title":"maix.thread","content":" title: maix.thread maix.thread module > You can use `maix.thread` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ## Function ## Class ### Thread thread class > C++ defination code: > ```cpp > class Thread > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, func: typing.Callable[[capsule], None], args: capsule None) > None ``` create thread item description **type** func **param** **func**: direction [in], thread function, one `args` parameter, void* type, no return value<br>**args**: direction [in], thread function parameter<br> **static** False > C++ defination code: > ```cpp > Thread(std::function<void(void *)> func, void *args nullptr) > ``` #### join ```python def join(self) > None ``` wait thread exit item description **type** func **static** False > C++ defination code: > ```cpp > void join() > ``` #### detach ```python def detach(self) > None ``` detach thread, detach will auto start thread and you can't use join anymore. item description **type** func **static** False > C++ defination code: > ```cpp > void detach() > ``` #### joinable ```python def joinable(self) > bool ``` Check if thread is joinable item description **type** func **return** true if thread is joinable **static** False > C++ defination code: > ```cpp > bool joinable() > ```"},"/maixpy/api/maix/i18n.html":{"title":"maix.i18n","content":" title: maix.i18n maix.i18n module > You can use `maix.i18n` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ### locales i18n locales list item description **value** **{<br> \"en\",<br> \"zh\",<br> \"zh tw\",<br> \"ja\"}** **readonly** False > C++ defination code: > ```cpp > static std::vector<std::string> locales { > \"en\", > \"zh\", > \"zh tw\", > \"ja\"} > ``` ### names i18n language names list item description **value** **{<br> \"English\",<br> \"简体中文\",<br> \"繁體中文\",<br> \"日本語\"}** **readonly** True > C++ defination code: > ```cpp > const static std::vector<std::string> names { > \"English\", > \"简体中文\", > \"繁體中文\", > \"日本語\"} > ``` ## Function ### get\\_locale ```python def get_locale() > str ``` Get system config of locale. item description **return** language locale, e.g. en, zh, zh_CN, zh_TW, etc. > C++ defination code: > ```cpp > string get_locale() > ``` ### get\\_language\\_name ```python def get_language_name() > str ``` Get system config of language name. item description **return** language name, e.g. English, 简体中文, 繁體中文, etc. > C++ defination code: > ```cpp > string get_language_name() > ``` ### load\\_trans\\_yaml ```python def load_trans_yaml(locales_dir: str) > dict[str, dict[str, str]] ``` Load translations from yaml files. item description **param** **locales_dir**: translation yaml files directory.<br> **return** A dict contains all translations, e.g. {\"zh\":{\"hello\": \"你好\"}, \"en\":{\"hello\": \"hello\"}}, you should delete it after use in C++. > C++ defination code: > ```cpp > const std::map<string, std::map<string, string>> *load_trans_yaml(const std::string &locales_dir) > ``` ## Class ### Trans Translate helper class. > C++ defination code: > ```cpp > class Trans > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, locales_dict: dict[str, dict[str, str]] {}) > None ``` Translate helper class constructor.\\nBy default locale is get by `i18n.get_locale()` function which set by system settings.\\nBut you can also manually set by `set_locale` function temporarily. item description **type** func **param** **locales_dict**: locales dict, e.g. {\"zh\": {\"Confirm\": \"确认\", \"OK\": \"好的\"}, \"en\": {\"Confirm\": \"Confirm\", \"OK\": \"OK\"}}<br> **static** False > C++ defination code: > ```cpp > Trans(const std::map<string, const std::map<string, string>> &locales_dict std::map<string, const std::map<string, string>>()) > ``` #### load ```python def load(self, locales_dir: str) > maix.err.Err ``` Load translation from yaml files generated by `maixtool i18n` command. item description **type** func **param** **locales_dir**: the translation files directory.<br> **return** err.Err type, no error will return err.Err.ERR_NONE. **static** False > C++ defination code: > ```cpp > err::Err load(const std::string &locales_dir) > ``` #### update\\_dict ```python def update_dict(self, dict: dict[str, dict[str, str]]) > maix.err.Err ``` Update translation dict. item description **type** func **param** **dict**: the new translation dict.<br> **return** err.Err type, no error will return err.Err.ERR_NONE. **static** False > C++ defination code: > ```cpp > err::Err update_dict(const std::map<std::string, const std::map<std::string, std::string>> &dict) > ``` #### tr ```python def tr(self, key: str, locale: str '') > str ``` Translate string by key. item description **type** func **param** **key**: string key, e.g. \"Confirm\"<br>**locale**: locale name, if not assign, use default locale set by system settings or set_locale function.<br> **return** translated string, if find translation, return it, or return key, e.g. \"确认\", \"Confirm\", etc. **static** False > C++ defination code: > ```cpp > string tr(const string &key, const string locale \"\") > ``` #### set\\_locale ```python def set_locale(self, locale: str) > None ``` Set locale temporarily, will not affect system settings. item description **type** func **param** **locale**: locale name, e.g. \"zh\", \"en\", etc. @see maix.i18n.locales<br> **static** False > C++ defination code: > ```cpp > void set_locale(const string &locale) > ``` #### get\\_locale ```python def get_locale(self) > str ``` Get current locale. item description **type** func **return** locale name, e.g. \"zh\", \"en\", etc. @see maix.i18n.locales **static** False > C++ defination code: > ```cpp > string get_locale() > ```"},"/maixpy/api/maix/image.html":{"title":"maix.image","content":" title: maix.image maix.image module, image related definition and functions > You can use `maix.image` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ### Format Image formats item describe **attention** for MaixPy firmware developers, update this enum will also need to update the fmt_size and fmt_names too !!! **values** **FMT_RGB888**: RGBRGB...RGB, R at the lowest address<br>**FMT_BGR888**: BGRBGR...BGR, B at the lowest address<br>**FMT_RGBA8888**: RGBARGBA...RGBA, R at the lowest address<br>**FMT_BGRA8888**: BGRABGRA...BGRA, B at the lowest address<br>**FMT_RGB565**: <br>**FMT_BGR565**: <br>**FMT_YUV422SP**: YYY...UVUVUV...UVUV<br>**FMT_YUV422P**: YYY...UUU...VVV<br>**FMT_YVU420SP**: YYY...VUVUVU...VUVU, NV21<br>**FMT_YUV420SP**: YYY...UVUVUV...UVUV, NV12<br>**FMT_YVU420P**: YYY...VVV...UUU<br>**FMT_YUV420P**: YYY...UUU...VVV<br>**FMT_GRAYSCALE**: <br>**FMT_BGGR6**: 6 bit Bayer format with a BGGR pattern.<br>**FMT_GBRG6**: 6 bit Bayer format with a GBRG pattern.<br>**FMT_GRBG6**: 6 bit Bayer format with a GRBG pattern.<br>**FMT_RGGB6**: 6 bit Bayer format with a RGGB pattern.<br>**FMT_BGGR8**: 8 bit Bayer format with a BGGR pattern.<br>**FMT_GBRG8**: 8 bit Bayer format with a GBRG pattern.<br>**FMT_GRBG8**: 8 bit Bayer format with a GRBG pattern.<br>**FMT_RGGB8**: 8 bit Bayer format with a RGGB pattern.<br>**FMT_BGGR10**: 10 bit Bayer format with a BGGR pattern.<br>**FMT_GBRG10**: 10 bit Bayer format with a GBRG pattern.<br>**FMT_GRBG10**: 10 bit Bayer format with a GRBG pattern.<br>**FMT_RGGB10**: 10 bit Bayer format with a RGGB pattern.<br>**FMT_BGGR12**: 12 bit Bayer format with a BGGR pattern.<br>**FMT_GBRG12**: 12 bit Bayer format with a GBRG pattern.<br>**FMT_GRBG12**: 12 bit Bayer format with a GRBG pattern.<br>**FMT_RGGB12**: 12 bit Bayer format with a RGGB pattern.<br>**FMT_UNCOMPRESSED_MAX**: <br>**FMT_COMPRESSED_MIN**: <br>**FMT_JPEG**: <br>**FMT_PNG**: <br>**FMT_COMPRESSED_MAX**: <br>**FMT_INVALID**: format not valid<br> > C++ defination code: > ```cpp > enum Format > { > FMT_RGB888 0, // RGBRGB...RGB, R at the lowest address > FMT_BGR888, // BGRBGR...BGR, B at the lowest address > FMT_RGBA8888, // RGBARGBA...RGBA, R at the lowest address > FMT_BGRA8888, // BGRABGRA...BGRA, B at the lowest address > FMT_RGB565, > FMT_BGR565, > FMT_YUV422SP, // YYY...UVUVUV...UVUV > FMT_YUV422P, // YYY...UUU...VVV > FMT_YVU420SP, // YYY...VUVUVU...VUVU, NV21 > FMT_YUV420SP, // YYY...UVUVUV...UVUV, NV12 > FMT_YVU420P, // YYY...VVV...UUU > FMT_YUV420P, // YYY...UUU...VVV > FMT_GRAYSCALE, > FMT_BGGR6, // 6 bit Bayer format with a BGGR pattern. > FMT_GBRG6, // 6 bit Bayer format with a GBRG pattern. > FMT_GRBG6, // 6 bit Bayer format with a GRBG pattern. > FMT_RGGB6, // 6 bit Bayer format with a RGGB pattern. > FMT_BGGR8, // 8 bit Bayer format with a BGGR pattern. > FMT_GBRG8, // 8 bit Bayer format with a GBRG pattern. > FMT_GRBG8, // 8 bit Bayer format with a GRBG pattern. > FMT_RGGB8, // 8 bit Bayer format with a RGGB pattern. > FMT_BGGR10, // 10 bit Bayer format with a BGGR pattern. > FMT_GBRG10, // 10 bit Bayer format with a GBRG pattern. > FMT_GRBG10, // 10 bit Bayer format with a GRBG pattern. > FMT_RGGB10, // 10 bit Bayer format with a RGGB pattern. > FMT_BGGR12, // 12 bit Bayer format with a BGGR pattern. > FMT_GBRG12, // 12 bit Bayer format with a GBRG pattern. > FMT_GRBG12, // 12 bit Bayer format with a GRBG pattern. > FMT_RGGB12, // 12 bit Bayer format with a RGGB pattern. > FMT_UNCOMPRESSED_MAX, > > // compressed format below, not compressed should define upper > FMT_COMPRESSED_MIN, > FMT_JPEG, > FMT_PNG, > FMT_COMPRESSED_MAX, > > FMT_INVALID 0xFF // format not valid > } > ``` ### Fit Object fit method item describe **values** **FIT_NONE**: no object fit, keep original<br>**FIT_FILL**: width to new width, height to new height, may be stretch<br>**FIT_CONTAIN**: keep aspect ratio, fill blank area with black color<br>**FIT_COVER**: keep aspect ratio, crop image to fit new size<br>**FIT_MAX**: <br> > C++ defination code: > ```cpp > enum Fit > { > FIT_NONE 1, // no object fit, keep original > FIT_FILL 0, // width to new width, height to new height, may be stretch > FIT_CONTAIN, // keep aspect ratio, fill blank area with black color > FIT_COVER, // keep aspect ratio, crop image to fit new size > FIT_MAX > } > ``` ### ResizeMethod Resize method item describe **values** **NEAREST**: <br>**BILINEAR**: <br>**BICUBIC**: <br>**AREA**: <br>**LANCZOS**: <br>**HAMMING**: <br>**RESIZE_METHOD_MAX**: <br> > C++ defination code: > ```cpp > enum ResizeMethod > { > NEAREST 0, > BILINEAR, > BICUBIC, > AREA, > LANCZOS, > HAMMING, > RESIZE_METHOD_MAX > } > ``` ### ApriltagFamilies Family of apriltag item describe **values** **TAG16H5**: <br>**TAG25H7**: <br>**TAG25H9**: <br>**TAG36H10**: <br>**TAG36H11**: <br>**ARTOOLKIT**: <br> > C++ defination code: > ```cpp > enum ApriltagFamilies > { > TAG16H5 1, > TAG25H7 2, > TAG25H9 4, > TAG36H10 8, > TAG36H11 16, > ARTOOLKIT 32 > } > ``` ### TemplateMatch Template match method item describe **values** **SEARCH_EX**: Exhaustive search<br>**SEARCH_DS**: Diamond search<br> > C++ defination code: > ```cpp > enum TemplateMatch > { > SEARCH_EX, // Exhaustive search > SEARCH_DS, // Diamond search > } > ``` ### CornerDetector CornerDetector class item describe **values** **CORNER_FAST**: <br>**CORNER_AGAST**: <br> > C++ defination code: > ```cpp > enum CornerDetector > { > CORNER_FAST, > CORNER_AGAST > } > ``` ### EdgeDetector EdgeDetector class item describe **values** **EDGE_CANNY**: <br>**EDGE_SIMPLE**: <br> > C++ defination code: > ```cpp > enum EdgeDetector > { > EDGE_CANNY, > EDGE_SIMPLE, > } > ``` ## Variable ### fmt\\_size Image format size in bytes item description **attention** It's a copy of this variable in MaixPy,<br>so change it in C++ (e.g. update var in hello function) will not take effect the var inMaixPy.<br>So we add const for this var to avoid this mistake. **value** **{<br> 3,<br> 3,<br> 4,<br> 4,<br> 2,<br> 2,<br> 2,<br> 2,<br> 1.5,<br> 1.5,<br> 1.5,<br> 1.5,<br> 1, // grayscale<br> 0.75, // 6 bit Bayer format<br> 0.75, // 6 bit Bayer format<br> 0.75, // 6 bit Bayer format<br> 0.75, // 6 bit Bayer format<br> 1, // 8 bit Bayer format<br> 1, // 8 bit Bayer format<br> 1, // 8 bit Bayer format<br> 1, // 8 bit Bayer format<br> 1.25, // 10 bit Bayer format<br> 1.25, // 10 bit Bayer format<br> 1.25, // 10 bit Bayer format<br> 1.25, // 10 bit Bayer format<br> 1.5, // 12 bit Bayer format<br> 1.5, // 12 bit Bayer format<br> 1.5, // 12 bit Bayer format<br> 1.5, // 12 bit Bayer format<br> 0, // uncompereed_max<br> 0, // compressed_min<br> 1, // jpeg<br> 1, // png<br> 0, // compressed_max<br> 0 // invalid<br> }** **readonly** True > C++ defination code: > ```cpp > const std::vector<float> fmt_size { > 3, > 3, > 4, > 4, > 2, > 2, > 2, > 2, > 1.5, > 1.5, > 1.5, > 1.5, > 1, // grayscale > 0.75, // 6 bit Bayer format > 0.75, // 6 bit Bayer format > 0.75, // 6 bit Bayer format > 0.75, // 6 bit Bayer format > 1, // 8 bit Bayer format > 1, // 8 bit Bayer format > 1, // 8 bit Bayer format > 1, // 8 bit Bayer format > 1.25, // 10 bit Bayer format > 1.25, // 10 bit Bayer format > 1.25, // 10 bit Bayer format > 1.25, // 10 bit Bayer format > 1.5, // 12 bit Bayer format > 1.5, // 12 bit Bayer format > 1.5, // 12 bit Bayer format > 1.5, // 12 bit Bayer format > 0, // uncompereed_max > 0, // compressed_min > 1, // jpeg > 1, // png > 0, // compressed_max > 0 // invalid > } > ``` ### fmt\\_names Image format string item description **value** **{<br> \"RGB888\",<br> \"BGR888\",<br> \"RGBA8888\",<br> \"BGRA8888\",<br> \"RGB565\",<br> \"BGR565\",<br> \"YUV422SP\",<br> \"YUV422P\",<br> \"YVU420SP\",<br> \"YUV420SP\",<br> \"YVU420P\",<br> \"YUV420P\",<br> \"GRAYSCALE\",<br> \"BGGR6\",<br> \"GBRG6\",<br> \"GRBG6\",<br> \"RG6B6\",<br> \"BGGR8\",<br> \"GBRG8\",<br> \"GRBG8\",<br> \"RG6B8\",<br> \"BGGR10\",<br> \"GBRG10\",<br> \"GRBG10\",<br> \"RG6B10\",<br> \"BGGR12\",<br> \"GBRG12\",<br> \"GRBG12\",<br> \"RG6B12\",<br> \"UNCOMPRESSED_MAX\",<br> \"COMPRESSED_MIN\",<br> \"JPEG\",<br> \"PNG\",<br> \"COMPRESSED_MAX\",<br> \"INVALID\"<br> }** **readonly** True > C++ defination code: > ```cpp > const std::vector<std::string> fmt_names { > \"RGB888\", > \"BGR888\", > \"RGBA8888\", > \"BGRA8888\", > \"RGB565\", > \"BGR565\", > \"YUV422SP\", > \"YUV422P\", > \"YVU420SP\", > \"YUV420SP\", > \"YVU420P\", > \"YUV420P\", > \"GRAYSCALE\", > \"BGGR6\", > \"GBRG6\", > \"GRBG6\", > \"RG6B6\", > \"BGGR8\", > \"GBRG8\", > \"GRBG8\", > \"RG6B8\", > \"BGGR10\", > \"GBRG10\", > \"GRBG10\", > \"RG6B10\", > \"BGGR12\", > \"GBRG12\", > \"GRBG12\", > \"RG6B12\", > \"UNCOMPRESSED_MAX\", > \"COMPRESSED_MIN\", > \"JPEG\", > \"PNG\", > \"COMPRESSED_MAX\", > \"INVALID\" > } > ``` ### COLOR\\_WHITE Predefined color white item description **value** **image::Color::from_rgb(255, 255, 255)** **readonly** True > C++ defination code: > ```cpp > const image::Color COLOR_WHITE image::Color::from_rgb(255, 255, 255) > ``` ### COLOR\\_BLACK Predefined color black item description **value** **image::Color::from_rgb(0, 0, 0)** **readonly** True > C++ defination code: > ```cpp > const image::Color COLOR_BLACK image::Color::from_rgb(0, 0, 0) > ``` ### COLOR\\_RED Predefined color red item description **value** **image::Color::from_rgb(255, 0, 0)** **readonly** True > C++ defination code: > ```cpp > const image::Color COLOR_RED image::Color::from_rgb(255, 0, 0) > ``` ### COLOR\\_GREEN Predefined color green item description **value** **image::Color::from_rgb(0, 255, 0)** **readonly** True > C++ defination code: > ```cpp > const image::Color COLOR_GREEN image::Color::from_rgb(0, 255, 0) > ``` ### COLOR\\_BLUE Predefined color blue item description **value** **image::Color::from_rgb(0, 0, 255)** **readonly** True > C++ defination code: > ```cpp > const image::Color COLOR_BLUE image::Color::from_rgb(0, 0, 255) > ``` ### COLOR\\_YELLOW Predefined color yellow item description **value** **image::Color::from_rgb(255, 255, 0)** **readonly** True > C++ defination code: > ```cpp > const image::Color COLOR_YELLOW image::Color::from_rgb(255, 255, 0) > ``` ### COLOR\\_PURPLE Predefined color purple item description **value** **image::Color::from_rgb(143, 0, 255)** **readonly** True > C++ defination code: > ```cpp > const image::Color COLOR_PURPLE image::Color::from_rgb(143, 0, 255) > ``` ### COLOR\\_ORANGE Predefined color orange item description **value** **image::Color::from_rgb(255, 127, 0)** **readonly** True > C++ defination code: > ```cpp > const image::Color COLOR_ORANGE image::Color::from_rgb(255, 127, 0) > ``` ### COLOR\\_GRAY Predefined color gray item description **value** **image::Color::from_rgb(127, 127, 127)** **readonly** True > C++ defination code: > ```cpp > const image::Color COLOR_GRAY image::Color::from_rgb(127, 127, 127) > ``` ## Function ### resize\\_map\\_pos ```python def resize_map_pos(w_in: int, h_in: int, w_out: int, h_out: int, fit: Fit, x: int, y: int, w: int 1, h: int 1) > list[int] ``` map point position or rectangle position from one image size to another image size(resize) item description **param** **int**: h_out target image height<br>**fit**: resize method, see maix.image.Fit<br>**x**: original point x, or rectagle left top point's x<br>**y**: original point y, or rectagle left top point's y<br>**w**: original rectagle width, can be 1 if not use this arg, default 1.<br>**h**: original rectagle height, can be 1 if not use this arg, default 1.<br> **return** list type, [x, y] if map point, [x, y, w, h] if resize rectangle. > C++ defination code: > ```cpp > std::vector<int> resize_map_pos(int w_in, int h_in, int w_out, int h_out, image::Fit fit, int x, int y, int w 1, int h 1) > ``` ### resize\\_map\\_pos (overload 1) map point position or rectangle position from this image size to another image size(resize) item description **param** **int**: h_out target image height<br>**fit**: resize method, see maix.image.Fit<br>**x**: original point x, or rectagle left top point's x<br>**y**: original point y, or rectagle left top point's y<br>**w**: original rectagle width, can be 1 if not use this arg, default 1.<br>**h**: original rectagle height, can be 1 if not use this arg, default 1.<br> **return** list type, [x, y] if map point, [x, y, w, h] if resize rectangle. > C++ defination code: > ```cpp > std::vector<int> resize_map_pos(int w_out, int h_out, image::Fit fit, int x, int y, int w 1, int h 1) > ``` ### resize\\_map\\_pos\\_reverse ```python def resize_map_pos_reverse(w_in: int, h_in: int, w_out: int, h_out: int, fit: Fit, x: int, y: int, w: int 1, h: int 1) > list[int] ``` reverse resize_map_pos method, when we call image.resize method resiz image 'a' to image 'b', we want to known the original position on 'a' whith a knew point on 'b' item description **param** **int**: h_out image height after resized<br>**fit**: resize method, see maix.image.Fit<br>**x**: point on resized image x, or rectagle left top point's x<br>**y**: original point y, or rectagle left top point's y<br>**w**: original rectagle width, can be 1 if not use this arg, default 1.<br>**h**: original rectagle height, can be 1 if not use this arg, default 1.<br> **return** list type, [x, y] if map point, [x, y, w, h] if resize rectangle. > C++ defination code: > ```cpp > std::vector<int> resize_map_pos_reverse(int w_in, int h_in, int w_out, int h_out, image::Fit fit, int x, int y, int w 1, int h 1) > ``` ### load ```python def load(path: str, format: Format ...) > Image ``` Load image from file, and convert to Image object item description **param** **path**: image file path<br>**format**: read as this format, if not match, will convert to this format, by default is RGB888<br> **return** Image object, if load failed, will return None(nullptr in C++), so you should care about it. > C++ defination code: > ```cpp > image::Image *load(const char *path, image::Format format image::Format::FMT_RGB888) > ``` ### from\\_bytes ```python def from_bytes(width: int, height: int, format: Format, data: maix.Bytes(bytes), copy: bool True) > Image ``` Create image from bytes item description **param** **width**: image width<br>**height**: image height<br>**format**: image format<br>**data**: image data, if data is None, will malloc memory for image data<br>If the image is in jpeg format, data must be filled in.<br>**copy**: if true and data is not None, will copy data to new buffer, else will use data directly. default is true to avoid memory leak.<br>Use it carefully!!!<br> **return** Image object > C++ defination code: > ```cpp > image::Image *from_bytes(int width, int height, image::Format format, Bytes *data, bool copy true) > ``` ### load\\_font ```python def load_font(name: str, path: str, size: int 16) > maix.err.Err ``` Load font from file item description **param** **name**: font name, used to identify font<br>**path**: font file path, support ttf, ttc, otf<br>**size**: font size, font height, by default is 16<br> **return** error code, err::ERR_NONE is ok, other is error > C++ defination code: > ```cpp > err::Err load_font(const std::string &name, const char *path, int size 16) > ``` ### set\\_default\\_font Set default font, if not call this method, default is hershey_plain item description **param** **name**: font name, supported names can be get by fonts()<br> **return** error code, err::ERR_NONE is ok, other is error > C++ defination code: > ```cpp > err::Err set_default_font(const std::string &name) > ``` ### fonts ```python def fonts() > list[str] ``` Get all loaded fonts item description **return** all loaded fonts, string list type > C++ defination code: > ```cpp > std::vector<std::string> *fonts() > ``` ### string\\_size ```python def string_size(string: str, scale: float 1, thickness: int 1, font: str '') > Size ``` Get text rendered width and height item description **param** **string**: text content<br>**scale**: font scale, by default(value is 1)<br>**thickness**: text thickness(line width), by default(value is 1)<br> **return** text rendered width and height, [width, height] > C++ defination code: > ```cpp > image::Size string_size(std::string string, float scale 1, int thickness 1, const std::string &font \"\") > ``` ### cv2image ```python def cv2image(array: numpy.ndarray[numpy.uint8], bgr: bool True, copy: bool True) > Image ``` OpenCV Mat(numpy array object) to Image object item description **param** **array**: numpy array object, must be a 3 dim or 2 dim continuous array with shape hwc or hw<br>**bgr**: if set bgr, the return image will be marked as BGR888 or BGRA8888 format, grayscale will ignore this arg.<br>**copy**: if true, will alloc new buffer and copy data, else will directly use array's data buffer, default true.<br>Use this arg carefully, when set to false, ther array MUST keep alive until we don't use the return img of this func, or will cause program crash.<br> **return** Image object > C++ defination code: > ```cpp > image::Image *cv2image(py::array_t<uint8_t, py::array::c_style> array, bool bgr true, bool copy true) > ``` ### image2cv ```python def image2cv(img: Image, ensure_bgr: bool True, copy: bool True) > numpy.ndarray[numpy.uint8] ``` Image object to OpenCV Mat(numpy array object) item description **param** **img**: Image object, maix.image.Image type.<br>**ensure_bgr**: auto convert to BGR888 or BGRA8888 if img format is not BGR or BGRA, if set to false, will not auto convert and directly use img's data, default true.<br>**copy**: Whether alloc new image and copy data or not, if ensure_bgr and img is not bgr or bgra format, always copy,<br>if not copy, array object will directly use img's data buffer, will faster but change array will affect img's data, default true.<br> **attention** take care of ensure_bgr and copy param. **return** numpy array object > C++ defination code: > ```cpp > py::array_t<uint8_t, py::array::c_style> image2cv(image::Image *img, bool ensure_bgr true, bool copy true) > ``` ## Class ### Size Image size type > C++ defination code: > ```cpp > class Size > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, width: int 0, height: int 0) > None ``` Construct a new Size object item description **type** func **param** **width**: image width<br>**height**: image height<br> **static** False > C++ defination code: > ```cpp > Size(int width 0, int height 0) > ``` #### width ```python def width(self, width: int 1) > int ``` width of size item description **type** func **param** **width**: set new width, if not set, only return current width<br> **static** False > C++ defination code: > ```cpp > int width(int width 1) > ``` #### height ```python def height(self, height: int 1) > int ``` height of size item description **type** func **param** **height**: set new height, if not set, only return current height<br> **static** False > C++ defination code: > ```cpp > int height(int height 1) > ``` #### \\_\\_getitem\\_\\_ ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: 0 for width, 1 for height<br> **return** int& width or height **static** False > C++ defination code: > ```cpp > int &operator[](int index) > ``` #### \\_\\_str\\_\\_ ```python def __str__(self) > str ``` to string item description **type** func **static** False > C++ defination code: > ```cpp > std::string __str__() > ``` ### Line Line class > C++ defination code: > ```cpp > class Line > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, x1: int, y1: int, x2: int, y2: int, magnitude: int 0, theta: int 0, rho: int 0) > None ``` Line constructor item description **type** func **param** **x1**: coordinate x1 of the straight line<br>**y1**: coordinate y1 of the straight line<br>**x2**: coordinate x2 of the straight line<br>**y2**: coordinate y2 of the straight line<br>**magnitude**: magnitude of the straight line after Hough transformation<br>**theta**: angle of the straight line after Hough transformation<br>**rho**: p value of the straight line after Hough transformation<br> **static** False > C++ defination code: > ```cpp > Line(int x1, int y1, int x2, int y2, int magnitude 0, int theta 0, int rho 0) > ``` #### \\_\\_getitem\\_\\_ ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: [0] get x1 of line<br>[1] get y1 of line<br>[2] get x2 of line<br>[3] get y2 of line<br>[4] get length of line<br>[5] get magnitude of the straight line after Hough transformation<br>[6] get angle of the straight line after Hough transformation (0 179 degrees)<br>[7] get p value of the straight line after Hough transformation<br> **return** int& **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### x1 ```python def x1(self) > int ``` get x1 of line item description **type** func **return** return x1 of the line, type is int **static** False > C++ defination code: > ```cpp > int x1() > ``` #### y1 ```python def y1(self) > int ``` get y1 of line item description **type** func **return** return y1 of the line, type is int **static** False > C++ defination code: > ```cpp > int y1() > ``` #### x2 ```python def x2(self) > int ``` get x2 of line item description **type** func **return** return x2 of the line, type is int **static** False > C++ defination code: > ```cpp > int x2() > ``` #### y2 ```python def y2(self) > int ``` get y2 of line item description **type** func **return** return y2 of the line, type is int **static** False > C++ defination code: > ```cpp > int y2() > ``` #### length ```python def length(self) > int ``` get length of line item description **type** func **return** return length of the line, type is int **static** False > C++ defination code: > ```cpp > int length() > ``` #### magnitude ```python def magnitude(self) > int ``` get magnitude of the straight line after Hough transformation item description **type** func **return** return magnitude, type is int **static** False > C++ defination code: > ```cpp > int magnitude() > ``` #### theta ```python def theta(self) > int ``` get angle of the straight line after Hough transformation (0 179 degrees) item description **type** func **return** return angle, type is int **static** False > C++ defination code: > ```cpp > int theta() > ``` #### rho ```python def rho(self) > int ``` get p value of the straight line after Hough transformation item description **type** func **return** return p value, type is int **static** False > C++ defination code: > ```cpp > int rho() > ``` ### Rect Rect class > C++ defination code: > ```cpp > class Rect > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, corners: list[list[int]], x: int, y: int, w: int, h: int, magnitude: int 0) > None ``` Rect constructor item description **type** func **param** **corners**: corners of rect<br>**x**: coordinate x of the straight line<br>**y**: coordinate y of the straight line<br>**w**: coordinate w of the straight line<br>**h**: coordinate h of the straight line<br>**magnitude**: magnitude of the straight line after Hough transformation<br> **static** False > C++ defination code: > ```cpp > Rect(std::vector<std::vector<int>> &corners, int x, int y, int w, int h, int magnitude 0) > ``` #### \\_\\_getitem\\_\\_ ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: [0] get x of rect<br>[1] get y of rect<br>[2] get w of rect<br>[3] get h of rect<br>[4] get magnitude of the straight line after Hough transformation<br> **return** int& **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### corners ```python def corners(self) > list[list[int]] ``` get corners of rect item description **type** func **return** return the coordinate of the rect. **static** False > C++ defination code: > ```cpp > std::vector<std::vector<int>> corners() > ``` #### rect ```python def rect(self) > list[int] ``` get rectangle of rect item description **type** func **return** return the rectangle of the rect. format is {x, y, w, h}, type is std::vector<int> **static** False > C++ defination code: > ```cpp > std::vector<int> rect() > ``` #### x ```python def x(self) > int ``` get x of rect item description **type** func **return** return x of the rect, type is int **static** False > C++ defination code: > ```cpp > int x() > ``` #### y ```python def y(self) > int ``` get y of rect item description **type** func **return** return y of the rect, type is int **static** False > C++ defination code: > ```cpp > int y() > ``` #### w ```python def w(self) > int ``` get w of rect item description **type** func **return** return w of the rect, type is int **static** False > C++ defination code: > ```cpp > int w() > ``` #### h ```python def h(self) > int ``` get h of rect item description **type** func **return** return h of the rect, type is int **static** False > C++ defination code: > ```cpp > int h() > ``` #### magnitude ```python def magnitude(self) > int ``` get magnitude of the straight line after Hough transformation item description **type** func **return** return magnitude, type is int **static** False > C++ defination code: > ```cpp > int magnitude() > ``` ### Circle circle class > C++ defination code: > ```cpp > class Circle > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, x: int, y: int, r: int, magnitude: int) > None ``` Circle constructor item description **type** func **param** **x**: coordinate x of the circle<br>**y**: coordinate y of the circle<br>**r**: coordinate r of the circle<br>**magnitude**: coordinate y2 of the straight line<br> **static** False > C++ defination code: > ```cpp > Circle(int x, int y, int r, int magnitude) > ``` #### \\_\\_getitem\\_\\_ ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: [0] get x of circle<br>[1] get y of circle<br>[2] get r of circle<br>[3] get magnitude of the circle after Hough transformation<br> **return** int& **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### x ```python def x(self) > int ``` get x of circle item description **type** func **return** return x of the circle, type is int **static** False > C++ defination code: > ```cpp > int x() > ``` #### y ```python def y(self) > int ``` get y of circle item description **type** func **return** return y of the circle, type is int **static** False > C++ defination code: > ```cpp > int y() > ``` #### r ```python def r(self) > int ``` get r of circle item description **type** func **return** return r of the circle, type is int **static** False > C++ defination code: > ```cpp > int r() > ``` #### magnitude ```python def magnitude(self) > int ``` get magnitude of the circle after Hough transformation item description **type** func **return** return magnitude, type is int **static** False > C++ defination code: > ```cpp > int magnitude() > ``` ### Blob Blob class > C++ defination code: > ```cpp > class Blob > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, rect: list[int], corners: list[list[int]], mini_corners: list[list[int]], cx: float, cy: float, pixels: int, rotation: float, code: int, count: int, perimeter: int, roundness: float, x_hist_bins: list[int], y_hist_bins: list[int]) > None ``` Blob constructor item description **type** func **param** **rect**: blob rect, type is std::vector<int><br>**corners**: blob corners, type is std::vector<std::vector<int>><br>**mini_corners**: blob mini_corners, type is std::vector<std::vector<int>><br>**cx**: blob center x, type is float<br>**cy**: blob center y, type is float<br>**pixels**: blob pixels, type is int<br>**rotation**: blob rotation, type is float<br>**code**: blob code, type is int<br>**count**: blob count, type is int<br>**perimeter**: blob perimeter, type is int<br>**roundness**: blob roundness, type is float<br>**x_hist_bins**: blob x_hist_bins, type is std::vector<int><br>**y_hist_bins**: blob y_hist_bins, type is std::vector<int><br> **static** False > C++ defination code: > ```cpp > Blob(std::vector<int> &rect, std::vector<std::vector<int>> &corners, std::vector<std::vector<int>> &mini_corners,float cx, float cy, int pixels, float rotation, int code, int count, int perimeter, float roundness, std::vector<int> &x_hist_bins, std::vector<int> &y_hist_bins) > ``` #### \\_\\_getitem\\_\\_ ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: [0] Returns the blob’s bounding box x coordinate<br>[1] Returns the blob’s bounding box y coordinate<br>[2] Returns the blob’s bounding box w coordinate<br>[3] Returns the blob’s bounding box h coordinate<br>[4] Returns the number of pixels that are part of this blob<br>[5] Returns the centroid x position of the blob<br>[6] Returns the centroid y position of the blob<br> **return** int& width or height **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### corners ```python def corners(self) > list[list[int]] ``` get blob corners item description **type** func **return** Returns a list of 4 (x,y) tuples of the 4 corners of the object.<br>(x0, y0)___________(x1, y1)<br> <br> <br> <br>___________<br>(x3, y3) (x2, y2)<br>note: the order of corners may change **static** False > C++ defination code: > ```cpp > std::vector<std::vector<int>> corners() > ``` #### mini\\_corners ```python def mini_corners(self) > list[list[int]] ``` get blob mini corners item description **type** func **return** Returns a list of 4 (x,y) tuples of the 4 corners than bound the min area rectangle of the blob.<br>(x0, y0)___________(x1, y1)<br> <br> <br> <br>___________<br>(x3, y3) (x2, y2)<br>note: the order of corners may change **static** False > C++ defination code: > ```cpp > std::vector<std::vector<int>> mini_corners() > ``` #### rect ```python def rect(self) > list[int] ``` get blob rect item description **type** func **return** Returns the center coordinates and width and height of the rectangle. format is (x, y, w, h)<br>w<br>(x, y) ___________<br> <br> h<br> <br>___________ **static** False > C++ defination code: > ```cpp > std::vector<int> rect() > ``` #### x ```python def x(self) > int ``` get blob x of the upper left coordinate item description **type** func **return** Returns the x coordinate of the upper left corner of the rectangle. **static** False > C++ defination code: > ```cpp > int x() > ``` #### y ```python def y(self) > int ``` get blob y of the upper left coordinate item description **type** func **return** Returns the y coordinate of the upper left corner of the rectangle. **static** False > C++ defination code: > ```cpp > int y() > ``` #### w ```python def w(self) > int ``` get blob width item description **type** func **return** Returns the blob’s bounding box w coordinate **static** False > C++ defination code: > ```cpp > int w() > ``` #### h ```python def h(self) > int ``` get blob height item description **type** func **return** Returns the blob’s bounding box h coordinate **static** False > C++ defination code: > ```cpp > int h() > ``` #### pixels ```python def pixels(self) > int ``` get blob pixels item description **type** func **return** Returns the number of pixels that are part of this blob. **static** False > C++ defination code: > ```cpp > int pixels() > ``` #### cx ```python def cx(self) > int ``` get blob center x item description **type** func **return** Returns the centroid x position of the blob **static** False > C++ defination code: > ```cpp > int cx() > ``` #### cy ```python def cy(self) > int ``` get blob center y item description **type** func **return** Returns the centroid y position of the blob **static** False > C++ defination code: > ```cpp > int cy() > ``` #### cxf ```python def cxf(self) > float ``` get blob center x item description **type** func **return** Returns the centroid x position of the blob **static** False > C++ defination code: > ```cpp > float cxf() > ``` #### cyf ```python def cyf(self) > float ``` get blob center y item description **type** func **return** Returns the centroid y position of the blob **static** False > C++ defination code: > ```cpp > float cyf() > ``` #### rotation ```python def rotation(self) > float ``` get blob rotation item description **type** func **return** Returns the rotation of the blob in radians (float). If the blob is like a pencil or pen this value will be unique for 0 180 degrees. **static** False > C++ defination code: > ```cpp > float rotation() > ``` #### rotation\\_rad ```python def rotation_rad(self) > float ``` get blob rotation_rad item description **type** func **return** Returns the rotation of the blob in radians **static** False > C++ defination code: > ```cpp > float rotation_rad() > ``` #### rotation\\_deg ```python def rotation_deg(self) > int ``` get blob rotation_deg item description **type** func **return** Returns the rotation of the blob in degrees. **static** False > C++ defination code: > ```cpp > int rotation_deg() > ``` #### code ```python def code(self) > int ``` get blob code item description **type** func **return** Returns a 32 bit binary number with a bit set in it for each color threshold that’s part of this blob **static** False > C++ defination code: > ```cpp > int code() > ``` #### count ```python def count(self) > int ``` get blob count item description **type** func **return** Returns the number of blobs merged into this blob. **static** False > C++ defination code: > ```cpp > int count() > ``` #### perimeter ```python def perimeter(self) > int ``` get blob merge_cnt item description **type** func **return** Returns the number of pixels on this blob’s perimeter. **static** False > C++ defination code: > ```cpp > int perimeter() > ``` #### roundness ```python def roundness(self) > float ``` get blob roundness item description **type** func **return** Returns a value between 0 and 1 representing how round the object is **static** False > C++ defination code: > ```cpp > float roundness() > ``` #### elongation ```python def elongation(self) > float ``` get blob elongation item description **type** func **returnReturns** a value between 0 and 1 representing how long (not round) the object is **static** False > C++ defination code: > ```cpp > float elongation() > ``` #### area ```python def area(self) > int ``` get blob area item description **type** func **return** Returns the area of the bounding box around the blob **static** False > C++ defination code: > ```cpp > int area() > ``` #### density ```python def density(self) > float ``` get blob density item description **type** func **return** Returns the density ratio of the blob **static** False > C++ defination code: > ```cpp > float density() > ``` #### extent ```python def extent(self) > float ``` Alias for blob.density() item description **type** func **return** Returns the density ratio of the blob **static** False > C++ defination code: > ```cpp > float extent() > ``` #### compactness ```python def compactness(self) > float ``` get blob compactness item description **type** func **return** Returns the compactness ratio of the blob **static** False > C++ defination code: > ```cpp > float compactness() > ``` #### solidity ```python def solidity(self) > float ``` get blob solidity item description **type** func **return** Returns the solidity ratio of the blob **static** False > C++ defination code: > ```cpp > float solidity() > ``` #### convexity ```python def convexity(self) > float ``` get blob convexity item description **type** func **return** Returns a value between 0 and 1 representing how convex the object is **static** False > C++ defination code: > ```cpp > float convexity() > ``` #### x\\_hist\\_bins ```python def x_hist_bins(self) > list[int] ``` get blob x_hist_bins item description **type** func **return** Returns the x_hist_bins of the blob **static** False > C++ defination code: > ```cpp > std::vector<int> x_hist_bins() > ``` #### y\\_hist\\_bins ```python def y_hist_bins(self) > list[int] ``` get blob y_hist_bins item description **type** func **return** Returns the y_hist_bins of the blob **static** False > C++ defination code: > ```cpp > std::vector<int> y_hist_bins() > ``` #### major\\_axis\\_line ```python def major_axis_line(self) > list[int] ``` get blob major_axis_line item description **type** func **return** Returns a line tuple (x1, y1, x2, y2) of the minor axis of the blob. **static** False > C++ defination code: > ```cpp > std::vector<int> major_axis_line() > ``` #### minor\\_axis\\_line ```python def minor_axis_line(self) > list[int] ``` get blob minor_axis_line item description **type** func **return** Returns a line tuple (x1, y1, x2, y2) of the minor axis of the blob. **static** False > C++ defination code: > ```cpp > std::vector<int> minor_axis_line() > ``` #### enclosing\\_circle ```python def enclosing_circle(self) > list[int] ``` get blob enclosing_circle item description **type** func **return** Returns a circle tuple (x, y, r) of the circle that encloses the min area rectangle of a blob. **static** False > C++ defination code: > ```cpp > std::vector<int> enclosing_circle() > ``` #### enclosed\\_ellipse ```python def enclosed_ellipse(self) > list[int] ``` get blob enclosed_ellipse item description **type** func **return** Returns an ellipse tuple (x, y, rx, ry, rotation) of the ellipse that fits inside of the min area rectangle of a blob. **static** False > C++ defination code: > ```cpp > std::vector<int> enclosed_ellipse() > ``` ### QRCode QRCode class > C++ defination code: > ```cpp > class QRCode > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, rect: list[int], corners: list[list[int]], payload: str, version: int, ecc_level: int, mask: int, data_type: int, eci: int) > None ``` QRCode constructor item description **type** func **param** **rect**: rect of corners, type is std::vector<int><br>**corners**: corners of QRCode<br>**payload**: payload of the QRCode<br>**version**: version of the QRCode<br>**ecc_level**: ecc_level of the QRCode<br>**mask**: mask of the QRCode<br>**data_type**: data_type of the QRCode<br>**eci**: eci of the QRCode<br> **static** False > C++ defination code: > ```cpp > QRCode(std::vector<int> &rect, std::vector<std::vector<int>> &corners, std::string &payload, int version, int ecc_level, int mask, int data_type, int eci) > ``` #### \\_\\_getitem\\_\\_ ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: [0] Returns the qrcode’s bounding box x coordinate<br>[1] Returns the qrcode’s bounding box y coordinate<br>[2] Returns the qrcode’s bounding box w coordinate<br>[3] Returns the qrcode’s bounding box h coordinate<br>[4] Not support this index, try to use payload() method<br>[5] Returns the version of qrcode<br>[6] Returns the error correction level of qrcode<br>[7] Returns the mask of qrcode<br>[8] Returns the datatype of qrcode<br>[9] Returns the eci of qrcode<br> **return** int& **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### corners ```python def corners(self) > list[list[int]] ``` get coordinate of QRCode item description **type** func **return** return the coordinate of the QRCode. **static** False > C++ defination code: > ```cpp > std::vector<std::vector<int>> corners() > ``` #### rect ```python def rect(self) > list[int] ``` get rectangle of QRCode item description **type** func **return** return the rectangle of the QRCode. format is {x, y, w, h}, type is std::vector<int> **static** False > C++ defination code: > ```cpp > std::vector<int> rect() > ``` #### x ```python def x(self) > int ``` get x of QRCode item description **type** func **return** return x of the QRCode, type is int **static** False > C++ defination code: > ```cpp > int x() > ``` #### y ```python def y(self) > int ``` get y of QRCode item description **type** func **return** return y of the QRCode, type is int **static** False > C++ defination code: > ```cpp > int y() > ``` #### w ```python def w(self) > int ``` get w of QRCode item description **type** func **return** return w of the QRCode, type is int **static** False > C++ defination code: > ```cpp > int w() > ``` #### h ```python def h(self) > int ``` get h of QRCode item description **type** func **return** return h of the QRCode, type is int **static** False > C++ defination code: > ```cpp > int h() > ``` #### payload ```python def payload(self) > str ``` get QRCode payload item description **type** func **return** return area of the QRCode **static** False > C++ defination code: > ```cpp > std::string payload() > ``` #### version ```python def version(self) > int ``` get QRCode version item description **type** func **return** return version of the QRCode **static** False > C++ defination code: > ```cpp > int version() > ``` #### ecc\\_level ```python def ecc_level(self) > int ``` get QRCode error correction level item description **type** func **return** return error correction level of the QRCode **static** False > C++ defination code: > ```cpp > int ecc_level() > ``` #### mask ```python def mask(self) > int ``` get QRCode mask item description **type** func **return** return mask of the QRCode **static** False > C++ defination code: > ```cpp > int mask() > ``` #### data\\_type ```python def data_type(self) > int ``` get QRCode dataType item description **type** func **return** return mask of the QRCode **static** False > C++ defination code: > ```cpp > int data_type() > ``` #### eci ```python def eci(self) > int ``` get QRCode eci item description **type** func **return** return data of the QRCode **static** False > C++ defination code: > ```cpp > int eci() > ``` #### is\\_numeric ```python def is_numeric(self) > bool ``` check QRCode is numeric item description **type** func **return** return true if the result type of the QRCode is numeric **static** False > C++ defination code: > ```cpp > bool is_numeric() > ``` #### is\\_alphanumeric ```python def is_alphanumeric(self) > bool ``` check QRCode is alphanumeric item description **type** func **return** return true if the result type of the QRCode is alphanumeric **static** False > C++ defination code: > ```cpp > bool is_alphanumeric() > ``` #### is\\_binary ```python def is_binary(self) > bool ``` check QRCode is binary item description **type** func **return** return true if the result type of the QRCode is binary **static** False > C++ defination code: > ```cpp > bool is_binary() > ``` #### is\\_kanji ```python def is_kanji(self) > bool ``` check QRCode is kanji item description **type** func **return** return true if the result type of the QRCode is kanji **static** False > C++ defination code: > ```cpp > bool is_kanji() > ``` ### AprilTag AprilTag class > C++ defination code: > ```cpp > class AprilTag > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, rect: list[int], corners: list[list[int]], id: int, famliy: int, centroid_x: float, centroid_y: float, rotation: float, decision_margin: float, hamming: int, goodness: float, x_translation: float, y_translation: float, z_translation: float, x_rotation: float, y_rotation: float, z_rotation: float) > None ``` AprilTag constructor item description **type** func **param** **rect**: Inlucdes the top left corner and the width and height of the rectangle. format is {x, y, w, h}, type is std::vector<int><br>**corners**: Includes the four corners of the rectangle. format is {{x0, y0}, {x1, y1}, {x2, y2}, {x3, y3}}, type is std::vector<std::vector<int>><br>**id**: The id of the AprilTag<br>**famliy**: The family of the AprilTag<br>**centroid_x**: The x coordinate of the center of the AprilTag<br>**centroid_y**: The y coordinate of the center of the AprilTag<br>**rotation**: The rotation of the AprilTag<br>**decision_margin**: The decision_margin of the AprilTag<br>**hamming**: The hamming of the AprilTag<br>**goodness**: The goodness of the AprilTag<br>**x_translation**: The x_translation of the AprilTag<br>**y_translation**: The y_translation of the AprilTag<br>**z_translation**: The z_translation of the AprilTag<br>**x_rotation**: The x_rotation of the AprilTag<br>**y_rotation**: The y_rotation of the AprilTag<br>**z_rotation**: The z_rotation of the AprilTag<br> **static** False > C++ defination code: > ```cpp > AprilTag(std::vector<int> &rect, std::vector<std::vector<int>> &corners, int id, int famliy, float centroid_x, float centroid_y, float rotation, float decision_margin, int hamming, float goodness, float x_translation, float y_translation, float z_translation, float x_rotation, float y_rotation, float z_rotation) > ``` #### \\_\\_getitem\\_\\_ ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: [0] Returns the apriltag’s bounding box x coordinate<br>[1] Returns the apriltag’s bounding box y coordinate<br>[2] Returns the apriltag’s bounding box w coordinate<br>[3] Returns the apriltag’s bounding box h coordinate<br>[4] Returns the apriltag’s id<br>[5] Returns the apriltag’s family<br>[6] Not support<br>[7] Not support<br>[8] Not support<br>[9] Not support<br>[10] Returns the apriltag’s hamming<br>[11] Not support<br>[12] Not support<br>[13] Not support<br>[14] Not support<br>[15] Not support<br>[16] Not support<br>[17] Not support<br> **return** int& **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### corners ```python def corners(self) > list[list[int]] ``` get coordinate of AprilTag item description **type** func **return** return the coordinate of the AprilTag. **static** False > C++ defination code: > ```cpp > std::vector<std::vector<int>> corners() > ``` #### rect ```python def rect(self) > list[int] ``` get rectangle of AprilTag item description **type** func **return** return the rectangle of the AprilTag. format is {x, y, w, h}, type is std::vector<int> **static** False > C++ defination code: > ```cpp > std::vector<int> rect() > ``` #### x ```python def x(self) > int ``` get x of AprilTag item description **type** func **return** return x of the AprilTag, type is int **static** False > C++ defination code: > ```cpp > int x() > ``` #### y ```python def y(self) > int ``` get y of AprilTag item description **type** func **return** return y of the AprilTag, type is int **static** False > C++ defination code: > ```cpp > int y() > ``` #### w ```python def w(self) > int ``` get w of AprilTag item description **type** func **return** return w of the AprilTag, type is int **static** False > C++ defination code: > ```cpp > int w() > ``` #### h ```python def h(self) > int ``` get h of AprilTag item description **type** func **return** return h of the AprilTag, type is int **static** False > C++ defination code: > ```cpp > int h() > ``` #### id ```python def id(self) > int ``` get id of AprilTag item description **type** func **return** return id of the AprilTag, type is int **static** False > C++ defination code: > ```cpp > int id() > ``` #### family ```python def family(self) > int ``` get family of AprilTag item description **type** func **return** return family of the AprilTag, type is int **static** False > C++ defination code: > ```cpp > int family() > ``` #### cx ```python def cx(self) > int ``` get cx of AprilTag item description **type** func **return** return cx of the AprilTag, type is int **static** False > C++ defination code: > ```cpp > int cx() > ``` #### cxf ```python def cxf(self) > float ``` get cxf of AprilTag item description **type** func **return** return cxf of the AprilTag, type is float **static** False > C++ defination code: > ```cpp > float cxf() > ``` #### cy ```python def cy(self) > int ``` get cy of AprilTag item description **type** func **return** return cy of the AprilTag, type is int **static** False > C++ defination code: > ```cpp > int cy() > ``` #### cyf ```python def cyf(self) > float ``` get cyf of AprilTag item description **type** func **return** return cyf of the AprilTag, type is float **static** False > C++ defination code: > ```cpp > float cyf() > ``` #### rotation ```python def rotation(self) > float ``` get rotation of AprilTag item description **type** func **return** return rotation of the AprilTag, type is float **static** False > C++ defination code: > ```cpp > float rotation() > ``` #### decision\\_margin ```python def decision_margin(self) > float ``` Get decision_margin of AprilTag item description **type** func **return** Returns the quality of the apriltag match (0.0 1.0) where 1.0 is the best. **static** False > C++ defination code: > ```cpp > float decision_margin() > ``` #### hamming ```python def hamming(self) > int ``` get hamming of AprilTag item description **type** func **return** Returns the number of accepted bit errors for this tag.<br>return 0, means 0 bit errors will be accepted.<br>1 is TAG25H7, means up to 1 bit error may be accepted<br>2 is TAG25H9, means up to 3 bit errors may be accepted<br>3 is TAG36H10, means up to 3 bit errors may be accepted<br>4 is TAG36H11, means up to 4 bit errors may be accepted<br>5 is ARTOOLKIT, means 0 bit errors will be accepted **static** False > C++ defination code: > ```cpp > int hamming() > ``` #### goodness ```python def goodness(self) > float ``` get goodness of AprilTag item description **type** func **return** return goodness of the AprilTag, type is float<br>Note: This value is always 0.0 for now. **static** False > C++ defination code: > ```cpp > float goodness() > ``` #### x\\_translation ```python def x_translation(self) > float ``` get x_translation of AprilTag item description **type** func **return** return x_translation of the AprilTag, type is float **static** False > C++ defination code: > ```cpp > float x_translation() > ``` #### y\\_translation ```python def y_translation(self) > float ``` get y_translation of AprilTag item description **type** func **return** return y_translation of the AprilTag, type is float **static** False > C++ defination code: > ```cpp > float y_translation() > ``` #### z\\_translation ```python def z_translation(self) > float ``` get z_translation of AprilTag item description **type** func **return** return z_translation of the AprilTag, type is float **static** False > C++ defination code: > ```cpp > float z_translation() > ``` #### x\\_rotation ```python def x_rotation(self) > float ``` get x_rotation of AprilTag item description **type** func **return** return x_rotation of the AprilTag, type is float **static** False > C++ defination code: > ```cpp > float x_rotation() > ``` #### y\\_rotation ```python def y_rotation(self) > float ``` get y_rotation of AprilTag item description **type** func **return** return y_rotation of the AprilTag, type is float **static** False > C++ defination code: > ```cpp > float y_rotation() > ``` #### z\\_rotation ```python def z_rotation(self) > float ``` get z_rotation of AprilTag item description **type** func **return** return z_rotation of the AprilTag, type is float **static** False > C++ defination code: > ```cpp > float z_rotation() > ``` ### DataMatrix DataMatrix class > C++ defination code: > ```cpp > class DataMatrix > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, rect: list[int], corners: list[list[int]], payload: str, rotation: float, rows: int, columns: int, capacity: int, padding: int) > None ``` DataMatrix constructor item description **type** func **param** **rect**: Inlucdes the top left corner and the width and height of the rectangle. format is {x, y, w, h}, type is std::vector<int><br>**corners**: Includes the four corners of the rectangle. format is {{x0, y0}, {x1, y1}, {x2, y2}, {x3, y3}}, type is std::vector<std::vector<int>><br>**payload**: The payload of the DataMatrix<br>**rotation**: The rotation of the DataMatrix<br>**rows**: The rows of the DataMatrix<br>**columns**: The columns of the DataMatrix<br>**capacity**: The capacity of the DataMatrix<br>**padding**: The padding of the DataMatrix<br> **static** False > C++ defination code: > ```cpp > DataMatrix(std::vector<int> &rect, std::vector<std::vector<int>> &corners, std::string &payload, float rotation, int rows, int columns, int capacity, int padding) > ``` #### \\_\\_getitem\\_\\_ ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: [0] get x of DataMatrix<br>[1] get y of DataMatrix<br>[2] get w of DataMatrix<br>[3] get h of DataMatrix<br>[4] Not support this index, try to use payload() method<br>[5] Not support this index, try to use rotation() method<br>[6] get rows of DataMatrix<br>[7] get columns of DataMatrix<br>[8] get capacity of DataMatrix<br>[9] get padding of DataMatrix<br> **return** int& **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### corners ```python def corners(self) > list[list[int]] ``` get coordinate of DataMatrix item description **type** func **return** return the coordinate of the DataMatrix. **static** False > C++ defination code: > ```cpp > std::vector<std::vector<int>> corners() > ``` #### rect ```python def rect(self) > list[int] ``` get rectangle of DataMatrix item description **type** func **return** return the rectangle of the DataMatrix. format is {x, y, w, h}, type is std::vector<int> **static** False > C++ defination code: > ```cpp > std::vector<int> rect() > ``` #### x ```python def x(self) > int ``` get x of DataMatrix item description **type** func **return** return x of the DataMatrix, type is int **static** False > C++ defination code: > ```cpp > int x() > ``` #### y ```python def y(self) > int ``` get y of DataMatrix item description **type** func **return** return y of the DataMatrix, type is int **static** False > C++ defination code: > ```cpp > int y() > ``` #### w ```python def w(self) > int ``` get w of DataMatrix item description **type** func **return** return w of the DataMatrix, type is int **static** False > C++ defination code: > ```cpp > int w() > ``` #### h ```python def h(self) > int ``` get h of DataMatrix item description **type** func **return** return h of the DataMatrix, type is int **static** False > C++ defination code: > ```cpp > int h() > ``` #### payload ```python def payload(self) > str ``` get payload of DataMatrix item description **type** func **return** return payload of the DataMatrix, type is std::string **static** False > C++ defination code: > ```cpp > std::string payload() > ``` #### rotation ```python def rotation(self) > float ``` get rotation of DataMatrix item description **type** func **return** return rotation of the DataMatrix, type is float **static** False > C++ defination code: > ```cpp > float rotation() > ``` #### rows ```python def rows(self) > int ``` get rows of DataMatrix item description **type** func **return** return rows of the DataMatrix, type is int **static** False > C++ defination code: > ```cpp > int rows() > ``` #### columns ```python def columns(self) > int ``` get columns of DataMatrix item description **type** func **return** return columns of the DataMatrix, type is int **static** False > C++ defination code: > ```cpp > int columns() > ``` #### capacity ```python def capacity(self) > int ``` get capacity of DataMatrix item description **type** func **return** returns how many characters could fit in this data matrix, type is int **static** False > C++ defination code: > ```cpp > int capacity() > ``` #### padding ```python def padding(self) > int ``` get padding of DataMatrix item description **type** func **return** returns how many unused characters are in this data matrix, type is int **static** False > C++ defination code: > ```cpp > int padding() > ``` ### BarCode BarCode class > C++ defination code: > ```cpp > class BarCode > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, rect: list[int], corners: list[list[int]], payload: str, type: int, rotation: float, quality: int) > None ``` BarCode constructor item description **type** func **param** **rect**: Inlucdes the top left corner and the width and height of the rectangle. format is {x, y, w, h}, type is std::vector<int><br>**corners**: Includes the four corners of the rectangle. format is {{x0, y0}, {x1, y1}, {x2, y2}, {x3, y3}}, type is std::vector<std::vector<int>><br>**payload**: The payload of the BarCode<br>**type**: The type of the BarCode<br>**rotation**: The rotation of the BarCode<br>**quality**: The quality of the BarCode<br> **static** False > C++ defination code: > ```cpp > BarCode(std::vector<int> &rect, std::vector<std::vector<int>> &corners, std::string &payload, int type, float rotation, int quality) > ``` #### \\_\\_getitem\\_\\_ ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: [0] get x of BarCode<br>[1] get y of BarCode<br>[2] get w of BarCode<br>[3] get h of BarCode<br>[4] Not support this index, try to use payload() method<br>[5] get type of BarCode<br>[6] Not support this index, try to use rotation() method<br>[7] get quality of BarCode<br> **return** int& **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### corners ```python def corners(self) > list[list[int]] ``` get coordinate of BarCode item description **type** func **return** return the coordinate of the BarCode. **static** False > C++ defination code: > ```cpp > std::vector<std::vector<int>> corners() > ``` #### rect ```python def rect(self) > list[int] ``` get rectangle of BarCode item description **type** func **return** return the rectangle of the BarCode. format is {x, y, w, h}, type is std::vector<int> **static** False > C++ defination code: > ```cpp > std::vector<int> rect() > ``` #### x ```python def x(self) > int ``` get x of BarCode item description **type** func **return** return x of the BarCode, type is int **static** False > C++ defination code: > ```cpp > int x() > ``` #### y ```python def y(self) > int ``` get y of BarCode item description **type** func **return** return y of the BarCode, type is int **static** False > C++ defination code: > ```cpp > int y() > ``` #### w ```python def w(self) > int ``` get w of BarCode item description **type** func **return** return w of the BarCode, type is int **static** False > C++ defination code: > ```cpp > int w() > ``` #### h ```python def h(self) > int ``` get h of BarCode item description **type** func **return** return h of the BarCode, type is int **static** False > C++ defination code: > ```cpp > int h() > ``` #### payload ```python def payload(self) > str ``` get payload of BarCode item description **type** func **return** return payload of the BarCode, type is std::string **static** False > C++ defination code: > ```cpp > std::string payload() > ``` #### type ```python def type(self) > int ``` get type of BarCode item description **type** func **return** return type of the BarCode, type is int **static** False > C++ defination code: > ```cpp > int type() > ``` #### rotation ```python def rotation(self) > float ``` get rotation of BarCode item description **type** func **return** return rotation of the BarCode, type is float. FIXME: always return 0.0 **static** False > C++ defination code: > ```cpp > float rotation() > ``` #### quality ```python def quality(self) > int ``` get quality of BarCode item description **type** func **return** return quality of the BarCode, type is int **static** False > C++ defination code: > ```cpp > int quality() > ``` ### Statistics Statistics class > C++ defination code: > ```cpp > class Statistics > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, format: Format, l_statistics: list[int], a_statistics: list[int], b_statistics: list[int]) > None ``` Statistics constructor item description **type** func **param** **format**: The statistics source image format<br>**l_statistics**: The statistics of the L channel. format is {mean, median, mode, std_dev, min, max, lq, uq}, type is std::vector<int><br>**a_statistics**: The statistics of the A channel. format is {mean, median, mode, std_dev, min, max, lq, uq}, type is std::vector<int><br>**b_statistics**: The statistics of the B channel. format is {mean, median, mode, std_dev, min, max, lq, uq}, type is std::vector<int><br> **static** False > C++ defination code: > ```cpp > Statistics(image::Format format, std::vector<int> &l_statistics, std::vector<int> &a_statistics, std::vector<int> &b_statistics) > ``` #### \\_\\_getitem\\_\\_ ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: array index<br> **return** int& **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### format ```python def format(self) > Format ``` get format of Statistics source image item description **type** func **return** return format of the Statistics source image, type is image::Format **static** False > C++ defination code: > ```cpp > image::Format format() > ``` #### l\\_mean ```python def l_mean(self) > int ``` get L channel mean item description **type** func **return** return L channel mean, type is int **static** False > C++ defination code: > ```cpp > int l_mean() > ``` #### l\\_median ```python def l_median(self) > int ``` get L channel median item description **type** func **return** return L channel median, type is int **static** False > C++ defination code: > ```cpp > int l_median() > ``` #### l\\_mode ```python def l_mode(self) > int ``` get L channel mode item description **type** func **return** return L channel mode, type is int **static** False > C++ defination code: > ```cpp > int l_mode() > ``` #### l\\_std\\_dev ```python def l_std_dev(self) > int ``` get L channel std_dev item description **type** func **return** return L channel std_dev, type is int **static** False > C++ defination code: > ```cpp > int l_std_dev() > ``` #### l\\_min ```python def l_min(self) > int ``` get L channel min item description **type** func **return** return L channel min, type is int **static** False > C++ defination code: > ```cpp > int l_min() > ``` #### l\\_max ```python def l_max(self) > int ``` get L channel max item description **type** func **return** return L channel max, type is int **static** False > C++ defination code: > ```cpp > int l_max() > ``` #### l\\_lq ```python def l_lq(self) > int ``` get L channel lq item description **type** func **return** return L channel lq, type is int **static** False > C++ defination code: > ```cpp > int l_lq() > ``` #### l\\_uq ```python def l_uq(self) > int ``` get L channel uq item description **type** func **return** return L channel uq, type is int **static** False > C++ defination code: > ```cpp > int l_uq() > ``` #### a\\_mean ```python def a_mean(self) > int ``` get A channel mean item description **type** func **return** return A channel mean, type is int **static** False > C++ defination code: > ```cpp > int a_mean() > ``` #### a\\_median ```python def a_median(self) > int ``` get A channea median item description **type** func **return** return A channel median, type is int **static** False > C++ defination code: > ```cpp > int a_median() > ``` #### a\\_mode ```python def a_mode(self) > int ``` get A channel mode item description **type** func **return** return A channel mode, type is int **static** False > C++ defination code: > ```cpp > int a_mode() > ``` #### a\\_std\\_dev ```python def a_std_dev(self) > int ``` get A channel std_dev item description **type** func **return** return A channel std_dev, type is int **static** False > C++ defination code: > ```cpp > int a_std_dev() > ``` #### a\\_min ```python def a_min(self) > int ``` get A channel min item description **type** func **return** return A channel min, type is int **static** False > C++ defination code: > ```cpp > int a_min() > ``` #### a\\_max ```python def a_max(self) > int ``` get A channel max item description **type** func **return** return A channel max, type is int **static** False > C++ defination code: > ```cpp > int a_max() > ``` #### a\\_lq ```python def a_lq(self) > int ``` get A channel lq item description **type** func **return** return A channel lq, type is int **static** False > C++ defination code: > ```cpp > int a_lq() > ``` #### a\\_uq ```python def a_uq(self) > int ``` get A channel uq item description **type** func **return** return A channel uq, type is int **static** False > C++ defination code: > ```cpp > int a_uq() > ``` #### b\\_mean ```python def b_mean(self) > int ``` get B channel mean item description **type** func **return** return B channel mean, type is int **static** False > C++ defination code: > ```cpp > int b_mean() > ``` #### b\\_median ```python def b_median(self) > int ``` get B channea median item description **type** func **return** return B channel median, type is int **static** False > C++ defination code: > ```cpp > int b_median() > ``` #### b\\_mode ```python def b_mode(self) > int ``` get B channel mode item description **type** func **return** return B channel mode, type is int **static** False > C++ defination code: > ```cpp > int b_mode() > ``` #### b\\_std\\_dev ```python def b_std_dev(self) > int ``` get B channel std_dev item description **type** func **return** return B channel std_dev, type is int **static** False > C++ defination code: > ```cpp > int b_std_dev() > ``` #### b\\_min ```python def b_min(self) > int ``` get B channel min item description **type** func **return** return B channel min, type is int **static** False > C++ defination code: > ```cpp > int b_min() > ``` #### b\\_max ```python def b_max(self) > int ``` get B channel max item description **type** func **return** return B channel max, type is int **static** False > C++ defination code: > ```cpp > int b_max() > ``` #### b\\_lq ```python def b_lq(self) > int ``` get B channel lq item description **type** func **return** return B channel lq, type is int **static** False > C++ defination code: > ```cpp > int b_lq() > ``` #### b\\_uq ```python def b_uq(self) > int ``` get B channel uq item description **type** func **return** return B channel uq, type is int **static** False > C++ defination code: > ```cpp > int b_uq() > ``` ### Displacement Displacement class > C++ defination code: > ```cpp > class Displacement > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, x_translation: float, y_translation: float, rotation: float, scale: float, response: float) > None ``` Displacement constructor item description **type** func **param** **x_translation**: The x_translation of the Displacement<br>**y_translation**: The y_translation of the Displacement<br>**rotation**: The rotation of the Displacement<br>**scale**: The scale of the Displacement<br>**response**: The response of the Displacement<br> **static** False > C++ defination code: > ```cpp > Displacement(float x_translation, float y_translation, float rotation, float scale, float response) > ``` #### \\_\\_getitem\\_\\_ ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: array index<br> **return** int& **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### x\\_translation ```python def x_translation(self) > float ``` get x_translation of Displacement item description **type** func **return** return x_translation of the Displacement, type is float **static** False > C++ defination code: > ```cpp > float x_translation() > ``` #### y\\_translation ```python def y_translation(self) > float ``` get y_translation of Displacement item description **type** func **return** return y_translation of the Displacement, type is float **static** False > C++ defination code: > ```cpp > float y_translation() > ``` #### rotation ```python def rotation(self) > float ``` get rotation of Displacement item description **type** func **return** return rotation of the Displacement, type is float **static** False > C++ defination code: > ```cpp > float rotation() > ``` #### scale ```python def scale(self) > float ``` get scale of Displacement item description **type** func **return** return scale of the Displacement, type is float **static** False > C++ defination code: > ```cpp > float scale() > ``` #### response ```python def response(self) > float ``` get response of Displacement item description **type** func **return** return response of the Displacement, type is float **static** False > C++ defination code: > ```cpp > float response() > ``` ### Percentile Percentile class > C++ defination code: > ```cpp > class Percentile > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, l_value: int, a_value: int 0, b_value: int 0) > None ``` Percentile constructor item description **type** func **param** **l_value**: for grayscale image, it is grayscale percentile value (between 0 and 255).<br>for rgb888 image, it is l channel percentile value of lab (between 0 and 100).<br>**a_value**: for rgb888 image, it is a channel percentile value of lab format(between 128 and 127).<br>**b_value**: for rgb888 image, it is b channel percentile value of lab format(between 128 and 127).<br> **static** False > C++ defination code: > ```cpp > Percentile(int l_value, int a_value 0, int b_value 0) > ``` #### \\_\\_getitem\\_\\_ ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### value ```python def value(self) > int ``` Return the grayscale percentile value (between 0 and 255). item description **type** func **return** returns grayscale percentile value **static** False > C++ defination code: > ```cpp > int value() > ``` #### l\\_value ```python def l_value(self) > int ``` Return the l channel percentile value of lab format (between 0 and 100). item description **type** func **return** returns l channel percentile value **static** False > C++ defination code: > ```cpp > int l_value() > ``` #### a\\_value ```python def a_value(self) > int ``` Return the a channel percentile value of lab format (between 128 and 127). item description **type** func **return** returns a channel percentile value **static** False > C++ defination code: > ```cpp > int a_value() > ``` #### b\\_value ```python def b_value(self) > int ``` Return the b channel percentile value of lab format (between 128 and 127). item description **type** func **return** returns b channel percentile value **static** False > C++ defination code: > ```cpp > int b_value() > ``` ### Threshold Threshold class > C++ defination code: > ```cpp > class Threshold > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, l_value: int, a_value: int 0, b_value: int 0) > None ``` Threshold constructor item description **type** func **param** **l_value**: for grayscale image, it is grayscale threshold value (between 0 and 255).<br>for rgb888 image, it is l channel threshold value of lab (between 0 and 100).<br>**a_value**: for rgb888 image, it is a channel threshold value of lab format(between 128 and 127).<br>**b_value**: for rgb888 image, it is b channel threshold value of lab format(between 128 and 127).<br> **static** False > C++ defination code: > ```cpp > Threshold(int l_value, int a_value 0, int b_value 0) > ``` #### \\_\\_getitem\\_\\_ ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### value ```python def value(self) > int ``` Return the grayscale threshold value (between 0 and 255). item description **type** func **return** returns grayscale threshold value **static** False > C++ defination code: > ```cpp > int value() > ``` #### l\\_value ```python def l_value(self) > int ``` Return the l channel threshold value of lab format (between 0 and 100). item description **type** func **return** returns l channel percentile value **static** False > C++ defination code: > ```cpp > int l_value() > ``` #### a\\_value ```python def a_value(self) > int ``` Return the a channel threshold value of lab format (between 128 and 127). item description **type** func **return** returns a channel percentile value **static** False > C++ defination code: > ```cpp > int a_value() > ``` #### b\\_value ```python def b_value(self) > int ``` Return the b channel threshold value of lab format (between 128 and 127). item description **type** func **return** returns b channel percentile value **static** False > C++ defination code: > ```cpp > int b_value() > ``` ### Histogram Histogram class > C++ defination code: > ```cpp > class Histogram > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, l_bin: list[float], a_bin: list[float], b_bin: list[float], format: Format ...) > None ``` Histogram constructor item description **type** func **param** **l_value**: for grayscale image, it is grayscale threshold value list (the range of element values in the list is 0 and 255).<br>for rgb888 image, it is l channel threshold value list of lab (the range of element values in the list is 0 and 100).<br>**a_value**: for rgb888 image, it is a channel threshold value list of lab format(the range of element values in the list is 128 and 127).<br>**b_value**: for rgb888 image, it is b channel threshold value list of lab format(the range of element values in the list is 128 and 127).<br>**format**: format of the source image<br> **static** False > C++ defination code: > ```cpp > Histogram(std::vector<float> l_bin, std::vector<float> a_bin, std::vector<float> b_bin, image::Format format image::Format::FMT_RGB888) > ``` #### \\_\\_getitem\\_\\_ ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### bins ```python def bins(self) > list[float] ``` Returns a list of floats for the grayscale histogram. item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<float> bins() > ``` #### l\\_bins ```python def l_bins(self) > list[float] ``` Returns a list of floats for the RGB565 histogram LAB L channel. item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<float> l_bins() > ``` #### a\\_bins ```python def a_bins(self) > list[float] ``` Returns a list of floats for the RGB565 histogram LAB A channel. item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<float> a_bins() > ``` #### b\\_bins ```python def b_bins(self) > list[float] ``` Returns a list of floats for the RGB565 histogram LAB B channel. item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<float> b_bins() > ``` #### get\\_percentile ```python def get_percentile(self, percentile: float) > Percentile ``` Computes the CDF of the histogram channels and returns a image::Percentile object item description **type** func **param** **percentile**: the values of the histogram at the passed in percentile (0.0 1.0) (float).<br>So, if you pass in 0.1 this method will tell you (going from left to right in the histogram)<br>what bin when summed into an accumulator caused the accumulator to cross 0.1. This is useful<br>to determine min (with 0.1) and max (with 0.9) of a color distribution without outlier effects<br>ruining your results for adaptive color tracking.<br> **return** image::Percentile object **static** False > C++ defination code: > ```cpp > image::Percentile get_percentile(float percentile) > ``` #### get\\_threshold ```python def get_threshold(self) > Threshold ``` Uses Otsu’s Method to compute the optimal threshold values that split the histogram into two halves for each channel of the histogram and returns a image::Threshold object. item description **type** func **return** image::Threshold object **static** False > C++ defination code: > ```cpp > image::Threshold get_threshold() > ``` #### get\\_statistics ```python def get_statistics(self) > Statistics ``` Computes the mean, median, mode, standard deviation, min, max, lower quartile, and upper quartile of each color channel in the histogram and returns a image::Statistics object. item description **type** func **return** image::Statistics object **static** False > C++ defination code: > ```cpp > image::Statistics get_statistics() > ``` ### LBPKeyPoint LBPKeyPoint class > C++ defination code: > ```cpp > class LBPKeyPoint > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, data: list[int]) > None ``` LBPKeyPoint constructor item description **type** func **param** **data**: The data of the LBPKeyPoint<br> **static** False > C++ defination code: > ```cpp > LBPKeyPoint(std::valarray<uint8_t> &data) > ``` ### KeyPoint KeyPoint class > C++ defination code: > ```cpp > class KeyPoint > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, x: int, y: int, score: int, octave: int, angle: int, matched: int, desc: list[int]) > None ``` KeyPoint constructor item description **type** func **param** **x**: The x of the KeyPoint<br>**y**: The y of the KeyPoint<br>**score**: The score of the KeyPoint<br>**octave**: The octave of the KeyPoint<br>**angle**: The angle of the KeyPoint<br>**matched**: The matched of the KeyPoint<br>**desc**: The desc of the KeyPoint<br> **static** False > C++ defination code: > ```cpp > KeyPoint(uint16_t x, uint16_t y, uint16_t score, uint16_t octave, uint16_t angle, uint16_t matched, std::vector<uint8_t> &desc) > ``` ### KPTMatch KPTMatch class > C++ defination code: > ```cpp > class KPTMatch > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, cx: int, cy: int, x: int, y: int, w: int, h: int, score: int, theta: int, match: int) > None ``` KPTMatch constructor item description **type** func **param** **cx**: The cx of the KPTMatch<br>**cy**: The cy of the KPTMatch<br>**x**: The x of the KPTMatch<br>**y**: The y of the KPTMatch<br>**w**: The w of the KPTMatch<br>**h**: The h of the KPTMatch<br>**score**: The score of the KPTMatch<br>**theta**: The theta of the KPTMatch<br>**match**: The match of the KPTMatch<br> **static** False > C++ defination code: > ```cpp > KPTMatch(int cx, int cy, int x, int y, int w, int h, int score, int theta, int match) > ``` ### ORBKeyPoint ORBKeyPoint class > C++ defination code: > ```cpp > class ORBKeyPoint > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, data: list[KeyPoint], threshold: int, normalized: bool) > None ``` ORBKeyPoint constructor item description **type** func **param** **data**: The data of the ORBKeyPoint<br>**threshold**: The threshold of the ORBKeyPoint<br>**normalized**: The normalized of the ORBKeyPoint<br> **static** False > C++ defination code: > ```cpp > ORBKeyPoint(std::vector<image::KeyPoint> &data, int threshold, bool normalized) > ``` #### get\\_data ```python def get_data(self) > list[KeyPoint] ``` get data of ORBKeyPoint item description **type** func **return** return data of the ORBKeyPoint, type is std::vector<KeyPoint> **static** False > C++ defination code: > ```cpp > std::vector<image::KeyPoint> get_data() > ``` ### HaarCascade HaarCascade class > C++ defination code: > ```cpp > class HaarCascade > ``` #### \\_\\_init\\_\\_ ```python def __init__(self) > None ``` HaarCascade constructor item description **type** func **param** **data**: The data of the HaarCascade<br>**threshold**: The threshold of the HaarCascade<br>**normalized**: The normalized of the HaarCascade<br> **static** False > C++ defination code: > ```cpp > HaarCascade() > ``` ### Color Color class > C++ defination code: > ```cpp > class Color > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, ch1: int, ch2: int 0, ch3: int 0, alpha: float 0, format: Format ...) > None ``` Color constructor item description **type** func **param** **alpha**: alpha channel, value range: 0 ~ 1<br> **static** False > C++ defination code: > ```cpp > Color(uint8_t ch1, uint8_t ch2 0, uint8_t ch3 0, float alpha 0, image::Format format image::FMT_GRAYSCALE) > ``` #### r Color red channel item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > uint8_t r > ``` #### g Color green channel item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > uint8_t g > ``` #### b Color blue channel item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > uint8_t b > ``` #### alpha Color alpha channel, value from 0.0 to 1.0, float value item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float alpha > ``` #### gray Color gray channel item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > uint8_t gray > ``` #### format Color format item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > image::Format format > ``` #### hex ```python def hex(self) > int ``` Get color's hex value item description **type** func **static** False > C++ defination code: > ```cpp > uint32_t hex() > ``` #### from\\_rgb ```python def from_rgb(r: int, g: int, b: int) > Color ``` Create Color object from RGB channels item description **type** func **static** True > C++ defination code: > ```cpp > static image::Color from_rgb(uint8_t r, uint8_t g, uint8_t b) > ``` #### from\\_bgr ```python def from_bgr(b: int, g: int, r: int) > Color ``` Create Color object from BGR channels item description **type** func **static** True > C++ defination code: > ```cpp > static image::Color from_bgr(uint8_t b, uint8_t g, uint8_t r) > ``` #### from\\_gray ```python def from_gray(gray: int) > Color ``` Create Color object from gray channel item description **type** func **static** True > C++ defination code: > ```cpp > static image::Color from_gray(uint8_t gray) > ``` #### from\\_rgba ```python def from_rgba(r: int, g: int, b: int, alpha: float) > Color ``` Create Color object from RGBA channels item description **type** func **param** **alpha**: alpha channel, float value, value range: 0 ~ 1<br> **static** True > C++ defination code: > ```cpp > static image::Color from_rgba(uint8_t r, uint8_t g, uint8_t b, float alpha) > ``` #### from\\_bgra ```python def from_bgra(b: int, g: int, r: int, alpha: float) > Color ``` Create Color object from BGRA channels item description **type** func **param** **alpha**: alpha channel, float value, value range: 0 ~ 1<br> **static** True > C++ defination code: > ```cpp > static image::Color from_bgra(uint8_t b, uint8_t g, uint8_t r, float alpha) > ``` #### from\\_hex ```python def from_hex(hex: int, format: Format) > Color ``` Create Color object from hex value item description **type** func **param** **hex**: hex value, e.g. 0x0000FF00, lower address if first channel<br>**format**: color format, @see image::Format<br> **static** True > C++ defination code: > ```cpp > static image::Color from_hex(uint32_t hex, image::Format &format) > ``` #### to\\_format ```python def to_format(self, format: Format) > None ``` Convert Color format item description **type** func **param** **format**: format want to convert to, @see image::Format, only support RGB888, BGR888, RGBA8888, BGRA8888, GRAYSCALE.<br> **static** False > C++ defination code: > ```cpp > void to_format(const image::Format &format) > ``` #### to\\_format2 ```python def to_format2(self, format: Format) > Color ``` Convert color format and return a new Color object item description **type** func **param** **format**: format want to convert to, @see image::Format, only support RGB888, BGR888, RGBA8888, BGRA8888, GRAYSCALE.<br> **return** new Color object, you need to delete it manually in C++. **static** False > C++ defination code: > ```cpp > image::Color *to_format2(const image::Format &format) > ``` ### Image Image class > C++ defination code: > ```cpp > class Image > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, width: int, height: int, format: Format ...) > None ``` Image constructor item description **type** func **param** **width**: image width, should > 0<br>**height**: image height, should > 0<br>**format**: image format @see image::Format<br> **static** False > C++ defination code: > ```cpp > Image(int width, int height, image::Format format image::Format::FMT_RGB888) > ``` #### format ```python def format(self) > Format ``` Get image's format item description **type** func **see** image.Format **static** False > C++ defination code: > ```cpp > image::Format format() > ``` #### size ```python def size(self) > Size ``` Get image's size, [width, height] item description **type** func **static** False > C++ defination code: > ```cpp > image::Size size() > ``` #### data\\_size ```python def data_size(self) > int ``` Get image's data size item description **type** func **static** False > C++ defination code: > ```cpp > int data_size() > ``` #### width ```python def width(self) > int ``` Get image's width item description **type** func **static** False > C++ defination code: > ```cpp > int width() > ``` #### height ```python def height(self) > int ``` Get image's height item description **type** func **static** False > C++ defination code: > ```cpp > int height() > ``` #### data ```python def data(self) > capsule ``` Get image's data pointer.\\nIn MaixPy is capsule object. item description **type** func **static** False > C++ defination code: > ```cpp > void *data() > ``` #### \\_\\_str\\_\\_ ```python def __str__(self) > str ``` To string method item description **type** func **static** False > C++ defination code: > ```cpp > std::string __str__() > ``` #### to\\_str ```python def to_str(self) > str ``` To string method item description **type** func **static** False > C++ defination code: > ```cpp > std::string to_str() > ``` #### get\\_pixel ```python def get_pixel(self, x: int, y: int, rgbtuple: bool False) > list[int] ``` Get pixel of image item description **type** func **param** **x**: pixel's coordinate x. x must less than image's width<br>**y**: pixel's coordinate y. y must less than image's height<br>**rgbtuple**: switch return value method. rgbtuple decides whether to split the return or not. default is false.<br> **return** pixel value,<br>According to image format and rgbtuple, return different value:<br>format is FMT_RGB888, rgbtuple is true, return [R, G, B]; rgbtuple is false, return [RGB]<br>foramt is FMT_BGR888, rgbtuple is true, return [B, G, R]; rgbtuple is false, return [BGR]<br>format is FMT_GRAYSCALE, return [GRAY]; **static** False > C++ defination code: > ```cpp > std::vector<int> get_pixel(int x, int y, bool rgbtuple false) > ``` #### set\\_pixel ```python def set_pixel(self, x: int, y: int, pixel: list[int]) > maix.err.Err ``` Set pixel of image item description **type** func **param** **x**: pixel's coordinate x. x must less than image's width<br>**y**: pixel's coordinate y. y must less than image's height<br>**pixel**: pixel value, according to image format and size of pixel, has different operation:<br>format is FMT_RGB888, pixel size must be 1 or 3, if size is 1, will split pixel[0] to [R, G, B]; if size is 3, will use pixel directly<br>format is FMT_BGR888, pixel size must be 1 or 3, if size is 1, will split pixel[0] to [B, G, R]; if size is 3, will use pixel directly<br>format is FMT_GRAYSCALE, pixel size must be 1, will use pixel directly<br> **return** error code, Err::ERR_NONE is ok, other is error **static** False > C++ defination code: > ```cpp > err::Err set_pixel(int x, int y, std::vector<int> pixel) > ``` #### to\\_tensor ```python def to_tensor(self, chw: bool False, copy: bool True) > maix.tensor.Tensor ``` Convert Image object to tensor::Tensor object item description **type** func **param** **chw**: if true, the shape of tensor is [C, H, W], else [H, W, C]<br>**copy**: if true, will alloc memory for tensor data, else will use the memory of Image object<br> **return** tensor::Tensor object pointer, an allocated tensor object **static** False > C++ defination code: > ```cpp > tensor::Tensor *to_tensor(bool chw false, bool copy true) > ``` #### to\\_bytes ```python def to_bytes(*args, **kwargs) ``` Get image's data and convert to array bytes item description **type** func **param** **copy**: if true, will alloc memory and copy data to new buffer,<br>else will use the memory of Image object, delete bytes object will not affect Image object，<br>but delete Image object will make bytes object invalid, it may cause program crash !!!!<br>So use this param carefully.<br> **return** image's data bytes, need be delete by caller in C++. **static** False > C++ defination code: > ```cpp > Bytes *to_bytes(bool copy true) > ``` #### to\\_format ```python def to_format(self, format: Format) > Image ``` Convert image to specific format item description **type** func **param** **format**: format want to convert to, @see image::Format, only support RGB888, BGR888, RGBA8888, BGRA8888, GRAYSCALE, JPEG.<br> **return** new image object. Need be delete by caller in C++. **throw** err.Exception, if two images' format not support, **or already the format**, will raise exception **static** False > C++ defination code: > ```cpp > image::Image *to_format(const image::Format &format) > ``` #### to\\_jpeg ```python def to_jpeg(self, quality: int 95) > Image ``` Convert image to jpeg item description **type** func **param** **quality**: the quality of jpg, default is 95. For MaixCAM supported range is (50, 100], if < 50 will be fixed to 51.<br> **return** new image object. Need be delete by caller in C++. **throw** err.Exception, if two images' format not support, **or already the format**, will raise exception **static** False > C++ defination code: > ```cpp > image::Image *to_jpeg(int quality 95) > ``` #### draw\\_image ```python def draw_image(self, x: int, y: int, img: Image) > Image ``` Draw image on this image item description **type** func **param** **x**: left top corner of image point's coordinate x<br>**y**: left top corner of image point's coordinate y<br>**img**: image object to draw, the caller's channel must < the args' channel,<br>e.g. caller is RGB888, args is RGBA8888, will throw exception, but caller is RGBA8888, args is RGB888 or RGBA8888 is ok<br> **return** this image object self **static** False > C++ defination code: > ```cpp > image::Image *draw_image(int x, int y, image::Image &img) > ``` #### draw\\_rect ```python def draw_rect(self, x: int, y: int, w: int, h: int, color: Color, thickness: int 1) > Image ``` Fill rectangle color to image item description **type** func **param** **x**: left top corner of rectangle point's coordinate x<br>**y**: left top corner of rectangle point's coordinate y<br>**w**: rectangle width<br>**h**: rectangle height<br>**color**: rectangle color<br>**thickness**: rectangle thickness(line width), by default(value is 1), 1 means fill rectangle<br> **return** this image object self **static** False > C++ defination code: > ```cpp > image::Image *draw_rect(int x, int y, int w, int h, const image::Color &color, int thickness 1) > ``` #### draw\\_line ```python def draw_line(self, x1: int, y1: int, x2: int, y2: int, color: Color, thickness: int 1) > Image ``` Draw line on image item description **type** func **param** **x1**: start point's coordinate x<br>**y1**: start point's coordinate y<br>**x2**: end point's coordinate x<br>**y2**: end point's coordinate y<br>**color**: line color @see image::Color<br>**thickness**: line thickness(line width), by default(value is 1)<br> **return** this image object self **static** False > C++ defination code: > ```cpp > image::Image *draw_line(int x1, int y1, int x2, int y2, const image::Color &color, int thickness 1) > ``` #### draw\\_circle ```python def draw_circle(self, x: int, y: int, radius: int, color: Color, thickness: int 1) > Image ``` Draw circle on image item description **type** func **param** **x**: circle center point's coordinate x<br>**y**: circle center point's coordinate y<br>**radius**: circle radius<br>**color**: circle color @see image::Color<br>**thickness**: circle thickness(line width), default 1 means fill circle<br> **return** this image object self **static** False > C++ defination code: > ```cpp > image::Image *draw_circle(int x, int y, int radius, const image::Color &color, int thickness 1) > ``` #### draw\\_ellipse ```python def draw_ellipse(self, x: int, y: int, a: int, b: int, angle: float, start_angle: float, end_angle: float, color: Color, thickness: int 1) > Image ``` Draw ellipse on image item description **type** func **param** **x**: ellipse center point's coordinate x<br>**y**: ellipse center point's coordinate y<br>**a**: ellipse major axis length<br>**b**: ellipse minor axis length<br>**angle**: ellipse rotation angle<br>**start_angle**: ellipse start angle<br>**end_angle**: ellipse end angle<br>**color**: ellipse color @see image::Color<br>**thickness**: ellipse thickness(line width), by default(value is 1), 1 means fill ellipse<br> **return** this image object self **static** False > C++ defination code: > ```cpp > image::Image *draw_ellipse(int x, int y, int a, int b, float angle, float start_angle, float end_angle, const image::Color &color, int thickness 1) > ``` #### draw\\_string ```python def draw_string(self, x: int, y: int, textstring: str, color: Color ..., scale: float 1, thickness: int 1, wrap: bool True, wrap_space: int 4, font: str '') > Image ``` Draw text on image item description **type** func **param** **x**: text left top point's coordinate x<br>**y**: text left top point's coordinate y<br>**string**: text content<br>**color**: text color @see image::Color, default is white<br>**scale**: font scale, by default(value is 1)<br>**thickness**: text thickness(line width), if negative, the glyph is filled, by default(value is 1)<br>**wrap**: if true, will auto wrap text to next line if text width > image width, by default(value is true)<br> **return** this image object self **static** False > C++ defination code: > ```cpp > image::Image *draw_string(int x, int y, const std::string &textstring, const image::Color &color image::COLOR_WHITE, float scale 1, int thickness 1, > bool wrap true, int wrap_space 4, const std::string &font \"\") > ``` #### draw\\_cross ```python def draw_cross(self, x: int, y: int, color: Color, size: int 5, thickness: int 1) > Image ``` Draw cross on image item description **type** func **param** **x**: cross center point's coordinate x<br>**y**: cross center point's coordinate y<br>**color**: cross color @see image::Color<br>**size**: how long the lines of the cross extend, by default(value is 5). So the line length is `2 * size + thickness`<br>**thickness**: cross thickness(line width), by default(value is 1)<br> **static** False > C++ defination code: > ```cpp > image::Image *draw_cross(int x, int y, const image::Color &color, int size 5, int thickness 1) > ``` #### draw\\_arrow ```python def draw_arrow(self, x0: int, y0: int, x1: int, y1: int, color: Color, thickness: int 1) > Image ``` Draw arrow on image item description **type** func **param** **x0**: start coordinate of the arrow x0<br>**y0**: start coordinate of the arrow y0<br>**x1**: end coordinate of the arrow x1<br>**y1**: end coordinate of the arrow y1<br>**color**: cross color @see image::Color<br>**thickness**: cross thickness(line width), by default(value is 1)<br> **return** this image object self **static** False > C++ defination code: > ```cpp > image::Image *draw_arrow(int x0, int y0, int x1, int y1, const image::Color &color, int thickness 1) > ``` #### draw\\_edges ```python def draw_edges(self, corners: list[list[int]], color: Color, size: int 0, thickness: int 1, fill: bool False) > Image ``` Draw edges on image item description **type** func **param** **corners**: edges, [[x0, y0], [x1, y1], [x2, y2], [x3, y3]]<br>**color**: edges color @see image::Color<br>**size**: the circle of radius size. TODO: support in the feature<br>**thickness**: edges thickness(line width), by default(value is 1)<br>**fill**: if true, will fill edges, by default(value is false)<br> **return** this image object self **static** False > C++ defination code: > ```cpp > image::Image *draw_edges(std::vector<std::vector<int>> corners, const image::Color &color, int size 0, int thickness 1, bool fill false) > ``` #### draw\\_keypoints ```python def draw_keypoints(self, keypoints: list[int], color: Color, size: int 4, thickness: int 1, line_thickness: int 0) > Image ``` Draw keypoints on image item description **type** func **param** **keypoints**: keypoints, [x1, y1, x2, y2...] or [x, y, rotation_andle_in_degrees, x2, y2, rotation_andle_in_degrees2](TODO: rotation_andle_in_degrees support in the feature)<br>**color**: keypoints color @see image::Color<br>**size**: size of keypoints(radius)<br>**thickness**: keypoints thickness(line width), by default(value is 1 means fill circle)<br>**line_thickness**: line thickness, default 0 means not draw lines, > 0 will draw lines connect points.<br> **return** this image object self **static** False > C++ defination code: > ```cpp > image::Image *draw_keypoints(const std::vector<int> &keypoints, const image::Color &color, int size 4, int thickness 1, int line_thickness 0) > ``` #### resize ```python def resize(self, width: int, height: int, object_fit: Fit ..., method: ResizeMethod ...) > Image ``` Resize image, will create a new resized image object item description **type** func **param** **width**: new width, if value is 1, will use height to calculate aspect ratio<br>**height**: new height, if value is 1, will use width to calculate aspect ratio<br>**object_fit**: fill, contain, cover, by default is fill<br>**method**: resize method, by default is bilinear<br> **return** Always return a new resized image object even size not change, So in C++ you should take care of the return value to avoid memory leak.<br>And it's better to judge whether the size has changed before calling this function to make the program more efficient.<br>e.g.<br>if img >width() ! width img >height() ! height:<br>img img >resize(width, height); **static** False > C++ defination code: > ```cpp > image::Image *resize(int width, int height, image::Fit object_fit image::Fit::FIT_FILL, image::ResizeMethod method image::ResizeMethod::NEAREST) > ``` #### affine ```python def affine(self, src_points: list[int], dst_points: list[int], width: int 1, height: int 1, method: ResizeMethod ...) > Image ``` Affine transform image, will create a new transformed image object item description **type** func **param** **src_points**: three source points, [x1, y1, x2, y2, x3, y3]<br>**dst_points**: three destination points, [x1, y1, x2, y2, x3, y3]<br>**width**: new width, if value is 1, will use height to calculate aspect ratio<br>**height**: new height, if value is 1, will use width to calculate aspect ratio<br>**method**: resize method, by default is bilinear<br> **return** new transformed image object **static** False > C++ defination code: > ```cpp > image::Image *affine(std::vector<int> src_points, std::vector<int> dst_points, int width 1, int height 1, image::ResizeMethod method image::ResizeMethod::BILINEAR) > ``` #### copy ```python def copy(self) > Image ``` Copy image, will create a new copied image object item description **type** func **return** new copied image object **static** False > C++ defination code: > ```cpp > image::Image *copy() > ``` #### crop ```python def crop(self, x: int, y: int, w: int, h: int) > Image ``` Crop image, will create a new cropped image object item description **type** func **param** **x**: left top corner of crop rectangle point's coordinate x<br>**y**: left top corner of crop rectangle point's coordinate y<br>**w**: crop rectangle width<br>**h**: crop rectangle height<br> **return** new cropped image object **static** False > C++ defination code: > ```cpp > image::Image *crop(int x, int y, int w, int h) > ``` #### rotate ```python def rotate(self, angle: float, width: int 1, height: int 1, method: ResizeMethod ...) > Image ``` Rotate image, will create a new rotated image object item description **type** func **param** **angle**: anti clock wise rotate angle, if angle is 90 or 270, and width or height is 1, will swap width and height, or will throw exception<br>**width**: new width, if value is 1, will use height to calculate aspect ratio<br>**height**: new height, if value is 1, will use width to calculate aspect ratio<br>**method**: resize method, by default is bilinear<br> **return** new rotated image object **static** False > C++ defination code: > ```cpp > image::Image *rotate(float angle, int width 1, int height 1, image::ResizeMethod method image::ResizeMethod::BILINEAR) > ``` #### mean\\_pool ```python def mean_pool(self, x_div: int, y_div: int, copy: bool False) > Image ``` Finds the mean of x_div * y_div squares in the image and returns the modified image composed of the mean of each square. item description **type** func **param** **x_div**: The width of the squares.<br>**y_div**: The height of the squares.<br>**copy**: Select whether to return a new image or modify the original image. default is false.<br>If true, returns a new image composed of the mean of each square; If false, returns the modified image composed of the mean of each square.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *mean_pool(int x_div, int y_div, bool copy false) > ``` #### midpoint\\_pool ```python def midpoint_pool(self, x_div: int, y_div: int, bias: float 0.5, copy: bool False) > Image ``` Finds the midpoint of x_div * y_div squares in the image and returns the modified image composed of the mean of each square. item description **type** func **param** **x_div**: The width of the squares.<br>**y_div**: The height of the squares.<br>**bias**: The bias of the midpoint. default is 0.5.<br>midpoint value is equal to (max * bias + min * (1 bias))<br>**copy**: Select whether to return a new image or modify the original image. default is false.<br>If true, returns a new image composed of the midpoint of each square; If false, returns the modified image composed of the midpoint of each square.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *midpoint_pool(int x_div, int y_div, double bias 0.5, bool copy false) > ``` #### compress ```python def compress(self, quality: int 95) > Image ``` JPEG compresses the image in place, the same as to_jpeg functioin, it's recommend to use to_jpeg instead. item description **type** func **param** **quality**: The quality of the compressed image. default is 95.<br> **return** Returns the compressed JPEG image **static** False > C++ defination code: > ```cpp > image::Image *compress(int quality 95) > ``` #### clear ```python def clear(self, mask: Image None) > Image ``` Sets all pixels in the image to zero item description **type** func **param** **mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *clear(image::Image *mask nullptr) > ``` #### mask\\_rectange ```python def mask_rectange(self, x: int 1, y: int 1, w: int 1, h: int 1) > Image ``` Zeros a rectangular part of the image. If no arguments are supplied this method zeros the center of the image. item description **type** func **param** **x**: The x coordinate of the top left corner of the rectangle.<br>**y**: The y coordinate of the top left corner of the rectangle.<br>**w**: The width of the rectangle.<br>**h**: The height of the rectangle.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *mask_rectange(int x 1, int y 1, int w 1, int h 1) > ``` #### mask\\_circle ```python def mask_circle(self, x: int 1, y: int 1, radius: int 1) > Image ``` Zeros a circular part of the image. If no arguments are supplied this method zeros the center of the image. item description **type** func **param** **x**: The x coordinate of the center of the circle.<br>**y**: The y coordinate of the center of the circle.<br>**radius**: The radius of the circle.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *mask_circle(int x 1, int y 1, int radius 1) > ``` #### mask\\_ellipse ```python def mask_ellipse(self, x: int 1, y: int 1, radius_x: int 1, radius_y: int 1, rotation_angle_in_degrees: float 0) > Image ``` Zeros a ellipse part of the image. If no arguments are supplied this method zeros the center of the image. item description **type** func **param** **x**: The x coordinate of the center of the ellipse.<br>**y**: The y coordinate of the center of the ellipse.<br>**radius_x**: The radius of the ellipse in the x direction.<br>**radius_y**: The radius of the ellipse in the y direction.<br>**rotation_angle_in_degrees**: The rotation angle of the ellipse in degrees.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *mask_ellipse(int x 1, int y 1, int radius_x 1, int radius_y 1, float rotation_angle_in_degrees 0) > ``` #### binary ```python def binary(self, thresholds: list[list[int]] [], invert: bool False, zero: bool False, mask: Image None, to_bitmap: bool False, copy: bool False) > Image ``` Sets all pixels in the image to black or white depending on if the pixel is inside of a threshold in the threshold list thresholds or not. item description **type** func **note** For GRAYSCALE format, Lmin and Lmax range is [0, 255]. For RGB888 format, Lmin and Lmax range is [0, 100]. **param** **thresholds**: You can define multiple thresholds.<br>For GRAYSCALE format, you can use {{Lmin, Lmax}, ...} to define one or more thresholds.<br>For RGB888 format, you can use {{Lmin, Lmax, Amin, Amax, Bmin, Bmax}, ...} to define one or more thresholds.<br>Where the upper case L,A,B represent the L,A,B channels of the LAB image format, and min, max represent the minimum and maximum values of the corresponding channels.<br>**invert**: If true, the thresholds will be inverted before the operation. default is false.<br>**zero**: If zero is true, the image will be set the pixels within the threshold to 0, other pixels remain unchanged. If zero is false, the image will be set to black or white. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br>**to_bitmap**: If true, the image will be converted to a bitmap image before thresholding. default is false. TODO: support in the feature<br>**copy**: Select whether to return a new image or modify the original image. default is false.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *binary(std::vector<std::vector<int>> thresholds std::vector<std::vector<int>>(), bool invert false, bool zero false, image::Image *mask nullptr, bool to_bitmap false, bool copy false) > ``` #### invert ```python def invert(self) > Image ``` Inverts the image in place. item description **type** func **return** Returns the image after the operation is completed **static** False > C++ defination code: > ```cpp > image::Image *invert() > ``` #### b\\_and ```python def b_and(self, other: Image, mask: Image None) > Image ``` Performs a bitwise and operation between the image and the other image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *b_and(image::Image *other, image::Image *mask nullptr) > ``` #### b\\_nand ```python def b_nand(self, other: Image, mask: Image None) > Image ``` Performs a bitwise nand operation between the image and the other image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *b_nand(image::Image *other, image::Image *mask nullptr) > ``` #### b\\_or ```python def b_or(self, other: Image, mask: Image None) > Image ``` Performs a bitwise or operation between the image and the other image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *b_or(image::Image *other, image::Image *mask nullptr) > ``` #### b\\_nor ```python def b_nor(self, other: Image, mask: Image None) > Image ``` Performs a bitwise nor operation between the image and the other image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *b_nor(image::Image *other, image::Image *mask nullptr) > ``` #### b\\_xor ```python def b_xor(self, other: Image, mask: Image None) > Image ``` Performs a bitwise xor operation between the image and the other image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *b_xor(image::Image *other, image::Image *mask nullptr) > ``` #### b\\_xnor ```python def b_xnor(self, other: Image, mask: Image None) > Image ``` Performs a bitwise xnor operation between the image and the other image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *b_xnor(image::Image *other, image::Image *mask nullptr) > ``` #### awb ```python def awb(self, max: bool False) > Image ``` Performs an auto white balance operation on the image. TODO: support in the feature item description **type** func **param** **max**: if True uses the white patch algorithm instead. default is false.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *awb(bool max false) > ``` #### ccm ```python def ccm(self, matrix: list[float]) > Image ``` Multiples the passed (3x3) or (4x3) floating point color correction matrix with the image.\\nnote: Grayscale format is not support. item description **type** func **param** **matrix**: The color correction matrix to use. 3x3 or 4x3 matrix.<br>Weights may either be positive or negative, and the sum of each column in the 3x3 matrix should generally be 1.<br>example:<br>{<br>1, 0, 0,<br>0, 1, 0,<br>0, 0, 1,<br>}<br>Where the last row of the 4x3 matrix is an offset per color channel. If you add an offset you may wish to make the<br>weights sum to less than 1 to account for the offset.<br>example:<br>{<br>1, 0, 0,<br>0, 1, 0,<br>0, 0, 1,<br>0, 0, 0,<br>}<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *ccm(std::vector<float> &matrix) > ``` #### gamma ```python def gamma(self, gamma: float 1.0, contrast: float 1.0, brightness: float 0.0) > Image ``` Quickly changes the image gamma, contrast, and brightness. Create a array whose size is usually 255,\\nand use the parameters gamma, contrast, and brightness to calculate the value of the array, and then map the\\nimage pixel value through the value of the array.\\nThe calculation method for array is: array[array_idx] (powf((array_idx / 255.0), (1 / gamma)) * contrast + brightness) * scale,\\n`powf` is a function used to calculate floating point power.\\n`array` is the array used for mapping.\\n`array_idx` is the index of the array, the maximum value is determined according to the image format, usually 255.\\n`scale` is a constant, the value is determined by the image format, usually 255.\\nMapping method:\\nAssume that a pixel value in the image is 128, then map the pixel value to the value of array[128]\\nUsers can adjust the value of the array through the gamma, contrast, and brightness parameters. item description **type** func **param** **gamma**: The contrast gamma greater than 1.0 makes the image darker in a non linear manner while less than 1.0 makes the image brighter. default is 1.0.<br>**contrast**: The contrast value greater than 1.0 makes the image brighter in a linear manner while less than 1.0 makes the image darker. default is 1.0.<br>**brightness**: The brightness value greater than 0.0 makes the image brighter in a constant manner while less than 0.0 makes the image darker. default is 0.0.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *gamma(double gamma 1.0, double contrast 1.0, double brightness 0.0) > ``` #### gamma\\_corr ```python def gamma_corr(self, gamma: float, contrast: float 1.0, brightness: float 0.0) > Image ``` Alias for Image.gamma. item description **type** func **param** **gamma**: The contrast gamma greater than 1.0 makes the image darker in a non linear manner while less than 1.0 makes the image brighter. default is 1.0.<br>**contrast**: The contrast value greater than 1.0 makes the image brighter in a linear manner while less than 1.0 makes the image darker. default is 1.0.<br>**brightness**: The brightness value greater than 0.0 makes the image brighter in a constant manner while less than 0.0 makes the image darker. default is 0.0.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *gamma_corr(double gamma, double contrast 1.0, double brightness 0.0) > ``` #### negate ```python def negate(self) > Image ``` Flips (numerically inverts) all pixels values in an image item description **type** func **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *negate() > ``` #### replace ```python def replace(self, other: Image None, hmirror: bool False, vflip: bool False, transpose: bool False, mask: Image None) > Image ``` Replaces all pixels in the image with the corresponding pixels in the other image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on.<br>**hmirror**: If true, the image will be horizontally mirrored before the operation. default is false.<br>**vflip**: If true, the image will be vertically flipped before the operation. default is false.<br>**transpose**: If true, the image can be used to rotate 90 degrees or 270 degrees.<br>hmirror false, vflip false, transpose false, the image will not be rotated.<br>hmirror false, vflip true, transpose true, the image will be rotated 90 degrees.<br>hmirror true, vflip true, transpose false, the image will be rotated 180 degrees.<br>hmirror true, vflip false, transpose true, the image will be rotated 270 degrees.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *replace(image::Image *other nullptr, bool hmirror false, bool vflip false, bool transpose false, image::Image *mask nullptr) > ``` #### set ```python def set(self, other: Image, hmirror: bool False, vflip: bool False, transpose: bool False, mask: Image None) > Image ``` Alias for Image::replace. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on.<br>**hmirror**: If true, the image will be horizontally mirrored before the operation. default is false.<br>**vflip**: If true, the image will be vertically flipped before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *set(image::Image *other, bool hmirror false, bool vflip false, bool transpose false, image::Image *mask nullptr) > ``` #### add ```python def add(self, other: Image, mask: Image None) > Image ``` Adds the other image to the image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *add(image::Image *other, image::Image *mask nullptr) > ``` #### sub ```python def sub(self, other: Image, reverse: bool False, mask: Image None) > Image ``` Subtracts the other image from the image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**reverse**: If true, the image will be reversed before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *sub(image::Image *other, bool reverse false, image::Image *mask nullptr) > ``` #### mul ```python def mul(self, other: Image, invert: bool False, mask: Image None) > Image ``` Multiplies the image by the other image.\\nNote: This method is meant for image blending and cannot multiply the pixels in the image by a scalar like 2. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**invert**: If true, the image will be change the multiplication operation from a*b to 1/((1/a)*(1/b)).<br>In particular, this lightens the image instead of darkening it (e.g. multiply versus burn operations). default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *mul(image::Image *other, bool invert false, image::Image *mask nullptr) > ``` #### div ```python def div(self, other: Image, invert: bool False, mod: bool False, mask: Image None) > Image ``` Divides the image by the other image.\\nThis method is meant for image blending and cannot divide the pixels in the image by a scalar like 2. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**invert**: If true, the image will be change the division direction from a/b to b/a. default is false.<br>**mod**: If true, the image will be change the division operation to the modulus operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *div(image::Image *other, bool invert false, bool mod false, image::Image *mask nullptr) > ``` #### min ```python def min(self, other: Image, mask: Image None) > Image ``` Caculate the minimum of each pixel in the image and the other image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *min(image::Image *other, image::Image *mask nullptr) > ``` #### max ```python def max(self, other: Image, mask: Image None) > Image ``` Caculate the maximum of each pixel in the image and the other image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *max(image::Image *other, image::Image *mask nullptr) > ``` #### difference ```python def difference(self, other: Image, mask: Image None) > Image ``` Caculate the absolute value of the difference between each pixel in the image and the other image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *difference(image::Image *other, image::Image *mask nullptr) > ``` #### blend ```python def blend(self, other: Image, alpha: int 128, mask: Image None) > Image ``` Blends the image with the other image.\\nres alpha * this_img / 256 + (256 alpha) * other_img / 256 item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on.<br>**alpha**: The alpha value of the blend, the value range is [0, 256],default is 128.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *blend(image::Image *other, int alpha 128, image::Image *mask nullptr) > ``` #### histeq ```python def histeq(self, adaptive: bool False, clip_limit: int 1, mask: Image None) > Image ``` Runs the histogram equalization algorithm on the image. item description **type** func **param** **adaptive**: If true, an adaptive histogram equalization method will be run on the image instead which as generally better results than non adaptive histogram qualization but a longer run time. default is false.<br>**clip_limit**: Provides a way to limit the contrast of the adaptive histogram qualization. Use a small value for this, like 10, to produce good histogram equalized contrast limited images. default is 1.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *histeq(bool adaptive false, int clip_limit 1, image::Image *mask nullptr) > ``` #### mean ```python def mean(self, size: int, threshold: bool False, offset: int 0, invert: bool False, mask: Image None) > Image ``` Standard mean blurring filter using a box filter.\\nThe parameters offset and invert are valid when threshold is True. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *mean(int size, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) > ``` #### median ```python def median(self, size: int, percentile: float 0.5, threshold: bool False, offset: int 0, invert: bool False, mask: Image None) > Image ``` Runs the median filter on the image. The median filter is the best filter for smoothing surfaces while preserving edges but it is very slow. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**percentile**: This parameter controls the percentile of the value used in the kernel. You can set this to 0 for a min filter, 0.25 for a lower quartile filter, 0.75 for an upper quartile filter, and 1.0 for a max filter. default is 0.5.<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *median(int size, double percentile 0.5, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) > ``` #### mode ```python def mode(self, size: int, threshold: bool False, offset: int 0, invert: bool False, mask: Image None) > Image ``` Runs the mode filter on the image by replacing each pixel with the mode of their neighbors. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *mode(int size, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) > ``` #### midpoint ```python def midpoint(self, size: int, bias: float 0.5, threshold: bool False, offset: int 0, invert: bool False, mask: Image None) > Image ``` Runs the midpoint filter on the image.This filter finds the midpoint (max * bias + min * (1 bias)) of each pixel neighborhood in the image. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**bias**: The bias of the midpoint. default is 0.5.<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *midpoint(int size, double bias 0.5, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) > ``` #### morph ```python def morph(self, size: int, kernel: list[int], mul: float 1, add: float 0.0, threshold: bool False, offset: int 0, invert: bool False, mask: Image None) > Image ``` Convolves the image by a filter kernel. This allows you to do general purpose convolutions on an image. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**kernel**: The kernel used for convolution. The kernel should be a list of lists of numbers. The kernel should be the same size as the actual kernel size.<br>**mul**: This parameter is used to multiply the convolved pixel results. default is auto.<br>**add**: This parameter is the value to be added to each convolution pixel result. default is 0.0.<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *morph(int size, std::vector<int> kernel, float mul 1, float add 0.0, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) > ``` #### gaussian ```python def gaussian(self, size: int, unsharp: bool False, mul: float 1, add: float 0.0, threshold: bool False, offset: int 0, invert: bool False, mask: Image None) > Image ``` Convolves the image by a smoothing guassian kernel. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**unsharp**: If true, this method will perform an unsharp mask operation instead of gaussian filtering operation, this improves the clarity of image edges. default is false.<br>**mul**: This parameter is used to multiply the convolved pixel results. default is auto.<br>**add**: This parameter is the value to be added to each convolution pixel result. default is 0.0.<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *gaussian(int size, bool unsharp false, float mul 1, float add 0.0, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) > ``` #### laplacian ```python def laplacian(self, size: int, sharpen: bool False, mul: float 1, add: float 0.0, threshold: bool False, offset: int 0, invert: bool False, mask: Image None) > Image ``` Convolves the image by a edge detecting laplacian kernel. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**sharpen**: If True, this method will sharpen the image instead of an unthresholded edge detection image. Then increase the kernel size to improve image clarity. default is false.<br>**mul**: This parameter is used to multiply the convolved pixel results. default is auto.<br>**add**: This parameter is the value to be added to each convolution pixel result. default is 0.0.<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *laplacian(int size, bool sharpen false, float mul 1, float add 0.0, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) > ``` #### bilateral ```python def bilateral(self, size: int, color_sigma: float 0.1, space_sigma: float 1, threshold: bool False, offset: int 0, invert: bool False, mask: Image None) > Image ``` Convolves the image by a bilateral filter. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**color_sigma**: Controls how closely colors are matched using the bilateral filter. default is 0.1.<br>**space_sigma**: Controls how closely pixels space wise are blurred with each other. default is 1.<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *bilateral(int size, double color_sigma 0.1, double space_sigma 1, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) > ``` #### linpolar ```python def linpolar(self, reverse: bool False) > Image ``` Re project’s and image from cartessian coordinates to linear polar coordinates. item description **type** func **param** **reverse**: If true, the image will be reverse polar transformed. default is false.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *linpolar(bool reverse false) > ``` #### logpolar ```python def logpolar(self, reverse: bool False) > Image ``` Re project’s and image from cartessian coordinates to log polar coordinates. item description **type** func **param** **reverse**: If true, the image will be reverse polar transformed. default is false.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *logpolar(bool reverse false) > ``` #### lens\\_corr ```python def lens_corr(self, strength: float 1.8, zoom: float 1.0, x_corr: float 0.0, y_corr: float 0.0) > Image ``` Performs a lens correction operation on the image. TODO: support in the feature item description **type** func **param** **strength**: The strength of the lens correction. default is 1.8.<br>**zoom**: The zoom of the lens correction. default is 1.0.<br>**x_corr**: The x correction of the lens correction. default is 0.0.<br>**y_corr**: The y correction of the lens correction. default is 0.0.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *lens_corr(double strength 1.8, double zoom 1.0, double x_corr 0.0, double y_corr 0.0) > ``` #### rotation\\_corr ```python def rotation_corr(self, x_rotation: float 0.0, y_rotation: float 0.0, z_rotation: float 0.0, x_translation: float 0.0, y_translation: float 0.0, zoom: float 1.0, fov: float 60.0, corners: list[float] []) > Image ``` Performs a rotation correction operation on the image. TODO: support in the feature item description **type** func **param** **x_rotation**: The x rotation of the rotation correction. default is 0.0.<br>**y_rotation**: The y rotation of the rotation correction. default is 0.0.<br>**z_rotation**: The z rotation of the rotation correction. default is 0.0.<br>**x_translation**: The x translation of the rotation correction. default is 0.0.<br>**y_translation**: The y translation of the rotation correction. default is 0.0.<br>**zoom**: The zoom of the rotation correction. default is 1.0.<br>**fov**: The fov of the rotation correction. default is 60.0.<br>**corners**: The corners of the rotation correction. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *rotation_corr(double x_rotation 0.0, double y_rotation 0.0, double z_rotation 0.0, double x_translation 0.0, double y_translation 0.0, double zoom 1.0, double fov 60.0, std::vector<float> corners std::vector<float>()) > ``` #### get\\_histogram ```python def get_histogram(self, thresholds: list[list[int]] [], invert: bool False, roi: list[int] [], bins: int 1, l_bins: int 100, a_bins: int 256, b_bins: int 256, difference: Image None) > Histogram ``` Computes the normalized histogram on all color channels and returns a image::Histogram object. item description **type** func **note** For GRAYSCALE format, Lmin and Lmax range is [0, 255]. For RGB888 format, Lmin and Lmax range is [0, 100]. **param** **thresholds**: You can define multiple thresholds.<br>For GRAYSCALE format, you can use {{Lmin, Lmax}, ...} to define one or more thresholds.<br>For RGB888 format, you can use {{Lmin, Lmax, Amin, Amax, Bmin, Bmax}, ...} to define one or more thresholds.<br>Where the upper case L,A,B represent the L,A,B channels of the LAB image format, and min, max represent the minimum and maximum values of the corresponding channels.<br>**invert**: If true, the thresholds will be inverted before the operation. default is false.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**bins**: The number of bins to use for the histogram.<br>In GRAYSCALE format, setting range is [2, 256], default is 100.<br>In RGB888 format, setting range is [2, 100], default is 100.<br>**l_bins**: The number of bins to use for the l channel of the histogram. Only valid in RGB888 format.<br>If an invalid value is set, bins will be used instead. The setting range is [2, 100], default is 100.<br>**a_bins**: The number of bins to use for the a channel of the histogram.<br>Only valid in RGB888 format.The setting range is [2, 256], default is 256.<br>**b_bins**: The number of bins to use for the b channel of the histogram.<br>Only valid in RGB888 format. The setting range is [2, 256], default is 256.<br>**difference**: difference may be set to an image object to cause this method to operate on the difference image between the current image and the difference image object.<br>default is None.<br> **return** Returns image::Histogram object **static** False > C++ defination code: > ```cpp > image::Histogram get_histogram(std::vector<std::vector<int>> thresholds std::vector<std::vector<int>>(), bool invert false, std::vector<int> roi std::vector<int>(), int bins 1, int l_bins 100, int a_bins 256, int b_bins 256, image::Image *difference nullptr) > ``` #### get\\_statistics ```python def get_statistics(self, thresholds: list[list[int]] [], invert: bool False, roi: list[int] [], bins: int 1, l_bins: int 1, a_bins: int 1, b_bins: int 1, difference: Image None) > Statistics ``` Gets the statistics of the image. TODO: support in the feature item description **type** func **note** For GRAYSCALE format, Lmin and Lmax range is [0, 255]. For RGB888 format, Lmin and Lmax range is [0, 100]. **param** **thresholds**: You can define multiple thresholds.<br>For GRAYSCALE format, you can use {{Lmin, Lmax}, ...} to define one or more thresholds.<br>For RGB888 format, you can use {{Lmin, Lmax, Amin, Amax, Bmin, Bmax}, ...} to define one or more thresholds.<br>Where the upper case L,A,B represent the L,A,B channels of the LAB image format, and min, max represent the minimum and maximum values of the corresponding channels.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**bins**: The number of bins to use for the statistics. default is 1.<br>**l_bins**: The number of bins to use for the l channel of the statistics. default is 1.<br>**a_bins**: The number of bins to use for the a channel of the statistics. default is 1.<br>**b_bins**: The number of bins to use for the b channel of the statistics. default is 1.<br>**difference**: The difference image to use for the statistics. default is None.<br> **return** Returns the statistics of the image **static** False > C++ defination code: > ```cpp > image::Statistics get_statistics(std::vector<std::vector<int>> thresholds std::vector<std::vector<int>>(), bool invert false, std::vector<int> roi std::vector<int>(), int bins 1, int l_bins 1, int a_bins 1, int b_bins 1, image::Image *difference nullptr) > ``` #### get\\_regression ```python def get_regression(self, thresholds: list[list[int]] [], invert: bool False, roi: list[int] [], x_stride: int 2, y_stride: int 1, area_threshold: int 10, pixels_threshold: int 10, robust: bool False) > list[Line] ``` Gets the regression of the image. item description **type** func **note** For GRAYSCALE format, Lmin and Lmax range is [0, 255]. For RGB888 format, Lmin and Lmax range is [0, 100]. **param** **thresholds**: You can define multiple thresholds.<br>For GRAYSCALE format, you can use {{Lmin, Lmax}, ...} to define one or more thresholds.<br>For RGB888 format, you can use {{Lmin, Lmax, Amin, Amax, Bmin, Bmax}, ...} to define one or more thresholds.<br>Where the upper case L,A,B represent the L,A,B channels of the LAB image format, and min, max represent the minimum and maximum values of the corresponding channels.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**x_stride**: The x stride to use for the regression. default is 2.<br>**y_stride**: The y stride to use for the regression. default is 1.<br>**area_threshold**: The area threshold to use for the regression. default is 10.<br>**pixels_threshold**: The pixels threshold to use for the regression. default is 10.<br>**robust**: If true, the regression will be robust. default is false.<br> **return** Returns the regression of the image **static** False > C++ defination code: > ```cpp > std::vector<image::Line> get_regression(std::vector<std::vector<int>> thresholds std::vector<std::vector<int>>(), bool invert false, std::vector<int> roi std::vector<int>(), int x_stride 2, int y_stride 1, int area_threshold 10, int pixels_threshold 10, bool robust false) > ``` #### save ```python def save(self, path: str, quality: int 95) > maix.err.Err ``` Save image to file item description **type** func **param** **path**: file path<br>**quality**: image quality, by default(value is 95), support jpeg and png format<br> **return** error code, err::ERR_NONE is ok, other is error **static** False > C++ defination code: > ```cpp > err::Err save(const char *path, int quality 95) > ``` #### flood\\_fill ```python def flood_fill(self, x: int, y: int, seed_threshold: float 0.05, floating_threshold: float 0.05, color: Color ..., invert: bool False, clear_background: bool False, mask: Image None) > Image ``` Flood fills a region of the image starting from location x, y. item description **type** func **param** **x**: The x coordinate of the seed point.<br>**y**: The y coordinate of the seed point.<br>**seed_threshold**: The seed_threshold value controls how different any pixel in the fill area may be from the original starting pixel. default is 0.05.<br>**floating_threshold**: The floating_threshold value controls how different any pixel in the fill area may be from any neighbor pixels. default is 0.05.<br>**color**: The color to fill the region with. default is white.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**clear_background**: If true, the background will be cleared before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None. FIXME: the mask image works abnormally<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *flood_fill(int x, int y, float seed_threshold 0.05, float floating_threshold 0.05, image::Color color image::COLOR_WHITE, bool invert false, bool clear_background false, image::Image *mask nullptr) > ``` #### erode ```python def erode(self, size: int, threshold: int 1, mask: Image None) > Image ``` Erodes the image in place. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: The number of pixels in the kernel that are not 0. If it is less than or equal to the threshold, set the center pixel to black. default is (kernel_size 1).<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *erode(int size, int threshold 1, image::Image *mask nullptr) > ``` #### dilate ```python def dilate(self, size: int, threshold: int 0, mask: Image None) > Image ``` Dilates the image in place. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: The number of pixels in the kernel that are not 0. If it is greater than or equal to the threshold, set the center pixel to white. default is 0.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *dilate(int size, int threshold 0, image::Image *mask nullptr) > ``` #### open ```python def open(self, size: int, threshold: int 0, mask: Image None) > Image ``` Performs erosion and dilation on an image in order. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: As the threshold for erosion and dilation, the actual threshold for erosion is (kernel_size 1 threshold), the actual threshold for dialation is threshold. default is 0.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *open(int size, int threshold 0, image::Image *mask nullptr) > ``` #### close ```python def close(self, size: int, threshold: int 0, mask: Image None) > Image ``` Performs dilation and erosion on an image in order. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: As the threshold for erosion and dilation, the actual threshold for erosion is (kernel_size 1 threshold), the actual threshold for dialation is threshold. default is 0.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *close(int size, int threshold 0, image::Image *mask nullptr) > ``` #### top\\_hat ```python def top_hat(self, size: int, threshold: int 0, mask: Image None) > Image ``` Returns the image difference of the image and Image.open()’ed image. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: As the threshold for open method. default is 0.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *top_hat(int size, int threshold 0, image::Image *mask nullptr) > ``` #### black\\_hat ```python def black_hat(self, size: int, threshold: int 0, mask: Image None) > Image ``` Returns the image difference of the image and Image.close()’ed image. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: As the threshold for close method. default is 0.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *black_hat(int size, int threshold 0, image::Image *mask nullptr) > ``` #### find\\_blobs ```python def find_blobs(self, thresholds: list[list[int]] [], invert: bool False, roi: list[int] [], x_stride: int 2, y_stride: int 1, area_threshold: int 10, pixels_threshold: int 10, merge: bool False, margin: int 0, x_hist_bins_max: int 0, y_hist_bins_max: int 0) > list[Blob] ``` Finds all blobs in the image and returns a list of image.Blob class which describe each Blob.\\nPlease see the image.Blob object more more information. item description **type** func **note** For GRAYSCALE format, Lmin and Lmax range is [0, 255]. For RGB888 format, Lmin and Lmax range is [0, 100]. **param** **thresholds**: You can define multiple thresholds.<br>For GRAYSCALE format, you can use {{Lmin, Lmax}, ...} to define one or more thresholds.<br>For RGB888 format, you can use {{Lmin, Lmax, Amin, Amax, Bmin, Bmax}, ...} to define one or more thresholds.<br>Where the upper case L,A,B represent the L,A,B channels of the LAB image format, and min, max represent the minimum and maximum values of the corresponding channels.<br>**invert**: if true, will invert thresholds before find blobs, default is false<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**x_stride**: x stride is the number of x pixels to skip when doing the hough transform. default is 2<br>**y_stride**: y_stride is the number of y pixels to skip when doing the hough transform. default is 1<br>**area_threshold**: area threshold, if the blob area is smaller than area_threshold, the blob is not returned, default is 10<br>**pixels_threshold**: pixels threshold, if the blob pixels is smaller than area_threshold, the blob is not returned,, default is 10.<br>when x_stride and y_stride is equal to 1, pixels_threshold is equivalent to area_threshold<br>**merge**: if True merges all not filtered out blobs whos bounding rectangles intersect each other. default is false<br>**margin**: margin can be used to increase or decrease the size of the bounding rectangles for blobs during the intersection test.<br>For example, with a margin of 1 blobs whos bounding rectangles are 1 pixel away from each other will be merged. default is 0<br>**x_hist_bins_max**: if set to non zero populates a histogram buffer in each blob object with an x_histogram projection of all columns in the object. This value then sets the number of bins for that projection.<br>**y_hist_bins_max**: if set to non zero populates a histogram buffer in each blob object with an y_histogram projection of all rows in the object. This value then sets the number of bins for that projection.<br> **return** Return the blob when found blobs, format is (blob1, blob2, ...), you can use blob class methods to do more operations. **static** False > C++ defination code: > ```cpp > std::vector<image::Blob> find_blobs(std::vector<std::vector<int>> thresholds std::vector<std::vector<int>>(), bool invert false, std::vector<int> roi std::vector<int>(), int x_stride 2, int y_stride 1, int area_threshold 10, int pixels_threshold 10, bool merge false, int margin 0, int x_hist_bins_max 0, int y_hist_bins_max 0) > ``` #### find\\_lines ```python def find_lines(self, roi: list[int] [], x_stride: int 2, y_stride: int 1, threshold: float 1000, theta_margin: float 25, rho_margin: float 25) > list[Line] ``` Find lines in image item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**x_stride**: x stride is the number of x pixels to skip when doing the hough transform. default is 2<br>**y_stride**: y_stride is the number of y pixels to skip when doing the hough transform. default is 1<br>**threshold**: threshold threshold controls what lines are detected from the hough transform. Only lines with a magnitude greater than or equal to threshold are returned.<br>The right value of threshold for your application is image dependent. default is 1000.<br>**theta_margin**: theta_margin controls the merging of detected lines. default is 25.<br>**rho_margin**: rho_margin controls the merging of detected lines. default is 25.<br> **return** Return the line when found lines, format is (line1, line2, ...), you can use line class methods to do more operations **static** False > C++ defination code: > ```cpp > std::vector<image::Line> find_lines(std::vector<int> roi std::vector<int>(), int x_stride 2, int y_stride 1, double threshold 1000, double theta_margin 25, double rho_margin 25) > ``` #### find\\_line\\_segments ```python def find_line_segments(self, roi: list[int] [], merge_distance: int 0, max_theta_difference: int 15) > list[Line] ``` Finds all line segments in the image. item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**merge_distance**: The maximum distance between two lines to merge them. default is 0.<br>**max_theta_difference**: The maximum difference between two lines to merge them. default is 15.<br> **return** Return the line when found lines, format is (line1, line2, ...), you can use line class methods to do more operations **static** False > C++ defination code: > ```cpp > std::vector<image::Line> find_line_segments(std::vector<int> roi std::vector<int>(), int merge_distance 0, int max_theta_difference 15) > ``` #### find\\_circles ```python def find_circles(self, roi: list[int] [], x_stride: int 2, y_stride: int 1, threshold: int 2000, x_margin: int 10, y_margin: int 10, r_margin: int 10, r_min: int 2, r_max: int 1, r_step: int 2) > list[Circle] ``` Find circles in image item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**x_stride**: x stride is the number of x pixels to skip when doing the hough transform. default is 2<br>**y_stride**: y_stride is the number of y pixels to skip when doing the hough transform. default is 1<br>**threshold**: threshold controls what circles are detected from the hough transform. Only circles with a magnitude greater than or equal to threshold are returned.<br>The right value of threshold for your application is image dependent.<br>**x_margin**: x_margin controls the merging of detected circles. Circles which are x_margin, y_margin, and r_margin pixels apart are merged. default is 10<br>**y_margin**: y_margin controls the merging of detected circles. Circles which are x_margin, y_margin, and r_margin pixels apart are merged. default is 10<br>**r_margin**: r_margin controls the merging of detected circles. Circles which are x_margin, y_margin, and r_margin pixels apart are merged. default is 10<br>**r_min**: r_min controls the minimum circle radius detected. Increase this to speed up the algorithm. default is 2<br>**r_max**: r_max controls the maximum circle radius detected. Decrease this to speed up the algorithm. default is min(roi.w / 2, roi.h / 2)<br>**r_step**: r_step controls how to step the radius detection by. default is 2.<br> **return** Return the circle when found circles, format is (circle1, circle2, ...), you can use circle class methods to do more operations **static** False > C++ defination code: > ```cpp > std::vector<image::Circle> find_circles(std::vector<int> roi std::vector<int>(), int x_stride 2, int y_stride 1, int threshold 2000, int x_margin 10, int y_margin 10, int r_margin 10, int r_min 2, int r_max 1, int r_step 2) > ``` #### find\\_rects ```python def find_rects(self, roi: list[int] [], threshold: int 10000) > list[Rect] ``` Finds all rects in the image. item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**threshold**: The threshold to use for the rects. default is 10000.<br> **return** Returns the rects of the image **static** False > C++ defination code: > ```cpp > std::vector<image::Rect> find_rects(std::vector<int> roi std::vector<int>(), int threshold 10000) > ``` #### find\\_qrcodes ```python def find_qrcodes(self, roi: list[int] []) > list[QRCode] ``` Finds all qrcodes in the image. item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br> **return** Returns the qrcodes of the image **static** False > C++ defination code: > ```cpp > std::vector<image::QRCode> find_qrcodes(std::vector<int> roi std::vector<int>()) > ``` #### find\\_apriltags ```python def find_apriltags(self, roi: list[int] [], families: ApriltagFamilies ..., fx: float 1, fy: float 1, cx: int 1, cy: int 1) > list[AprilTag] ``` Finds all apriltags in the image. item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**families**: The families to use for the apriltags. default is TAG36H11.<br>**fx**: The camera X focal length in pixels, default is 1.<br>**fy**: The camera Y focal length in pixels, default is 1.<br>**cx**: The camera X center in pixels, default is image.width / 2.<br>**cy**: The camera Y center in pixels, default is image.height / 2.<br> **return** Returns the apriltags of the image **static** False > C++ defination code: > ```cpp > std::vector<image::AprilTag> find_apriltags(std::vector<int> roi std::vector<int>(), image::ApriltagFamilies families image::ApriltagFamilies::TAG36H11, float fx 1, float fy 1, int cx 1, int cy 1) > ``` #### find\\_datamatrices ```python def find_datamatrices(self, roi: list[int] [], effort: int 200) > list[DataMatrix] ``` Finds all datamatrices in the image. item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**effort**: Controls how much time to spend trying to find data matrix matches. default is 200.<br> **return** Returns the datamatrices of the image **static** False > C++ defination code: > ```cpp > std::vector<image::DataMatrix> find_datamatrices(std::vector<int> roi std::vector<int>(), int effort 200) > ``` #### find\\_barcodes ```python def find_barcodes(self, roi: list[int] []) > list[BarCode] ``` Finds all barcodes in the image. item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br> **return** Returns the barcodes of the image **static** False > C++ defination code: > ```cpp > std::vector<image::BarCode> find_barcodes(std::vector<int> roi std::vector<int>()) > ``` #### find\\_displacement ```python def find_displacement(self, template_image: Image, roi: list[int] [], template_roi: list[int] [], logpolar: bool False) > Displacement ``` Finds the displacement between the image and the template. TODO: support in the feature\\nnote: this method must be used on power of 2 image sizes item description **type** func **param** **template_image**: The template image.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**template_roi**: The region of interest rectangle (x, y, w, h) to work in. If not specified, it is equal to the image rectangle.<br>**logpolar**: If true, it will instead find rotation and scale changes between the two images. default is false.<br> **return** Returns the displacement of the image **static** False > C++ defination code: > ```cpp > image::Displacement find_displacement(image::Image &template_image, std::vector<int> roi std::vector<int>(), std::vector<int> template_roi std::vector<int>(), bool logpolar false) > ``` #### find\\_template ```python def find_template(self, template_image: Image, threshold: float, roi: list[int] [], step: int 2, search: TemplateMatch ...) > list[int] ``` Finds the template in the image. item description **type** func **param** **template_image**: The template image.<br>**threshold**: Threshold is floating point number (0.0 1.0) where a higher threshold prevents false positives while lowering the detection rate while a lower threshold does the opposite.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image. Only valid in SEARCH_EX mode.<br>**step**: The step size to use for the template. default is 2. Only valid in SEARCH_EX mode<br>**search**: The search method to use for the template. default is SEARCH_EX.<br> **return** Returns a bounding box tuple (x, y, w, h) for the matching location otherwise None. **static** False > C++ defination code: > ```cpp > std::vector<int> find_template(image::Image &template_image, float threshold, std::vector<int> roi std::vector<int>(), int step 2, image::TemplateMatch search image::TemplateMatch::SEARCH_EX) > ``` #### find\\_features ```python def find_features(self, cascade: int, threshold: float 0.5, scale: float 1.5, roi: list[int] []) > list[int] ``` Finds the features in the image. TODO: support in the feature item description **type** func **param** **cascade**: The cascade to use for the features. default is CASCADE_FRONTALFACE_ALT.<br>**threshold**: The threshold to use for the features. default is 0.5.<br>**scale**: The scale to use for the features. default is 1.5.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br> **return** Returns the features of the image **static** False > C++ defination code: > ```cpp > std::vector<int> find_features(int cascade, float threshold 0.5, float scale 1.5, std::vector<int> roi std::vector<int>()) > ``` #### find\\_lbp ```python def find_lbp(self, roi: list[int] []) > LBPKeyPoint ``` Finds the lbp in the image. TODO: support in the feature. item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br> **return** Returns the lbp of the image **static** False > C++ defination code: > ```cpp > image::LBPKeyPoint find_lbp(std::vector<int> roi std::vector<int>()) > ``` #### find\\_keypoints ```python def find_keypoints(self, roi: list[int] [], threshold: int 20, normalized: bool False, scale_factor: float 1.5, max_keypoints: int 100, corner_detector: CornerDetector ...) > ORBKeyPoint ``` Finds the keypoints in the image. TODO: support in the feature. item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**threshold**: The threshold to use for the keypoints. default is 20.<br>**normalized**: If true, the image will be normalized before the operation. default is false.<br>**scale_factor**: The scale factor to use for the keypoints. default is 1.5.<br>**max_keypoints**: The maximum number of keypoints to use for the keypoints. default is 100.<br>**corner_detector**: The corner detector to use for the keypoints. default is CORNER_AGAST.<br> **return** Returns the keypoints of the image **static** False > C++ defination code: > ```cpp > image::ORBKeyPoint find_keypoints(std::vector<int> roi std::vector<int>(), int threshold 20, bool normalized false, float scale_factor 1.5, int max_keypoints 100, image::CornerDetector corner_detector image::CornerDetector::CORNER_AGAST) > ``` #### find\\_edges ```python def find_edges(self, edge_type: EdgeDetector, roi: list[int] [], threshold: list[int] [100, 200]) > Image ``` Finds the edges in the image. item description **type** func **param** **edge_type**: The edge type to use for the edges. default is EDGE_CANNY.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**threshold**: The threshold to use for the edges. default is 20.<br> **return** Returns the edges of the image **static** False > C++ defination code: > ```cpp > image::Image* find_edges(image::EdgeDetector edge_type, std::vector<int> roi std::vector<int>(), std::vector<int> threshold std::vector<int>({100, 200})) > ``` #### find\\_hog ```python def find_hog(self, roi: list[int] [], size: int 8) > Image ``` Finds the hog in the image. TODO: support in the feature item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**size**: The size to use for the hog. default is 8.<br> **return** Returns the hog of the image **static** False > C++ defination code: > ```cpp > image::Image* find_hog(std::vector<int> roi std::vector<int>(), int size 8) > ``` #### match\\_lbp\\_descriptor ```python def match_lbp_descriptor(self, desc1: LBPKeyPoint, desc2: LBPKeyPoint) > int ``` Matches the lbp descriptor of the image. TODO: support in the feature item description **type** func **param** **desc1**: The descriptor to use for the match.<br>**desc2**: The descriptor to use for the match.<br> **return** Returns the match of the image **static** False > C++ defination code: > ```cpp > int match_lbp_descriptor(image::LBPKeyPoint &desc1, image::LBPKeyPoint &desc2) > ``` #### match\\_orb\\_descriptor ```python def match_orb_descriptor(self, desc1: ORBKeyPoint, desc2: ORBKeyPoint, threshold: int 95, filter_outliers: bool False) > KPTMatch ``` Matches the orb descriptor of the image. TODO: support in the feature item description **type** func **param** **desc1**: The descriptor to use for the match.<br>**desc2**: The descriptor to use for the match.<br>**threshold**: The threshold to use for the match. default is 95.<br>**filter_outliers**: If true, the image will be filter_outliers before the operation. default is false.<br> **return** Returns the match of the image **static** False > C++ defination code: > ```cpp > image::KPTMatch match_orb_descriptor(image::ORBKeyPoint &desc1, image::ORBKeyPoint &desc2, int threshold 95, bool filter_outliers false) > ```"},"/maixpy/api/maix/display.html":{"title":"maix.display","content":" title: maix.display maix.display module, control display device and show image on it > You can use `maix.display` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ## Function ### send\\_to\\_maixvision ```python def send_to_maixvision(img: maix.image.Image) > None ``` Send image to MaixVision work station if connected.\\nIf you want to debug your program an don't want to initialize display, use this method. item description **param** **img**: image to send, image.Image object<br> > C++ defination code: > ```cpp > void send_to_maixvision(image::Image &img) > ``` ## Class ### Display Display class > C++ defination code: > ```cpp > class Display > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, width: int 1, height: int 1, format: maix.image.Format ..., device: str None, open: bool True) > None ``` Construct a new Display object item description **type** func **param** **width**: display width, by default(value is 1) means auto detect,<br>if width > max device supported width, will auto set to max device supported width<br>**height**: display height, by default(value is 1) means auto detect,<br>if height > max device supported height, will auto set to max device supported height<br>**device**: display device name, you can get devices by list_devices method, by default(value is NULL(None in MaixPy)) means the first device<br>**open**: If true, display will automatically call open() after creation. default is true.<br> **static** False > C++ defination code: > ```cpp > Display(int width 1, int height 1, image::Format format image::FMT_RGB888, const char *device nullptr, bool open true) > ``` #### width ```python def width(self) > int ``` Get display width item description **type** func **return** width **static** False > C++ defination code: > ```cpp > int width() > ``` #### height ```python def height(self) > int ``` Get display height item description **type** func **param** **ch**: channel to get, by default(value is 0) means the first channel<br> **return** height **static** False > C++ defination code: > ```cpp > int height() > ``` #### size ```python def size(self) > list[int] ``` Get display size item description **type** func **param** **ch**: channel to get, by default(value is 0) means the first channel<br> **return** size A list type in MaixPy, [width, height] **static** False > C++ defination code: > ```cpp > std::vector<int> size() > ``` #### format ```python def format(self) > maix.image.Format ``` Get display format item description **type** func **return** format **static** False > C++ defination code: > ```cpp > image::Format format() > ``` #### open ```python def open(self, width: int 1, height: int 1, format: maix.image.Format ...) > maix.err.Err ``` open display device, if already opened, will return err.ERR_NONE. item description **type** func **param** **width**: display width, default is 1, means auto, mostly means max width of display support<br>**height**: display height, default is 1, means auto, mostly means max height of display support<br>**format**: display output format, default is RGB888<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err open(int width 1, int height 1, image::Format format image::FMT_INVALID) > ``` #### close ```python def close(self) > maix.err.Err ``` close display device item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err close() > ``` #### add\\_channel ```python def add_channel(self, width: int 1, height: int 1, format: maix.image.Format ..., open: bool True) > Display ``` Add a new channel and return a new Display object, you can use close() to close this channel. item description **type** func **attention** If a new disp channel is created, it is recommended to set fit image::FIT_COVER or fit image::FIT_FILL when running show for the main channel,<br>otherwise the display of the new disp channel may be abnormal. **param** **width**: display width, default is 1, means auto, mostly means max width of display support. Maximum width must not exceed the main channel.<br>**height**: display height, default is 1, means auto, mostly means max height of display support. Maximum height must not exceed the main channel.<br>**format**: display output format, default is FMT_BGRA8888<br>**open**: If true, display will automatically call open() after creation. default is true.<br> **return** new Display object **static** False > C++ defination code: > ```cpp > display::Display *add_channel(int width 1, int height 1, image::Format format image::FMT_BGRA8888, bool open true) > ``` #### is\\_opened ```python def is_opened(self) > bool ``` check display device is opened or not item description **type** func **return** opened or not, bool type **static** False > C++ defination code: > ```cpp > bool is_opened() > ``` #### is\\_closed ```python def is_closed(self) > bool ``` check display device is closed or not item description **type** func **return** closed or not, bool type **static** False > C++ defination code: > ```cpp > bool is_closed() > ``` #### show ```python def show(self, img: maix.image.Image, fit: maix.image.Fit ...) > maix.err.Err ``` show image on display device, and will also send to MaixVision work station if connected. item description **type** func **param** **img**: image to show, image.Image object,<br>if the size of image smaller than display size, will show in the center of display;<br>if the size of image bigger than display size, will auto resize to display size and keep ratio, fill blank with black color.<br>**fit**: image in screen fit mode, by default(value is image.FIT_CONTAIN), @see image.Fit for more details<br>e.g. image.FIT_CONTAIN means resize image to fit display size and keep ratio, fill blank with black color.<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err show(image::Image &img, image::Fit fit image::FIT_CONTAIN) > ``` #### device ```python def device(self) > str ``` Get display device path item description **type** func **return** display device path **static** False > C++ defination code: > ```cpp > std::string device() > ``` #### set\\_backlight ```python def set_backlight(self, value: float) > None ``` Set display backlight item description **type** func **param** **value**: backlight value, float type, range is [0, 100]<br> **static** False > C++ defination code: > ```cpp > void set_backlight(float value) > ``` #### get\\_backlight ```python def get_backlight(self) > float ``` Get display backlight item description **type** func **return** value backlight value, float type, range is [0, 100] **static** False > C++ defination code: > ```cpp > float get_backlight() > ``` #### set\\_hmirror ```python def set_hmirror(self, en: bool) > maix.err.Err ``` Set display mirror item description **type** func **param** **en**: enable/disable mirror<br> **static** False > C++ defination code: > ```cpp > err::Err set_hmirror(bool en) > ``` #### set\\_vflip ```python def set_vflip(self, en: bool) > maix.err.Err ``` Set display flip item description **type** func **param** **en**: enable/disable flip<br> **static** False > C++ defination code: > ```cpp > err::Err set_vflip(bool en) > ```"},"/maixpy/api/maix/protocol.html":{"title":"maix.protocol","content":" title: maix.protocol maix.protocol module > You can use `maix.protocol` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ### CMD protocol cmd, more doc see MaixCDK document's convention doc item describe **note** max app custom CMD value should < CMD_APP_MAX **values** **CMD_APP_MAX**: 200, max app custom CMD value should < CMD_APP_MAX<br>**CMD_SET_REPORT**: set auto upload data mode<br>**CMD_APP_LIST**: <br>**CMD_START_APP**: <br>**CMD_EXIT_APP**: <br>**CMD_CUR_APP_INFO**: <br>**CMD_APP_INFO**: <br>**CMD_KEY**: <br>**CMD_TOUCH**: <br> > C++ defination code: > ```cpp > enum CMD > { > CMD_APP_MAX 0xC8, // 200, max app custom CMD value should < CMD_APP_MAX > > CMD_SET_REPORT 0xF8, // set auto upload data mode > CMD_APP_LIST 0xF9, > CMD_START_APP 0xFA, > CMD_EXIT_APP 0xFB, > CMD_CUR_APP_INFO 0xFC, > CMD_APP_INFO 0xFD, > CMD_KEY 0xFE, > CMD_TOUCH 0xFF, > } > ``` ### FLAGS protocol flags, more doc see MaixCDK document's convention doc item describe **values** **FLAG_REQ**: <br>**FLAG_RESP**: <br>**FLAG_IS_RESP_MASK**: <br>**FLAG_RESP_OK**: <br>**FLAG_RESP_ERR**: <br>**FLAG_RESP_OK_MASK**: <br>**FLAG_REPORT**: <br>**FLAG_REPORT_MASK**: <br>**FLAG_VERSION_MASK**: <br> > C++ defination code: > ```cpp > enum FLAGS > { > FLAG_REQ 0x00, > FLAG_RESP 0x80, > FLAG_IS_RESP_MASK 0x80, > > FLAG_RESP_OK 0x40, > FLAG_RESP_ERR 0x00, > FLAG_RESP_OK_MASK 0x40, > > FLAG_REPORT 0x20, > FLAG_REPORT_MASK 0x20, > > FLAG_VERSION_MASK 0x03 > } > ``` ## Variable ### VERSION protocol version item description **value** **1** **readonly** True > C++ defination code: > ```cpp > const uint8_t VERSION 1 > ``` ### HEADER protocol header item description **readonly** False > C++ defination code: > ```cpp > extern uint32_t HEADER > ``` ## Function ### crc16\\_IBM ```python def crc16_IBM(data: maix.Bytes(bytes)) > int ``` CRC16 IBM item description **param** **data**: data, bytes type.<br> **return** CRC16 IBM value, uint16_t type. > C++ defination code: > ```cpp > uint16_t crc16_IBM(const Bytes *data) > ``` ## Class ### MSG protocol msg > C++ defination code: > ```cpp > class MSG > ``` #### version protocol version item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > uint8_t version > ``` #### resp\\_ok Indicate response message type, true means CMD valid and the CMD processed correctly, (only for response msg) item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > uint8_t resp_ok > ``` #### has\\_been\\_replied Flag whether CMD has been processed and responded to CMD sender.\\nE.g. CMD CMD_START_APP will be automatically processed in CommProtocol.get_msg function,\\nso the return msg will set this flag to true. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool has_been_replied{false} > ``` #### cmd CMD value item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > uint8_t cmd > ``` #### is\\_resp message is response or not, contrast with is_req item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool is_resp > ``` #### body\\_len Message body length, read only, use set_body() to update item description **type** var **attention** DO NOT manually change this value **static** False **readonly** False > C++ defination code: > ```cpp > int body_len > ``` #### encode\\_resp\\_ok ```python def encode_resp_ok(*args, **kwargs) ``` Encode response ok(success) message item description **type** func **param** **body**: response body, can be null<br> **return** encoded data, if nullptr, means error, and the error code is err.Err **static** False > C++ defination code: > ```cpp > Bytes *encode_resp_ok(Bytes *body nullptr) > ``` #### encode\\_report ```python def encode_report(*args, **kwargs) ``` Encode proactively report message item description **type** func **param** **body**: report body, can be null<br> **return** encoded data, if nullptr, means error, and the error code is err.Err **static** False > C++ defination code: > ```cpp > Bytes *encode_report(Bytes *body nullptr) > ``` #### encode\\_resp\\_err ```python def encode_resp_err(*args, **kwargs) ``` Encode response error message item description **type** func **param** **code**: error code<br>**msg**: error message<br> **return** encoded data, if nullptr, means error, and the error code is err.Err **static** False > C++ defination code: > ```cpp > Bytes *encode_resp_err(err::Err code, const std::string &msg) > ``` #### set\\_body ```python def set_body(self, body_new: maix.Bytes(bytes)) > None ``` Update message body item description **type** func **param** **body_new**: new body data<br> **static** False > C++ defination code: > ```cpp > void set_body(Bytes *body_new) > ``` #### get\\_body ```python def get_body(*args, **kwargs) ``` Get message body item description **type** func **return** message body, bytes type **static** False > C++ defination code: > ```cpp > Bytes *get_body() > ``` ### Protocol Communicate protocol > C++ defination code: > ```cpp > class Protocol > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, buff_size: int 1024, header: int 3148663466) > None ``` Construct a new Protocol object item description **type** func **param** **buff_size**: Data queue buffer size<br> **static** False > C++ defination code: > ```cpp > Protocol(int buff_size 1024, uint32_t header maix::protocol::HEADER) > ``` #### buff\\_size ```python def buff_size(self) > int ``` Data queue buffer size item description **type** func **static** False > C++ defination code: > ```cpp > int buff_size() > ``` #### push\\_data ```python def push_data(self, new_data: maix.Bytes(bytes)) > maix.err.Err ``` Add data to data queue item description **type** func **param** **new_data**: new data<br> **return** error code, maybe err.Err.ERR_BUFF_FULL **static** False > C++ defination code: > ```cpp > err::Err push_data(const Bytes *new_data) > ``` #### decode ```python def decode(self, new_data: maix.Bytes(bytes) None) > MSG ``` Decode data in data queue and return a message item description **type** func **param** **new_data**: new data add to data queue, if null, only decode.<br> **return** decoded message, if nullptr, means no message decoded. **static** False > C++ defination code: > ```cpp > protocol::MSG *decode(const Bytes *new_data nullptr) > ``` #### encode\\_resp\\_ok ```python def encode_resp_ok(*args, **kwargs) ``` Encode response ok(success) message to buffer item description **type** func **param** **cmd**: CMD value<br>**body**: response body, can be null<br> **return** encoded data, if nullptr, means error, and the error code is err.Err **static** False > C++ defination code: > ```cpp > Bytes *encode_resp_ok(uint8_t cmd, Bytes *body nullptr) > ``` #### encode\\_report ```python def encode_report(*args, **kwargs) ``` Encode proactively report message to buffer item description **type** func **param** **cmd**: CMD value<br>**body**: report body, can be null<br> **return** encoded data, if nullptr, means error, and the error code is err.Err **static** False > C++ defination code: > ```cpp > Bytes *encode_report(uint8_t cmd, Bytes *body nullptr) > ``` #### encode\\_resp\\_err ```python def encode_resp_err(*args, **kwargs) ``` Encode response error message to buffer item description **type** func **param** **cmd**: CMD value<br>**code**: error code<br>**msg**: error message<br> **return** encoded data, if nullptr, means error, and the error code is err.Err **static** False > C++ defination code: > ```cpp > Bytes *encode_resp_err(uint8_t cmd, err::Err code, const std::string &msg) > ```"},"/maixpy/api/maix/app.html":{"title":"maix.app","content":" title: maix.app maix.app module > You can use `maix.app` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ## Function ### app\\_id ```python def app_id() > str ``` Get current APP ID. item description **return** APP ID. > C++ defination code: > ```cpp > string app_id() > ``` ### set\\_app\\_id ```python def set_app_id(app_id: str) > str ``` Set current APP ID. item description **param** **app_id**: APP ID.<br> > C++ defination code: > ```cpp > string set_app_id(const string &app_id) > ``` ### get\\_apps\\_info\\_path ```python def get_apps_info_path() > str ``` Get APP info file path. > C++ defination code: > ```cpp > string get_apps_info_path() > ``` ### get\\_apps\\_info ```python def get_apps_info(ignore_launcher: bool False, ignore_app_store: bool False) > list[APP_Info] ``` Get APP info list. item description **param** **ignore_launcher**: if true, ignore launcher APP. default false.<br>**ignore_app_store**: if true, ignore app store APP. default false.<br> **return** APP info list. APP_Info object list. > C++ defination code: > ```cpp > vector<app::APP_Info> &get_apps_info(bool ignore_launcher false, bool ignore_app_store false) > ``` ### get\\_app\\_info ```python def get_app_info(app_id: str) > APP_Info ``` Get app info by app id. item description **return** app.APP_Info type. > C++ defination code: > ```cpp > app::APP_Info get_app_info(const std::string &app_id) > ``` ### get\\_app\\_data\\_path ```python def get_app_data_path() > str ``` Get APP info, APP can store private data in this directory. item description **return** APP data path \"./data\", just return the data folder in current path because APP executed in app install path or project path.<br>So, you must execute your program in you project path to use the project/data folder when you debug your APP. > C++ defination code: > ```cpp > string get_app_data_path() > ``` ### get\\_app\\_path ```python def get_app_path(app_id: str '') > str ``` Get APP path. item description **param** **app_id**: APP ID, if empty, return current APP path, else return the APP path by app_id.<br> **return** APP path, just return the current path because APP executed in app install path or project path.<br>So, you must execute your program in you project path to use the project/data folder when you debug your APP. > C++ defination code: > ```cpp > string get_app_path(const string &app_id \"\") > ``` ### get\\_tmp\\_path ```python def get_tmp_path() > str ``` Get global temporary data path, APPs can use this path as temporary data directory. item description **return** temporary data path. > C++ defination code: > ```cpp > string get_tmp_path() > ``` ### get\\_share\\_path ```python def get_share_path() > str ``` Get data path of share, shared data like picture and video will put in this directory item description **return** share data path. > C++ defination code: > ```cpp > string get_share_path() > ``` ### get\\_picture\\_path ```python def get_picture_path() > str ``` Get picture path of share, shared picture will put in this directory item description **return** share picture path. > C++ defination code: > ```cpp > string get_picture_path() > ``` ### get\\_video\\_path ```python def get_video_path() > str ``` Get video path of share, shared video will put in this directory item description **return** share video path. > C++ defination code: > ```cpp > string get_video_path() > ``` ### get\\_font\\_path ```python def get_font_path() > str ``` Get font path of share, shared font will put in this directory item description **return** share font path. > C++ defination code: > ```cpp > string get_font_path() > ``` ### get\\_icon\\_path ```python def get_icon_path() > str ``` Get icon path of share, shared icon will put in this directory item description **return** share icon path. > C++ defination code: > ```cpp > string get_icon_path() > ``` ### get\\_sys\\_config\\_kv ```python def get_sys_config_kv(item: str, key: str, value: str '', from_cache: bool True) > str ``` Get system config item value. item description **param** **item**: name of setting item, e.g. wifi, language. more see settings APP.<br>**key**: config key, e.g. for wifi, key can be ssid, for language, key can be locale.<br>**value**: default value, if not found, return this value.<br>**from_cache**: if true, read from cache, if false, read from file.<br> **return** config value, always string type, if not found, return empty string. > C++ defination code: > ```cpp > string get_sys_config_kv(const string &item, const string &key, const string &value \"\", bool from_cache true) > ``` ### get\\_app\\_config\\_kv ```python def get_app_config_kv(item: str, key: str, value: str '', from_cache: bool True) > str ``` Get APP config item value. item description **param** **item**: name of setting item, e.g. user_info<br>**key**: config key, e.g. for user_info, key can be name, age etc.<br>**value**: default value, if not found, return this value.<br>**from_cache**: if true, read from cache, if false, read from file.<br> **return** config value, always string type, if not found, return empty string. > C++ defination code: > ```cpp > string get_app_config_kv(const string &item, const string &key, const string &value \"\", bool from_cache true) > ``` ### set\\_app\\_config\\_kv ```python def set_app_config_kv(item: str, key: str, value: str, write_file: bool True) > maix.err.Err ``` Set APP config item value. item description **param** **item**: name of setting item, e.g. user_info<br>**key**: config key, e.g. for user_info, key can be name, age etc.<br>**value**: config value, always string type.<br>**write_file**: if true, write to file, if false, just write to cache.<br> **return** err::Err > C++ defination code: > ```cpp > err::Err set_app_config_kv(const string &item, const string &key, const string &value, bool write_file true) > ``` ### get\\_app\\_config\\_path ```python def get_app_config_path() > str ``` Get APP config path, ini format, so you can use your own ini parser to parse it like `configparser` in Python.\\nAll APP config info is recommended to store in this file. item description **return** APP config path(ini format). > C++ defination code: > ```cpp > string get_app_config_path() > ``` ### set\\_exit\\_msg ```python def set_exit_msg(code: maix.err.Err, msg: str) > maix.err.Err ``` Set APP exit code and exit message.\\nIf code ! 0, the launcher will show a dialog to user, and display the msg. item description **param** **code**: exit code, 0 means success, other means error, if code is 0, do nothing.<br>**msg**: exit message, if code is 0, msg is not used.<br> **return** exit code, the same as arg @code. > C++ defination code: > ```cpp > err::Err set_exit_msg(err::Err code, const string &msg) > ``` ### get\\_exit\\_msg ```python def get_exit_msg(cache: bool False) > tuple[str, maix.err.Err, str] ``` Get APP exit code and exit message. item description **param** **cache**: if true, read from cache, if false, read from file. default false.<br> **return** exit return app_id, exit code and exit message. > C++ defination code: > ```cpp > tuple<string, err::Err, string> get_exit_msg(bool cache false) > ``` ### have\\_exit\\_msg ```python def have_exit_msg(cache: bool False) > bool ``` Check if have exit msg item description **param** **cache**: if true, just check from cache, if false, check from file. default false.<br> **return** true if have exit msg, false if not. > C++ defination code: > ```cpp > bool have_exit_msg(bool cache false) > ``` ### switch\\_app ```python def switch_app(app_id: str, idx: int 1, start_param: str '') > None ``` Exit this APP and start another APP(by launcher).\\nCall this API will call set_exit_flag(true), you should check app::need_exit() in your code.\\nAnd exit this APP if app::need_exit() return true. item description **param** **app_id**: APP ID which will be started. app_id and idx must have one is valid.<br>**idx**: APP index. app_id and idx must have one is valid.<br>**start_param**: string type, will send to app, app can get this param by `app.get_start_param()`<br> **attention** If app id or idx the same as current app, do nothing. > C++ defination code: > ```cpp > void switch_app(const string &app_id, int idx 1, const std::string &start_param \"\") > ``` ### get\\_start\\_param ```python def get_start_param() > str ``` Get start param set by caller item description **return** param, string type > C++ defination code: > ```cpp > const std::string get_start_param() > ``` ### need\\_exit ```python def need_exit() > bool ``` Shoule this APP exit? item description **return** true if this APP should exit, false if not. **attention** This API is a function, not a variable. > C++ defination code: > ```cpp > bool need_exit() > ``` ### running ```python def running() > bool ``` App should running? The same as !app::need_exit() (not app::need_exit() in MaixPy). item description **return** true if this APP should running, false if not. **attention** This API is a function, not a variable. > C++ defination code: > ```cpp > bool running() > ``` ### set\\_exit\\_flag ```python def set_exit_flag(exit: bool) > None ``` Set exit flag. You can get exit flag by app.need_exit(). item description **param** **exit**: true if this APP should exit, false if not.<br> > C++ defination code: > ```cpp > void set_exit_flag(bool exit) > ``` ## Class ### Version APP version > C++ defination code: > ```cpp > class Version > ``` #### \\_\\_str\\_\\_ ```python def __str__(self) > str ``` Convert to string, e.g. 1.0.0 item description **type** func **static** False > C++ defination code: > ```cpp > std::string __str__() > ``` #### from\\_str ```python def from_str(version_str: str) > Version ``` Convert from string, e.g. \\\"1.0.0\\\" item description **type** func **static** True > C++ defination code: > ```cpp > static app::Version from_str(const string &version_str) > ``` ### APP\\_Info APP info > C++ defination code: > ```cpp > class APP_Info > ``` #### id APP id item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > string id > ``` #### name APP name item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > string name > ``` #### icon APP icon item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > string icon > ``` #### version APP version item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > Version version > ``` #### exec APP exec item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > string exec > ``` #### author APP author item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > string author > ``` #### desc APP desc item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > string desc > ``` #### names APP names item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > map<string, string> names > ``` #### descs APP descs item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > map<string, string> descs > ```"},"/maixpy/api/maix/ext_dev.html":{"title":"maix.ext_dev","content":" title: maix.ext_dev maix.ext_dev module > You can use `maix.ext_dev` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module module brief [imu](./ext_dev/imu.html) maix.ext_dev.imu module [qmi8658](./ext_dev/qmi8658.html) maix.ext_dev.qmi8658 module [tmc2209](./ext_dev/tmc2209.html) maix.ext_dev.tmc2209 module [bm8563](./ext_dev/bm8563.html) maix.ext_dev.bm8563 module ## Enum ## Variable ## Function ## Class"},"/maixpy/api/maix/comm.html":{"title":"maix.comm","content":" title: maix.comm maix.comm module > You can use `maix.comm` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module No module ## Enum ## Variable ## Function ### add\\_default\\_comm\\_listener Add default CommProtocol listener.\\nWhen the application uses this port, the listening thread will immediately\\nrelease the port resources and exit. If you need to start the default listening thread again,\\nplease release the default port resources and then call this function. > C++ defination code: > ```cpp > void add_default_comm_listener() > ``` ### rm\\_default\\_comm\\_listener Remove default CommProtocol listener. item description **return** bool type. > C++ defination code: > ```cpp > bool rm_default_comm_listener() > ``` ## Class ### CommProtocol Class for communication protocol > C++ defination code: > ```cpp > class CommProtocol > ``` #### \\_\\_init\\_\\_ ```python def __init__(self, buff_size: int 1024, header: int 3148663466) > None ``` Construct a new CommProtocol object item description **type** func **param** **buff_size**: buffer size, default to 1024 bytes<br> **static** False > C++ defination code: > ```cpp > CommProtocol(int buff_size 1024, uint32_t header maix::protocol::HEADER) > ``` #### get\\_msg ```python def get_msg(self, timeout: int 0) > ... ``` Read data to buffer, and try to decode it as maix.protocol.MSG object item description **type** func **param** **timeout**: unit ms, 0 means return immediatly, 1 means block util have msg, >0 means block until have msg or timeout.<br> **return** decoded data, if nullptr, means no valid frame found.<br>Attentioin, delete it after use in C++. **static** False > C++ defination code: > ```cpp > protocol::MSG *get_msg(int timeout 0) > ``` #### resp\\_ok ```python def resp_ok(self, cmd: int, body: maix.Bytes(bytes) None) > maix.err.Err ``` Send response ok(success) message item description **type** func **param** **cmd**: CMD value<br>**body**: response body, can be null<br> **return** encoded data, if nullptr, means error, and the error code is err.Err.<br>Attentioin, delete it after use in C++. **static** False > C++ defination code: > ```cpp > err::Err resp_ok(uint8_t cmd, Bytes *body nullptr) > ``` #### report ```python def report(self, cmd: int, body: maix.Bytes(bytes) None) > maix.err.Err ``` Send report message item description **type** func **param** **cmd**: CMD value<br>**body**: report body, can be null<br> **return** encoded data, if nullptr, means error, and the error code is err.Err.<br>Attentioin, delete it after use in C++. **static** False > C++ defination code: > ```cpp > err::Err report(uint8_t cmd, Bytes *body nullptr) > ``` #### resp\\_err ```python def resp_err(self, cmd: int, code: maix.err.Err, msg: str) > maix.err.Err ``` Encode response error message to buffer item description **type** func **param** **cmd**: CMD value<br>**code**: error code<br>**msg**: error message<br> **return** encoded data, if nullptr, means error, and the error code is err.Err.<br>Attentioin, delete it after use in C++. **static** False > C++ defination code: > ```cpp > err::Err resp_err(uint8_t cmd, err::Err code, const std::string &msg) > ```"}}